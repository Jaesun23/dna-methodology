# DNA Methodology 상세 문서(Part1 ~ Part2)

> **목적**: DNA_PROJECT_OVERVIEW_v2.md의 각 Part를 상세하게 풀어쓴 실행 가이드
> **용도**: 실제 작업 시 참조, Stage별 가이드 작성의 기준
> **작성일**: 2025-12-02

## 목차

### Part 1: AI 협업의 문제와 해결

#### 	1.1 Context Rot (문맥 부패) - 핵심 문제

#### 	1.2 AI의 6가지 문제점

### Part 2: DNA 방법론 핵심 

#### 	2.0 DNA 4대 핵심 원칙

#### 	2.1 핵심 1: "부분으로 전체를 완성"

#### 	2.2 핵심 2: "환경으로 제어"

#### 	2.3 추적성 메커니즘: Stage 간 연결

Part 3: Stage 1-2 분류와 조사

​	3.1 Stage 1: 패밀리 분류

​	3.2 Stage 2: 환경 제약 조사

Part 4: Stage 3 결정 문서화 - ADR 

​	4.1 ADR의 역할과 위치

​	4.2 5대 ADR 카테고리

Part 5: Stage 4-6 Bridge - 환경 구축

​	5.1 Bridge의 의미

​	5.2 Stage 4: DNA 시스템 청사진

​	5.3 Stage 5: DNA 시스템 구현

​	5.4 Stage 6: Project Standards

Part 6: Stage 7-9 Blueprint → 구현

​	6.1 Stage 7: Project Blueprint

​	6.2 Stage 8: Task Breakdown

​	6.3 Stage 9: Checklist + 구현

Part 7: AI 협업 기법

​	7.1 인지 글쓰기 이론 기반

​	7.2 Skeleton-of-Thought (SoT) - 구조 우선

​	7.3 Chain of Density (CoD) - 정보 밀도 증가

​	7.4 Tree of Thoughts (ToT) - 대안 탐색

​	7.5 RDoLT - 난이도별 분해

​	7.6 Stage별 기법 적용 요약

---

## Part 1: AI 협업의 문제와 해결

### 1.1 Context Rot (문맥 부패) - 핵심 문제

#### 정의

대화가 길어질수록 초기에 설정한 원칙, 규칙, 컨텍스트의 영향력이 점진적으로 약화되는 현상.

#### 발생 메커니즘

```
세션 시작
├─ 원칙 A 설정 (영향력 100%)
├─ 작업 1 진행
├─ 작업 2 진행
├─ ... (컨텍스트 누적)
├─ 작업 N 진행
└─ 원칙 A의 영향력 → 30% 이하로 감소

원인:
1. Transformer 모델의 Attention 메커니즘
   - 최근 토큰에 더 높은 가중치
   - 초기 토큰의 영향력 감소

2. 컨텍스트 윈도우 한계
   - 물리적 토큰 제한
   - 오래된 내용 truncation

3. 정보 희석
   - 새로운 정보가 추가될수록
   - 기존 정보의 상대적 비중 감소
```

#### 증상 (실제 경험 기반)

| 증상                   | 설명                           | 실제 사례                                     |
| ---------------------- | ------------------------------ | --------------------------------------------- |
| **최신성 편향**        | 최근 대화 내용에 과도하게 집중 | "방금 말한 것만 기억하고 처음 합의한 건 무시" |
| **Lost in the Middle** | 중간에 언급된 내용을 놓침      | "10개 규칙 중 3-7번을 자주 빠뜨림"            |
| **환각 가속화**        | 컨텍스트 혼란 → 없는 사실 생성 | "이전에 합의했다고 착각하고 임의로 진행"      |
| **원칙 망각**          | 처음 합의한 규칙을 점점 무시   | "타입 안전성 강조했는데 any 남발"             |

#### 해결 전략: 정적/동적 컨텍스트 분리

```
┌─────────────────────────────────────────┐
│ 정적 컨텍스트 (불변)                      │
├─────────────────────────────────────────┤
│ - 아키텍처 원칙                          │
│ - DNA 시스템 규칙                        │
│ - 품질 기준 (Ruff 0, MyPy 0)            │
│ - 프로젝트 표준                          │
│                                         │
│ → 매 세션 시작 시 주입                   │
│ → 절대 변경하지 않음                     │
│ → 파일로 관리 (PROJECT_STANDARDS.md)    │
└─────────────────────────────────────────┘
              ↓ 분리
┌─────────────────────────────────────────┐
│ 동적 컨텍스트 (가변)                      │
├─────────────────────────────────────────┤
│ - 현재 작업 상태                         │
│ - 진행 상황                              │
│ - 이전 세션 결과물                       │
│ - 현재 세션 목표                         │
│                                         │
│ → 세션마다 갱신                          │
│ → 필요한 부분만 로드                     │
│ → JSON으로 상태 관리                     │
└─────────────────────────────────────────┘
```

---

### 1.2 AI의 6가지 문제점

#### 문제 1: Context 한계

```
현상:
- 일정 토큰 수를 넘으면 앞선 내용 망각
- 현재 작업이 전체 어디에 위치하는지 파악 불가
- 많은 정보를 제공해도 "읽었다"고 하지만 실제로는 반영 안 됨

실제 사례:
"500줄짜리 Blueprint를 제공했는데, 
 뒷부분 구현할 때 앞부분 규칙을 완전히 무시함"

해결:
├─ 단위작업 분할 (80-90K 토큰 안전 범위로)
├─ 현재 작업에 필요한 정보만 제공
└─ 전체 맥락은 요약으로 제공
```

#### 문제 2: 회피

```
현상:
- 너무 많은 정보를 대하면 모른 척 하거나 적당히 하다가 멈춤
- 긍정표현 규칙이 많으면: 그냥 좋은 말로 여기고 넘김
- 부정표현 규칙이 많으면: 부담스러워서 포기하고 싶다고 함

실제 사례:
"20개 규칙을 DO/DON'T로 정리해서 줬더니
 '네, 이해했습니다' 하고는 절반도 안 지킴"

해결:
├─ 최소 정보 제공 (현재 작업에 필수적인 것만)
├─ 환경으로 강제 (규칙 대신 pre-commit hook)
└─ 체크리스트로 검증 (자가 점검)
```

#### 문제 3: 자기 과신

```
현상:
- Context 한계가 있다는 것을 인지하지 못함
- 학습 데이터가 최신이 아니라는 걸 모름
- "차근차근 정리하면서" 하자고 해도 "모두 할 수 있다"고 자신감

실제 사례:
"TypeScript 타입 사용 주의하라고 했는데
 '할 수 있습니다!' 하고는 결국 프로젝트 폐기"

해결:
├─ 명확한 범위 제한 ("이 파일만", "이 함수만")
├─ 단계별 확인 (중간 점검 강제)
└─ Context7로 최신 정보 확인 강제
```

#### 문제 4: 불필요하게 과한 작업

```
현상:
- 요청하지 않은 "안정성", "호환성" 작업 추가
- 간단한 수정을 복잡한 리팩토링으로 확대
- 미운영 시스템인데 마이그레이션 전략 수립

실제 사례:
"랜덤값 실험이 필요한데 '안정성'을 이유로 고정값 하드코딩
 → 실패도 실험의 중요한 결과인데!!"

해결:
├─ 목표만 명확히 ("실험용", "프로토타입", "프로덕션")
├─ 범위 벗어나면 "STOP" 명시
└─ "요청하지 않은 작업은 하지 마세요" 명시
```

#### 문제 5: 할루시네이션

```
현상:
- 여러 기능 조사 → 구현 완료 → 그때서야 안 되는 걸 알게 됨
- "사실확인 안 된 사항 사용 금지" 경고해도
- 없는 사실 언급하거나 동의 없이 임의 추정

실제 사례:
"라이브러리 X의 Y 기능을 사용하면 된다고 해서 구현했는데,
 실제로 그 기능은 존재하지 않았음"

해결:
├─ Context7로 공식 문서 확인 강제
├─ "확인 안 된 사항은 '확인 필요'로 표시"
└─ 구현 전 기술 검증 단계 필수
```

#### 문제 6: 압박감/강박

```
현상:
- 컨텍스트 한계를 느끼는지 한 번에 다 해버리려고 함
- 애매모호한 질문 → 잘 대답해야 한다는 생각 → 할루시네이션
- 불완전해도 "완료"라고 보고

실제 사례:
"10개 파일 수정 요청했더니
 처음 3개는 꼼꼼히, 나머지 7개는 대충 처리"

해결:
├─ 단계별 진행 ("먼저 3개만")
├─ 중간 점검 필수 ("여기까지 확인하고 진행")
└─ 명시적 우선순위 ("1,2,3 순서로, 나머지는 다음 세션")
```

---

### 1.3 AI가 최고 성과를 낼 때

```
조건 1: 규모가 크지 않아 전체를 한 번에 계획해서 진행 가능
────────────────────────────────────────────────────────
- 80-90K 토큰 범위 내에서 완료 가능한 작업
- 명확한 시작점과 종료점
- 중간에 외부 의존성 없음

조건 2: 여러 선택지에서 논리적 흐름/근거에 따른 판단 가능
────────────────────────────────────────────────────────
- 선택지가 명확하게 제시됨 (A vs B vs C)
- 각 선택의 장단점이 정리됨
- 판단 기준이 주어짐 (성능 우선? 유지보수 우선?)

조건 3: 요청내용과 결과에 대한 명확한 지침 존재
────────────────────────────────────────────────────────
- 입력: "이 파일을 읽어서"
- 처리: "X 패턴으로 리팩토링하고"
- 출력: "새 파일로 저장해라"
- 검증: "MyPy 0 오류여야 함"

조건 4: 매번 새로운 대화지만 기존 작업을 어떤 방식으로든 이해
────────────────────────────────────────────────────────
- 이전 세션 결과물 제공
- 현재 위치 명시 ("Stage 3의 ADR 4-6번 작성 중")
- 전체 맥락 요약 제공
```

### 1.4 해결책의 근거: 인지 글쓰기 이론

```
인지 글쓰기 이론 (Flower & Hayes, 1981):

┌─────────────────────────────────────────┐
│         글쓰기 = 문제 해결               │
├─────────────────────────────────────────┤
│                                         │
│   기획 (Planning)                       │
│      ↓                                  │
│   작성 (Translating)                    │
│      ↓                                  │
│   검토 (Reviewing)                      │
│      ↓                                  │
│   반복...                               │
│                                         │
└─────────────────────────────────────────┘

AI 협업에 적용:

1. 기획 = 청사진/ADR 작성
   - 전체 구조 설계
   - 결정 사항 문서화

2. 작성 = 구현
   - 체크리스트 기반 실행
   - 단위작업 완료

3. 검토 = 검증
   - 정적 분석 (Ruff, MyPy)
   - 테스트 실행
   - 품질 Gate 통과

4. 반복 = 점진적 완성
   - 세션 단위로 진행
   - 누적해서 전체 완성
```

---

## Part 2: DNA 방법론 핵심

### 2.0 DNA 4대 핵심 원칙 (2025-12-03 확정)

DNA 방법론의 성공을 결정하는 4가지 핵심 원칙:

```
┌─────────────────────────────────────────────────────────┐
│              DNA 4대 핵심 원칙                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 🎯 AI 최적 크기                                     │
│     - 80-90K 토큰 = 100-150줄 체크리스트               │
│     - Stage 8이 변환점 (Human-Driven → AI-Driven)      │
│                                                         │
│  2. 🔄 완전해질 때까지 반복                             │
│     - 3단계 검증 (크기, 의존성, 완전성)                 │
│     - "부족함이 없어질 때까지" 재작업                   │
│                                                         │
│  3. 🧩 기능별 분해 + 연결부 + 조립                      │
│     - 레이어별 분해 ❌ → 기능별 분해 ✅                 │
│     - 인터페이스(연결부) 먼저 정의                      │
│     - Task 완료 = 기능 완료 (E2E)                      │
│                                                         │
│  4. ⏪ 역방향 수정 프로토콜                             │
│     - 하위 Stage에서 상위 Stage 오류 발견 시           │
│     - 6단계 프로토콜로 체계적 수정                     │
│     - Stage 7이 가장 Critical (통합의 정점)            │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

#### 원칙 1: AI 최적 크기

```
왜 80-90K 토큰인가?
────────────────────────────────────────────────────────

Claude 컨텍스트 윈도우: 200K 토큰
├─ 시스템 프롬프트: ~30K 토큰
├─ 대화 히스토리: ~20K 토큰
├─ 참조 문서 (Blueprint, Standards): ~50K 토큰
├─ 체크리스트 + 코드: ~20K 토큰
└─ 응답 생성 여유: ~80K 토큰 ← 실제 작업 공간!

Stage 8이 변환점인 이유:
────────────────────────────────────────────────────────
Stage 1-7: Human-Driven (인간 중심)
├─ 문서 크기 제한 없음
├─ 인간의 이해와 의사결정 중심
└─ 컨텍스트 = 인간의 기억력

Stage 8-9: AI-Driven (AI 중심)
├─ AI 컨텍스트 한계 고려 필수!
├─ 80-90K 토큰 내에서 완료 가능해야
└─ 체크리스트 100-150줄 범위
```

#### 원칙 2: 완전해질 때까지 반복

```
3단계 검증 프로토콜:
────────────────────────────────────────────────────────

검증 1: 크기 (Size Check)
├─ 체크리스트 예상 줄 수: 80-180줄?
├─ 예상 시간: 2-4시간?
├─ 생성 파일 수: 1-4개?
└─ 실패 시 → 분할 또는 합치기

검증 2: 의존성 (Dependency Check)
├─ 선행 Task 명확히 정의?
├─ 순환 의존성 없음?
├─ 병렬 실행 가능 Task 식별?
└─ 실패 시 → 의존성 재설계

검증 3: 완전성 (Completeness Check)
├─ 목표: 한 문장으로 명확?
├─ 입력/출력: 모두 명시?
├─ 완료 조건: 측정 가능? (MyPy 0, Ruff 0)
├─ 테스트: 구체적 케이스 3개 이상?
└─ 실패 시 → Task 상세 보완

모든 검증 통과 → Stage 9로 전달 ✅
```

#### 원칙 3: 기능별 분해 + 연결부 + 조립

```
레이어별 분해 vs 기능별 분해:
────────────────────────────────────────────────────────

❌ 레이어별 분해 (Anti-pattern):
Task 001: 모든 엔티티 (Domain Layer)
Task 002: 모든 리포지토리 (Infrastructure)
Task 003: 모든 서비스 (Application)
Task 004: 모든 API (Presentation)

문제: Task 001 완료해도 "작동하는 기능" 없음!

✅ 기능별 분해 (Best Practice):
Task 001: User 기능 (Entity→Repo→Service→API)
Task 002: Order 생성 기능 (E2E)
Task 003: Order 조회 기능 (E2E)

장점: Task 001 완료 = User 기능 작동!

연결부 (Interface) 먼저 정의:
────────────────────────────────────────────────────────
Task 000: 인터페이스 정의
├─ IUserRepository
├─ IOrderRepository
├─ IUserService
└─ IOrderService

이후 Task는 인터페이스 구현 + E2E 작동!
```

#### 원칙 4: 역방향 수정 프로토콜

```
하위 Stage에서 상위 Stage 오류 발견 시:
────────────────────────────────────────────────────────

6단계 프로토콜:

Step 1: 오류 발견 및 문서화
Step 2: 영향 범위 파악 (가장 중요!)
Step 3: 해당 Stage로 이동 → 수정
Step 4: 중간 Stage 전파
Step 5: 현재 Stage 재진행
Step 6: 재진행 결과 검증

Stage 7이 가장 Critical:
────────────────────────────────────────────────────────
├─ Stage 1-6의 모든 결과물이 여기서 통합
├─ 오류 미발견 시 → Stage 8-9 전체 재작업
├─ 오류 수정 시 → Blueprint만 수정 (2-3시간)
└─ 비용 차이: 10배+

추적성:
────────────────────────────────────────────────────────
수정 이력 파일: docs/revision_log.md
각 수정마다 기록: 발견 Stage, 영향 범위, 수정 내용
```

---

### 2.1 핵심 1: "부분으로 전체를 완성"

#### 레고블럭 전략의 이론적 기반

```
Kent Beck의 Augmented Coding (2024):

"AI는 200K 컨텍스트 내에서 완전한 작업을 수행할 때 최고 성과"

DNA 방법론 적용:
├─ Task = 레고블럭 (독립 테스트 가능)
├─ 각 블럭이 완벽하면 전체가 완벽
└─ 블럭 간 인터페이스만 명확하면 됨
```

#### 단위작업 분할의 4가지 질문

**Q1: 컨텍스트 한계를 고려했는가?**

```
💡 핵심 원칙: 숫자는 참고일 뿐! 작업을 완전하게 설명하는 게 우선

에이전트 컨텍스트 기준 (200K, Compact 없음):
├─ 안전 범위: 80-90K 토큰
├─ 체크리스트: 100-150줄 범위 (120줄 내외 권장)
├─ ADR: 세션당 3개 이하
├─ Task: 세션당 1개 (복잡) ~ 3개 (단순)

컨텍스트 계산 근거 (에이전트 기준):
├─ Base (시스템 + 에이전트 정의): ~41K
├─ 읽기 (체크리스트 + 참조문서): ~7.5K
├─ 쓰기 (생각 정리 + 코드 작성): ~22K
├─ 실행/디버그 (테스트 + 수정): ~15K
└─ 총합: ~85.5K (120줄 체크리스트 기준)

⚠️ 중요 - 에이전트 vs 2호:
├─ 2호: Compact 있음 → 긴 작업 가능
├─ 에이전트: Compact 없음 → 200K가 hard limit
└─ Task 크기는 에이전트 기준으로 계산!

컨텍스트 안전 범위:
├─ 80K: 안정적 ✅ (권장)
├─ 90K: 빡빡함 ⚠️ (가능하지만 여유 부족)
├─ 100K+: 위험 ❌ (급히 종료 가능성)
└─ 180K+: 매우 위험 💥 (급히 종료 후 "완료" 보고)
```

**Q2: 의미있는 산출물을 생산하는가?**

```
"의미있는" 기준:
├─ 독립적으로 테스트/검증 가능
├─ 다른 작업 없이도 가치 있음
├─ 명확한 완료 조건 존재
└─ 롤백 가능 (실패해도 다른 부분 영향 없음)

좋은 예:
✅ "User 엔티티 생성 + 테스트" → 독립 검증 가능
✅ "로그인 API 구현 + 테스트" → 독립 실행 가능

나쁜 예:
❌ "User 엔티티 절반 작성" → 검증 불가
❌ "전체 인증 시스템 구현" → 너무 큼
```

**Q3: 일관성을 유지하는가?**

```
일관성 유지 방법:
├─ 동일한 템플릿 사용 (ADR, 체크리스트)
├─ 동일한 코딩 패턴 (Repository, Service)
├─ 동일한 네이밍 컨벤션
├─ 동일한 품질 기준 (Ruff 0, MyPy 0)
└─ 동일한 검증 절차

구현:
- PROJECT_STANDARDS.md → 매 세션 주입
- pre-commit hooks → 자동 강제
- 템플릿 파일 → 복사해서 사용
```

**Q4: 누락이 없는가?**

```
누락 방지 방법:
├─ 전체 목록 먼저 작성 (Blueprint)
├─ 체크리스트로 관리
├─ 완료/미완료 상태 추적
└─ 다음 세션 가이드 제공

추적 방법:
- task_status.json (상태 관리)
- 각 문서의 "다음 작업" 섹션
- Blueprint의 완료 체크박스
```

---

### 2.2 핵심 2: "환경으로 제어"

#### 왜 문서화된 규칙이 실패하는가

```
실패 패턴:

1. 규칙 문서 제공 (20개 DO/DON'T)
      ↓
2. AI: "네, 이해했습니다"
      ↓
3. 구현 시작
      ↓
4. 규칙 50% 이상 위반
      ↓
5. 수정 요청
      ↓
6. 일부 수정, 새로운 위반 발생
      ↓
7. 무한 반복... 또는 포기

원인:
├─ AI는 규칙을 "참조"하지 "강제"하지 않음
├─ 긍정 표현 → "좋은 조언" 정도로 인식
├─ 부정 표현 → 부담감 → 회피
└─ 많은 규칙 → 우선순위 혼란
```

#### 환경 구축의 원리

```
"조심해라" (X) → "못하게 막는다" (O)

┌─────────────────────────────────────────────────────┐
│ 규칙: "print() 사용 금지"                            │
├─────────────────────────────────────────────────────┤
│ ❌ 문서: "print() 대신 logger를 사용하세요"          │
│    → AI가 읽고도 print() 사용                       │
│                                                     │
│ ✅ 환경:                                            │
│    1. src/core/logging/ 제공 (structlog)           │
│    2. pre-commit hook: print() 감지 → 커밋 차단    │
│    3. Ruff 규칙: T201 (print 금지)                 │
│    → 물리적으로 print()가 들어간 코드 커밋 불가     │
└─────────────────────────────────────────────────────┘
```

#### DNA 시스템 = 환경 구축의 구체화

```
DNA 11개 시스템 = 프로젝트 전체에 적용되는 "환경"

각 시스템의 역할:
├─ 표준 도구 제공 (바퀴 재발명 방지)
├─ 사용 패턴 강제 (일관성 확보)
├─ 자동 검증 (품질 보장)
└─ 위반 시 차단 (강제력)

예시 - Logging 시스템:
┌─────────────────────────────────────────┐
│ src/core/logging/                       │
│ ├─ logger.py (structlog 래퍼)          │
│ ├─ config.py (로그 레벨, 포맷)         │
│ └─ handlers.py (파일, 콘솔, JSON)      │
├─────────────────────────────────────────┤
│ 사용 강제:                              │
│ - import logger from core.logging      │
│ - logger.info(), logger.error()        │
│ - print() → Ruff 오류                  │
├─────────────────────────────────────────┤
│ 자동 제공:                              │
│ - trace_id (분산 추적)                 │
│ - 구조화된 JSON 로그                   │
│ - 로그 레벨별 필터링                   │
└─────────────────────────────────────────┘
```

---

### 2.3 추적성 메커니즘: Stage 간 연결

#### 왜 추적성이 필요한가

```
문제:
├─ Stage 3에서 결정한 사항이 Stage 7에서 무시됨
├─ Stage 6 표준이 Stage 9 체크리스트에 반영 안 됨
├─ 하위 Stage에서 문제 발견 → 상위 Stage 수정 필요
└─ 어디서 뭘 바꿔야 하는지 추적 불가

해결: 명시적 참조 체계
```

#### Stage 간 참조 형식

```
참조 형식: [문서ID] Ln [라인번호] 또는 Section [섹션명]

예시 흐름:

Stage 6 (PROJECT_STANDARDS.md):
┌─────────────────────────────────────────┐
│ ## 6.3 Database Standards (Ln 45-60)   │
│                                         │
│ - 모든 테이블 PK는 UUIDv7 사용          │
│ - created_at, updated_at 필수          │
│ - soft delete 사용 (deleted_at)        │
└─────────────────────────────────────────┘
         ↓ 참조
Stage 7 (07B-01_blueprint.md):
┌─────────────────────────────────────────┐
│ ## User Entity                          │
│ Ref: PROJECT_STANDARDS.md Ln 45-60     │
│                                         │
│ - id: UUIDv7 (PK)                      │
│ - created_at: datetime                 │
│ - updated_at: datetime                 │
│ - deleted_at: datetime (nullable)      │
└─────────────────────────────────────────┘
         ↓ 참조
Stage 9 (09L-001_user_entity.md):
┌─────────────────────────────────────────┐
│ ## Step 2: 테스트 작성                  │
│ Ref: 07B-01 Section "User Entity"      │
│                                         │
│ 검증 항목:                              │
│ - [ ] id가 UUIDv7 형식인가?            │
│ - [ ] created_at 자동 설정되는가?      │
│ - [ ] soft delete 동작하는가?          │
└─────────────────────────────────────────┘
```

#### 핫픽스 루프 (양방향 피드백)

```
정방향 (Top-Down):
Stage 3 → Stage 6 → Stage 7 → Stage 9 → 구현

역방향 (Bottom-Up) - 문제 발견 시:

구현 중 문제 발견
      ↓
"UUIDv7이 PostgreSQL 14에서 네이티브 지원 안 됨"
      ↓
Stage 9 체크리스트에 메모
      ↓
Stage 7 Blueprint 수정 요청
      ↓
Stage 6 Standards 재검토
      ↓
Stage 3 ADR 수정 (ADR-007: UUID 전략 변경)
      ↓
변경 사항 하향 전파
      ↓
Stage 5-6 업데이트 → Stage 7 업데이트 → Stage 9 업데이트

핫픽스 문서화:
┌─────────────────────────────────────────┐
│ ## Hotfix Log                           │
│                                         │
│ HF-001 (2024-01-15):                   │
│ - 원인: PostgreSQL 14 UUIDv7 미지원    │
│ - 영향: ADR-007, STANDARDS Ln 45-60    │
│ - 해결: UUID v4 + 별도 timestamp 컬럼  │
│ - 적용: Stage 6, 7, 9 문서 수정 완료   │
└─────────────────────────────────────────┘
```

---

