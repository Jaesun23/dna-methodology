# DNA Methodology 상세 문서(Part3 ~ Part4)

> **목적**: DNA_PROJECT_OVERVIEW_v2.md의 각 Part를 상세하게 풀어쓴 실행 가이드
> **용도**: 실제 작업 시 참조, Stage별 가이드 작성의 기준
> **작성일**: 2025-12-02

## 목차

Part 1: AI 협업의 문제와 해결

​	1.1 Context Rot (문맥 부패) - 핵심 문제

​	1.2 AI의 6가지 문제점

Part 2: DNA 방법론 핵심 

​	2.0 DNA 4대 핵심 원칙

​	2.1 핵심 1: "부분으로 전체를 완성"

​	2.2 핵심 2: "환경으로 제어"

​	2.3 추적성 메커니즘: Stage 간 연결

### Part 3: Stage 1-2 분류와 조사

#### 	3.1 Stage 1: 패밀리 분류

#### 	3.2 Stage 2: 환경 제약 조사

### Part 4: Stage 3 결정 문서화 - ADR 

#### 	4.1 ADR의 역할과 위치

#### 	4.2 5대 ADR 카테고리

Part 5: Stage 4-6 Bridge - 환경 구축

​	5.1 Bridge의 의미

​	5.2 Stage 4: DNA 시스템 청사진

​	5.3 Stage 5: DNA 시스템 구현

​	5.4 Stage 6: Project Standards

Part 6: Stage 7-9 Blueprint → 구현

​	6.1 Stage 7: Project Blueprint

​	6.2 Stage 8: Task Breakdown

​	6.3 Stage 9: Checklist + 구현

Part 7: AI 협업 기법

​	7.1 인지 글쓰기 이론 기반

​	7.2 Skeleton-of-Thought (SoT) - 구조 우선

​	7.3 Chain of Density (CoD) - 정보 밀도 증가

​	7.4 Tree of Thoughts (ToT) - 대안 탐색

​	7.5 RDoLT - 난이도별 분해

​	7.6 Stage별 기법 적용 요약

---

## Part 3: Stage 1-2 분류와 조사 (상세)

### 3.1 Stage 1: 패밀리 분류

#### 목표

시스템의 본질적 특성을 파악하여 7가지 패밀리 중 하나로 분류

#### 10가지 ADQ (Architecture-Driving Questions) 상세

**Part 0: 핵심 기능 파악 (ADQ 전 필수)**

```
Q0: "이 시스템은 무엇을 하기 위한 시스템인가?"
────────────────────────────────────────────────────────
목적: 시스템의 존재 이유, 원자적 핵심 기능 정의

핵심 원칙: "구현 방식"이 아닌 "본질적 기능"으로 정의

❌ 잘못된 예:
├─ 수동 거래 (기능 1)
├─ 자동 거래 (기능 2)
└─ 조건 감시 (기능 3)
→ 이건 "구현 방식"의 나열

✅ 올바른 예:
├─ 핵심 기능: 거래 (Trade)
│   ├─ 구현 방식 A: 수동 (사용자 직접)
│   ├─ 구현 방식 B: 자동 (시스템 자동)
│   └─ 구현 방식 C: 조건부 (조건 충족 시)
└─ 비즈니스 목적: 사용자가 원하는 조건에 주식을 매매

질문 체크리스트:
├─ "이 시스템이 없으면 사용자는 무엇을 못하나?"
├─ "한 문장으로 시스템을 설명한다면?"
└─ "가장 중요한 단 하나의 기능은?"

예시:
- 이커머스: "상품 거래" (검색, 장바구니, 결제는 구현 방식)
- 채팅 앱: "메시지 전달" (그룹채팅, 파일공유는 구현 방식)
- 예약 시스템: "일정 예약" (알림, 결제는 구현 방식)
```

**카테고리 A: 비즈니스 가치**

```
Q1: "이 시스템이 1시간 동안 멈추면 어떤 일이 일어나나요?"
────────────────────────────────────────────────────────
목적: 실패의 치명도 판단 (Layer 1 - 실패 영향)

답변 유형:
├─ 치명적 (A): "거래 손실", "인명 피해", "법적 책임"
├─ 심각 (B): "매출 감소", "고객 불만", "경쟁사 이탈"
└─ 경미 (C): "불편함", "지연", "대체 수단 존재"

예시:
- 주식 거래 플랫폼: "1시간 정지 = 수억 원 손실" → A
- 블로그 서비스: "1시간 정지 = 불편하지만 치명적이진 않음" → C
- 병원 예약 시스템: "1시간 정지 = 환자 대기, 심각한 불편" → B

Q2: "고객이 이 시스템에서 가장 중요하게 생각하는 것은?"
────────────────────────────────────────────────────────
목적: 핵심 품질 속성 식별 (Layer 2 - NFR 우선순위)

답변 유형:
├─ 속도: "빨라야 함", "즉시 응답"
├─ 정확성: "틀리면 안 됨", "100% 정확해야"
├─ 가용성: "항상 접속 가능해야", "24/7"
├─ 보안: "절대 유출되면 안 됨"
└─ 비용: "저렴해야 함", "운영비 최소화"

예시:
- 검색 엔진: "속도" (0.1초 내 결과)
- 은행 이체: "정확성" (1원도 틀리면 안 됨)
- 채팅 앱: "가용성" (항상 메시지 전송 가능)
```

**카테고리 B: 사용자/규모**

```
Q3: "사용자가 이 시스템에서 가장 자주 하는 행동 3가지는?"
────────────────────────────────────────────────────────
목적: 핵심 사용자 여정 파악

답변 형식:
1. [행동 1] - 빈도: 일 N회, 소요시간: N초
2. [행동 2] - 빈도: 일 N회, 소요시간: N초
3. [행동 3] - 빈도: 일 N회, 소요시간: N초

예시 (이커머스):
1. 상품 검색 - 일 100회, 1초 이내
2. 상품 상세 보기 - 일 50회, 3초 이내
3. 주문하기 - 일 5회, 30초 이내

Q4: "동시에 이 시스템을 사용하는 사용자는 얼마나 되나요?"
────────────────────────────────────────────────────────
목적: 확장성 요구사항 파악 (Layer 3 - 환경 제약)

답변 유형:
├─ 소규모: 10-100명 동시 접속
├─ 중규모: 100-10,000명 동시 접속
├─ 대규모: 10,000-100,000명 동시 접속
└─ 초대규모: 100,000명+ 동시 접속

추가 질문:
- 피크 시간대는? (출퇴근, 점심, 이벤트)
- 성장 예상치는? (월 N% 증가)
- 지역 분포는? (국내, 글로벌)
```

**카테고리 C: 데이터/의존성**

```
Q5: "이 시스템에서 다루는 데이터 중 가장 민감한 것은?"
────────────────────────────────────────────────────────
목적: 보안 수준 결정

답변 유형:
├─ 극비: 금융 정보, 의료 기록, 생체 정보
├─ 민감: 개인정보, 위치 정보, 연락처
├─ 내부: 비즈니스 데이터, 운영 정보
└─ 공개: 공개 콘텐츠, 통계 정보

규제 연결:
- 금융: 전자금융거래법, PCI-DSS
- 의료: HIPAA, 개인정보보호법
- 일반: GDPR, 개인정보보호법

Q6: "데이터는 어디서 오나요? (원천)"
────────────────────────────────────────────────────────
목적: 통합 복잡도 파악

답변 유형:
├─ 자체 생성: 사용자 입력, 시스템 생성
├─ 외부 API: 증권사 API, 결제 API, 지도 API
├─ 데이터 피드: 실시간 시세, 뉴스 피드
├─ 배치 수집: 일별 정산, 주기적 크롤링
└─ 사용자 업로드: 파일, 이미지, 문서

Q7: "데이터는 얼마나 오래 보관해야 하나요?"
────────────────────────────────────────────────────────
목적: 저장소 설계, 아카이빙 전략

답변 유형:
├─ 실시간: 현재 상태만 (캐시, 세션)
├─ 단기: 7일-30일 (로그, 임시 데이터)
├─ 중기: 1년-5년 (거래 내역, 활동 기록)
├─ 장기: 5년+ (법적 보관, 감사 추적)
└─ 영구: 삭제 불가 (블록체인, 아카이브)
```

**카테고리 D: 운영/환경**

```
Q8: "이 시스템이 연동해야 하는 외부 시스템은?"
────────────────────────────────────────────────────────
목적: 의존성 파악, 장애 전파 범위

답변 형식:
| 시스템 | 연동 방식 | 의존도 | 대체 가능 |
|--------|----------|--------|----------|
| KIS API | REST | 필수 | X |
| Slack | Webhook | 선택 | O (이메일) |

Q9: "시스템은 어디에 배포되나요?"
────────────────────────────────────────────────────────
목적: 인프라 제약 파악

답변 유형:
├─ 클라우드: AWS, GCP, Azure
├─ 온프레미스: 자체 서버, IDC
├─ 하이브리드: 클라우드 + 온프레미스
├─ 엣지: IoT, CDN, 로컬
└─ 제약: 특정 리전, 규제 요건

Q10: "시스템은 얼마나 자주 변경되나요?"
────────────────────────────────────────────────────────
목적: 유지보수 전략, 배포 파이프라인

답변 유형:
├─ 초고빈도: 일 수회 배포 (CI/CD 필수)
├─ 고빈도: 주 1-2회 배포
├─ 중빈도: 월 1-2회 배포
├─ 저빈도: 분기 1회 배포
└─ 극저빈도: 연 1-2회 (안정성 중시)
```

---

#### 7가지 패밀리와 ADQ 매핑

```
10가지 ADQ 답변 → 3-Layer Decision Tree → 패밀리 코드

Layer 1 (Q1 기반): 실패 영향
├─ A: 치명적 (금전/인명/법적)
├─ B: 심각 (비즈니스 영향)
└─ C: 경미 (불편함 수준)

Layer 2 (Q2, Q5, Q6 기반): 데이터 형태
├─ A: 구조화 (정형 데이터, 스키마 고정)
├─ B: 반구조화 (JSON, 유연한 스키마)
└─ C: 비구조화 (스트림, 로그, 자연어)

Layer 3 (Q3, Q4, Q10 기반): 응답 시점
├─ A: 밀리초 (실시간, <100ms)
├─ B: 초 단위 (대화형, <5s)
└─ C: 배치 (분~시간)
```

**7가지 주요 패밀리**:

| 코드      | 패밀리          | 특성                       | 대표 사례                |
| --------- | --------------- | -------------------------- | ------------------------ |
| **A-A-B** | CRUD/트랜잭션   | 치명적, 구조화, 초         | 주문, 결제, ERP          |
| **B-B-B** | 검색/추천       | 점진적, 반구조화, 초       | Elasticsearch, 추천 엔진 |
| **B-C-A** | 실시간 스트리밍 | 점진적, 비구조화, 밀리초   | Netflix, Uber GPS        |
| **B-A-C** | 분석/배치       | 점진적, 구조화, 배치       | Snowflake, BI            |
| **B-A-A** | 협업/동기화     | 점진적, 구조화, 밀리초     | Google Docs, Figma       |
| **A-A-A** | 초고빈도 거래   | 치명적, 구조화, 마이크로초 | HFT, NASDAQ              |
| **A-B-A** | 안전-임계 IoT   | 치명적, 반구조화, 밀리초   | SCADA, 의료기기          |

#### NFR 프로파일 도출

```
Q2 답변 기반 NFR 우선순위 결정:

예시: 주식 거래 플랫폼

Q2 답변: "빠르고 정확해야 하며, 항상 접속 가능해야 함"
         → 속도, 정확성, 가용성 모두 중요

NFR 프로파일:
┌─────────────────────────────────────────┐
│ 정확성: A (100% 정확, 1원도 틀리면 안됨) │
│ 속도: A (100ms 이내 응답)               │
│ 가용성: A (99.9% uptime)                │
│ 보안: A (금융 데이터)                   │
│ 비용: B (성능이 우선, 비용은 그 다음)    │
└─────────────────────────────────────────┘

프로파일 코드: A-A-A-A-B

충돌 식별:
├─ 정확성 A + 속도 A = 캐싱 전략 신중해야
├─ 가용성 A + 정확성 A = 분산 트랜잭션 필요
└─ → Stage 2에서 충돌 해결 전략 수립
```

#### Stage 1 산출물

```
01C-01_family_classification.md
────────────────────────────────
# 패밀리 분류 결과

## 프로젝트: [프로젝트명]

## 10가지 ADQ 답변
[Q1-Q10 답변 기록]

## 3-Layer 결정
- Layer 1 (실패 영향): A (치명적)
- Layer 2 (데이터 형태): A (구조화)
- Layer 3 (응답 시점): B (초 단위)

## 패밀리 코드: A-A-B (CRUD/트랜잭션)

## NFR 프로파일: A-A-A-A-B
- 정확성: A
- 속도: A
- 가용성: A
- 보안: A
- 비용: B

## 잠재적 충돌
1. 정확성 + 속도: 캐싱 vs 실시간 검증
2. 가용성 + 정확성: 분산 vs 단일 소스

## 다음 단계
→ Stage 2에서 Layer 3 외부 제약 조사
→ 충돌 해결 전략 수립
```

---

### 3.2 Stage 2: 환경 제약 조사

#### 목표

Layer 3 외부 제약 파악, 충돌 패턴 식별, 기술 스택 결정

#### 외부 제약 조사 체크리스트

```
1. API/연동 제약 (Q8 심화)
────────────────────────────────
[ ] 사용할 외부 API 목록
[ ] 각 API의 호출 제한 (rate limit)
[ ] 인증 방식 (OAuth, API Key, 인증서)
[ ] 응답 시간 SLA
[ ] 장애 시 대응 방안

예시 (KIS API):
├─ 호출 제한: 초당 20회
├─ 인증: OAuth 2.0 + 앱키
├─ 시장 시간: 09:00-15:30 (정규)
└─ 장애 대응: 재시도 3회 + 알림

2. 규제/법적 제약
────────────────────────────────
[ ] 적용되는 법규 목록
[ ] 데이터 보관 요건
[ ] 감사 로그 요건
[ ] 암호화 요건
[ ] 지역 제한 (데이터 거주지)

예시 (금융):
├─ 전자금융거래법
├─ 거래 기록 5년 보관
├─ 이상거래 탐지 의무
└─ 국내 서버 필수

3. 인프라 제약 (Q9 심화)
────────────────────────────────
[ ] 클라우드 제공자 제한
[ ] 가용 리전
[ ] 네트워크 대역폭
[ ] 스토리지 용량/비용
[ ] 기존 인프라 연동

4. 시간 제약
────────────────────────────────
[ ] 서비스 운영 시간
[ ] 배치 처리 시간 윈도우
[ ] 유지보수 시간
[ ] 마감 시간 (정산, 리포트)
```

#### 충돌 패턴 식별

```
Stage 1의 NFR 프로파일에서 충돌 식별:

공통 충돌 패턴:

1. 정확성 vs 속도 (CAP Theorem의 C vs A)
────────────────────────────────
상황: 강한 일관성 vs 낮은 지연시간
해결 전략:
├─ 쓰기: 동기식 (정확성)
├─ 읽기: 캐시 + 비동기 (속도)
└─ 중요 작업만 동기, 나머지 비동기

2. 가용성 vs 정확성 (CAP Theorem의 A vs C)
────────────────────────────────
상황: 항상 응답 vs 항상 정확
해결 전략:
├─ 네트워크 정상: 둘 다 만족
├─ 네트워크 장애: 정확성 우선 (금융)
└─ Saga 패턴, Outbox 패턴 검토

3. 성능 vs 비용
────────────────────────────────
상황: 최고 성능 vs 운영비 절감
해결 전략:
├─ 피크 시간: 오토스케일링
├─ 비피크: 최소 인스턴스
└─ 비용 상한선 설정

4. 보안 vs 사용성
────────────────────────────────
상황: 강한 보안 vs 편리한 사용
해결 전략:
├─ 조회: 간단한 인증
├─ 거래: MFA 필수
└─ 위험 기반 인증 (Risk-based Auth)
```

#### 기술 스택 결정 프로세스

```
1. 패밀리 기반 후보군 도출
────────────────────────────────
패밀리: A-A-B (CRUD/트랜잭션)

후보 DB:
├─ PostgreSQL: ACID, JSON 지원, 성숙
├─ MySQL: ACID, 대중적, Aurora 옵션
└─ Oracle: 엔터프라이즈, 비용 높음

후보 프레임워크:
├─ FastAPI: 비동기, 타입 안전, 현대적
├─ Django: 풀스택, ORM 내장, 성숙
└─ Spring Boot: 엔터프라이즈, Java

2. 제약조건 필터링
────────────────────────────────
팀 역량: Python 중심 → FastAPI
비용 제한: 오픈소스 우선 → PostgreSQL
성능 요건: 비동기 필수 → FastAPI + asyncpg

3. 결정 및 근거 문서화
────────────────────────────────
→ Stage 3에서 ADR로 문서화
```

#### Stage 2 산출물

```
02C-01_external_constraints.md
────────────────────────────────
# 외부 제약 조건

## API 제약
[KIS API, 결제 API 등 상세]

## 규제 제약
[법규, 보관 요건 등]

## 인프라 제약
[클라우드, 리전 등]

## 시간 제약
[운영 시간, 배치 윈도우 등]

---

02C-02_conflict_patterns.md
────────────────────────────────
# 충돌 패턴 분석

## 식별된 충돌
1. 정확성 vs 속도
2. 가용성 vs 정확성

## 해결 전략
[각 충돌별 전략]

---

02D-01_tech_stack.md
────────────────────────────────
# 기술 스택 결정

## 결정 사항
- 언어: Python 3.11+
- 프레임워크: FastAPI
- DB: PostgreSQL 15
- 캐시: Redis
- 메시징: Kafka

## 선택 근거
[각 기술별 근거]

## 제외된 대안
[검토했으나 제외된 기술과 이유]
```

---

## Part 4: Stage 3 결정 문서화 - ADR (상세)

### 4.1 ADR의 역할과 위치

#### ADR이란?

```
ADR = Architecture Decision Record
     아키텍처 결정 기록

목적:
├─ 왜 이 결정을 했는지 기록
├─ 어떤 대안이 있었는지 기록
├─ 나중에 "왜 이렇게 했지?" 질문에 답변
└─ 결정 변경 시 영향 범위 파악

핵심:
"코드는 '무엇'을 보여주지만, ADR은 '왜'를 설명한다"
```

#### ADR vs Design Doc

```
┌─────────────────────────────────────────────────────────┐
│                    Design Doc                           │
│  (상세 분석 문서)                                        │
├─────────────────────────────────────────────────────────┤
│  - 문제 정의                                            │
│  - 여러 대안 상세 분석                                  │
│  - 장단점 비교표                                        │
│  - 프로토타입 결과                                      │
│  - 성능 벤치마크                                        │
│  - 10-50 페이지                                         │
│                                                         │
│  → 복잡한 결정에 사용                                   │
│  → "어머니" 문서                                        │
└─────────────────────────────────────────────────────────┘
                    ↓ 요약
┌─────────────────────────────────────────────────────────┐
│                      ADR                                │
│  (결정 기록)                                            │
├─────────────────────────────────────────────────────────┤
│  - 결정 사항 (1줄)                                      │
│  - 맥락 (왜 필요했나)                                   │
│  - 선택한 대안과 이유                                   │
│  - 결과 (무엇이 바뀌나)                                 │
│  - 1-2 페이지                                           │
│                                                         │
│  → 모든 결정에 사용                                     │
│  → Design Doc의 "결론" 요약                             │
└─────────────────────────────────────────────────────────┘

판단 기준:
├─ 간단한 결정: ADR만 작성
│   예: "로깅은 structlog 사용"
│
├─ 복잡한 결정: Design Doc → ADR
│   예: "DB 선택 (PostgreSQL vs MySQL vs MongoDB)"
│
└─ 매우 복잡: RFC/KEP → Design Doc → ADR
    예: "마이크로서비스 vs 모놀리식"
```

---

### 4.2 5대 ADR 카테고리

#### 카테고리 1: 외부 제약 ADR

```
정의: 변경할 수 없는 외부 요인에 의한 결정

특징:
├─ 우리가 선택할 수 없음
├─ 반드시 따라야 함
├─ 위반 시 시스템 작동 불가 또는 법적 문제
└─ "왜?"보다 "무엇?"이 중요

예시:
├─ 법규: "금융 거래 기록 5년 보관 (전자금융거래법)"
├─ API 제한: "KIS API 초당 20회 호출 제한"
├─ 시장 시간: "KRX 정규장 09:00-15:30"
└─ 지역 제한: "개인정보 국내 서버 저장 필수"

템플릿:
┌─────────────────────────────────────────────────────────┐
│ ADR-001: KIS API 호출 제한 준수                         │
├─────────────────────────────────────────────────────────┤
│ 상태: 승인됨                                            │
│ 일자: 2024-01-15                                        │
│ 카테고리: 외부 제약                                     │
├─────────────────────────────────────────────────────────┤
│ 맥락:                                                   │
│ KIS API는 초당 20회 호출 제한이 있음.                   │
│ 이를 초과하면 일시적 차단됨.                            │
├─────────────────────────────────────────────────────────┤
│ 결정:                                                   │
│ Rate Limiter를 구현하여 초당 15회로 제한.               │
│ 여유분 5회는 재시도용.                                  │
├─────────────────────────────────────────────────────────┤
│ 결과:                                                   │
│ - 모든 KIS API 호출은 RateLimiter를 거쳐야 함          │
│ - 벌크 요청 시 큐잉 필요                               │
└─────────────────────────────────────────────────────────┘
```

#### 카테고리 2: 충돌 해결 ADR

```
정의: 상충하는 요구사항 간 Trade-off 결정

특징:
├─ 둘 다 중요하지만 둘 다 만족 불가
├─ 하나를 선택하면 다른 하나 희생
├─ "왜 이걸 선택했나?"가 핵심
└─ 나중에 재검토 가능성 있음

예시:
├─ 정확성 vs 속도: "주문 정확성 > 응답 속도"
├─ 일관성 vs 가용성: "CP 선택 (장애 시 거부)"
├─ 보안 vs 편의성: "거래는 MFA, 조회는 단순 인증"
└─ 비용 vs 성능: "피크 시 성능, 비피크 시 비용"

템플릿:
┌─────────────────────────────────────────────────────────┐
│ ADR-002: 정확성 우선 전략                               │
├─────────────────────────────────────────────────────────┤
│ 상태: 승인됨                                            │
│ 일자: 2024-01-15                                        │
│ 카테고리: 충돌 해결                                     │
├─────────────────────────────────────────────────────────┤
│ 맥락:                                                   │
│ 주문 처리에서 정확성(금액 정확)과 속도(빠른 응답)가     │
│ 충돌함. 캐시 사용 시 속도↑ but 정확성 위험.            │
├─────────────────────────────────────────────────────────┤
│ 검토한 대안:                                            │
│ 1. 캐시 사용 + 비동기 검증: 속도↑, 정확성 위험         │
│ 2. 항상 실시간 조회: 정확성↑, 속도↓ (200ms→500ms)     │
│ 3. 하이브리드: 조회는 캐시, 주문은 실시간              │
├─────────────────────────────────────────────────────────┤
│ 결정:                                                   │
│ 대안 3 선택. 주문 관련 데이터는 항상 실시간 조회.      │
│ 시세 조회는 1초 캐시 허용.                              │
├─────────────────────────────────────────────────────────┤
│ 결과:                                                   │
│ - 주문 API: 캐시 사용 금지                              │
│ - 시세 API: Redis 캐시 1초 TTL                          │
│ - 모니터링: 캐시 히트율 + 주문 정확도 추적             │
├─────────────────────────────────────────────────────────┤
│ 재검토 조건:                                            │
│ - 응답 시간이 1초 초과 시                               │
│ - 정확도 문제 발생 시                                   │
└─────────────────────────────────────────────────────────┘
```

#### 카테고리 3: 기술 스택 ADR

```
정의: 여러 기술 대안 중 하나를 선택하는 결정

특징:
├─ 비교 가능한 대안 존재
├─ 정량적 비교 가능 (성능, 비용, 생태계)
├─ Context7 검증 필수
└─ 팀 역량, 생태계 고려

예시:
├─ DB: "PostgreSQL vs MySQL vs MongoDB"
├─ 프레임워크: "FastAPI vs Django vs Flask"
├─ 메시지 큐: "Kafka vs RabbitMQ vs Redis Pub/Sub"
└─ 캐시: "Redis vs Memcached"

템플릿:
┌─────────────────────────────────────────────────────────┐
│ ADR-003: PostgreSQL 선택                                │
├─────────────────────────────────────────────────────────┤
│ 상태: 승인됨                                            │
│ 일자: 2024-01-15                                        │
│ 카테고리: 기술 스택                                     │
├─────────────────────────────────────────────────────────┤
│ 맥락:                                                   │
│ CRUD/트랜잭션 패밀리로, ACID 준수 DB 필요.              │
├─────────────────────────────────────────────────────────┤
│ 검토한 대안:                                            │
│                                                         │
│ | 기준 | PostgreSQL | MySQL | MongoDB |                 │
│ |------|------------|-------|---------|                 │
│ | ACID | ✅ 완전    | ✅    | ⚠️ 제한 |                │
│ | JSON | ✅ JSONB   | ⚠️    | ✅ 네이티브 |            │
│ | 성능 | 복잡쿼리↑  | 단순↑ | 읽기↑   |                │
│ | 비용 | 무료       | 무료  | Atlas$$ |                 │
│ | 팀경험| ✅ 있음   | ✅    | ⚠️ 적음 |                │
├─────────────────────────────────────────────────────────┤
│ 결정:                                                   │
│ PostgreSQL 15 선택.                                     │
│ - ACID 완전 지원                                        │
│ - JSONB로 유연한 스키마 가능                            │
│ - 팀 경험 있음                                          │
├─────────────────────────────────────────────────────────┤
│ 결과:                                                   │
│ - ORM: SQLAlchemy 2.0 (async 지원)                      │
│ - 마이그레이션: Alembic                                 │
│ - 연결: asyncpg (비동기)                                │
└─────────────────────────────────────────────────────────┘
```

#### 카테고리 4: 도메인 기술 ADR

```
정의: 프로젝트 특화 로직/알고리즘 설계 결정

특징:
├─ 외부 라이브러리로 해결 안 됨
├─ 자체 설계/구현 필요
├─ 비즈니스 로직 깊숙이 관련
└─ 성능/정확도가 핵심

예시:
├─ 주문 매칭 알고리즘
├─ 추천 점수 계산 로직
├─ 가격 책정 엔진
└─ 동시성 제어 전략

템플릿:
┌─────────────────────────────────────────────────────────┐
│ ADR-101: 주문 실행 전략                                 │
├─────────────────────────────────────────────────────────┤
│ 상태: 승인됨                                            │
│ 일자: 2024-01-15                                        │
│ 카테고리: 도메인 기술                                   │
├─────────────────────────────────────────────────────────┤
│ 맥락:                                                   │
│ 사용자 주문을 KIS API로 전송하는 전략 필요.             │
│ 부분 체결, 실패, 재시도 처리 필요.                      │
├─────────────────────────────────────────────────────────┤
│ 설계:                                                   │
│ 1. 주문 상태 머신:                                      │
│    CREATED → SUBMITTED → PARTIAL → FILLED/FAILED       │
│                                                         │
│ 2. 재시도 전략:                                         │
│    - 네트워크 오류: 최대 3회, 지수 백오프              │
│    - 비즈니스 오류: 재시도 없음, 사용자 알림           │
│                                                         │
│ 3. 부분 체결:                                           │
│    - 원주문 유지 + 체결 이력 별도 저장                 │
│    - 잔량 추적                                         │
├─────────────────────────────────────────────────────────┤
│ 결과:                                                   │
│ - OrderStateMachine 구현 필요                           │
│ - OrderExecution 서비스 구현 필요                       │
│ - 상태 변경 이벤트 발행 (Kafka)                        │
└─────────────────────────────────────────────────────────┘
```

#### 카테고리 5: DNA 시스템 ADR

```
정의: 프로젝트 공통 인프라/표준 결정

특징:
├─ 전체 프로젝트에 영향
├─ Stage 4-6 (Bridge)에서 구현
├─ 일관성이 핵심
└─ 변경 시 영향 범위 큼

예시:
├─ 로깅 표준: "structlog + JSON 포맷"
├─ 에러 처리: "예외 계층 + 에러 코드"
├─ 설정 관리: "Pydantic Settings + 환경 변수"
└─ 테스트 전략: "pytest + 95% 커버리지"

템플릿:
┌─────────────────────────────────────────────────────────┐
│ ADR-010: 로깅 표준화                                    │
├─────────────────────────────────────────────────────────┤
│ 상태: 승인됨                                            │
│ 일자: 2024-01-15                                        │
│ 카테고리: DNA 시스템                                    │
├─────────────────────────────────────────────────────────┤
│ 맥락:                                                   │
│ 일관된 로깅으로 디버깅/모니터링 효율화 필요.            │
│ 분산 추적(trace_id) 필수.                               │
├─────────────────────────────────────────────────────────┤
│ 결정:                                                   │
│ - 라이브러리: structlog                                 │
│ - 포맷: JSON (프로덕션), Console (개발)                │
│ - 레벨: DEBUG, INFO, WARNING, ERROR, CRITICAL          │
│ - 컨텍스트: trace_id, user_id, request_id              │
├─────────────────────────────────────────────────────────┤
│ 결과:                                                   │
│ - src/core/logging/ 모듈 구현                          │
│ - print() 사용 금지 (Ruff T201)                        │
│ - 모든 로그는 logger.info() 등 사용                    │
├─────────────────────────────────────────────────────────┤
│ 강제:                                                   │
│ - pre-commit: print() 감지 차단                        │
│ - Ruff: T201 규칙 활성화                               │
└─────────────────────────────────────────────────────────┘
```

---

