# DNA Methodology Project - 프로젝트 개요

> **핵심**: 백지상태의 1호/2호가 이 문서만 읽으면 DNA 프로젝트의 전체를 이해하고, 현재 위치를 파악할 수 있습니다.

---

## 📌 프로젝트의 진짜 목표

이 프로젝트는 **"아이디어에서 완성된 소프트웨어까지"** AI와 함께 만드는 **완전한 방법론**을 확립하는 것입니다.

### 현재 상태

| Stage | 역할 정립 | 프레임워크화 | 상태 |
|:-----:|:--------:|:-----------:|:----:|
| 1-6 | ✅ 완료 | ❌ 미착수 | 프레임워크화 필요 |
| 7-9 | ✅ 완료 | ❌ 미착수 | 프레임워크화 필요 |

```
✅ Gemini 연구(8개 문서)를 통해 Stage 1-6의 역할이 명확해짐
⚠️ 전체 9-Stage를 2호 기능(Skills, Commands, Agents)과 조합한 프레임워크화가 남음
```

### 최종 목표

**전체 9-Stage를 2호 기능(Skills, Commands, Agents)과 조합한 하나의 프레임워크로 완성**

---

## Part 1: AI 협업의 문제와 해결

### 🚨 Jason의 경험: 여러 프로젝트 실패

> "여러가지 프로젝트를 1, 2호와 함께 하면서 성공한 프로젝트가 몇 가지 없음"

**가장 기본적인 문제**:
- Jason의 소프트웨어 개발 경험/지식 부족 → 전체 컨트롤 불가
- AI의 여러 한계와 행동패턴

### AI의 핵심 문제: Context Rot (문맥 부패)

```
정의: 대화가 길어질수록 초기 원칙의 영향력이 약화되는 현상

증상:
├─ 최신성 편향: 최근 내용에 과도하게 집중
├─ Lost in the Middle: 중간 내용을 놓침
├─ 환각 가속화: 컨텍스트 혼란 → 없는 사실 생성
└─ 원칙 망각: 처음 합의한 규칙을 점점 무시

해결책:
├─ 정적 컨텍스트: 불변 규칙 (DNA 시스템, 아키텍처 원칙)
├─ 동적 컨텍스트: 변화하는 상태 (현재 작업, 진행 상황)
└─ 분리 관리: 정적은 고정, 동적만 갱신
```

### AI의 6가지 문제점

| 문제 | 설명 | 해결 |
|------|------|------|
| **Context 한계** | 용량 초과 시 앞 내용 망각 | 단위작업 분할 |
| **회피** | 많은 정보 → 모른 척, 적당히 | 최소 정보 제공 |
| **자기 과신** | "다 할 수 있다" → 실패 | 명확한 범위 제한 |
| **과한 작업** | 불필요한 호환성, 마이그레이션 | 목표만 명확히 |
| **할루시네이션** | 없는 사실 언급, 임의 추정 | 사실확인 강제 |
| **압박감** | 한 번에 다 하려고 함 | 단계별 진행 |

### ✨ AI가 최고 성과를 낼 때

```
✅ 1. 규모가 크지 않아 전체를 한 번에 계획해서 진행 가능
✅ 2. 여러 선택지에서 논리적 흐름/근거에 따른 판단 가능
✅ 3. 요청내용과 결과에 대한 명확한 지침 존재
✅ 4. 매번 새로운 대화지만 기존 작업을 어떤 방식으로든 이해
```

### 💡 해결책 (DNA 방법론의 근본)

```
1. 컨텍스트의 한계를 항상 염두에 두라
2. 전체 흐름을 여러 단계로 나눈 계획을 미리 세운다
3. 하나의 작업 또는 하나의 단계는 하나의 세션에서 완료되도록 한다
4. 명확한 지침과 스스로 도달할 선택지를 사전에 제공한다
```

---

## Part 2: DNA 방법론의 2가지 핵심

### 핵심 1: "부분으로 전체를 완성" 🧩

> **"하나의 세션에서 컨텍스트 제한을 고려해서 필요한 정보를 제공하고, 가장 좋은 성과를 낼 수 있는 양의 작업을 정확하게 지시한다."**

#### 단위작업 분할의 4가지 질문

| 질문 | 의미 | 예시 |
|:----:|:----:|:----:|
| **Q1** | 컨텍스트 한계 고려 | 80-90K 토큰 범위, 체크리스트 100-150줄 |
| **Q2** | 의미있는 산출물 생산 | 독립 테스트/검증 가능 |
| **Q3** | 일관성 유지 | 같은 템플릿, 같은 패턴 |
| **Q4** | 누락 없음 | 전체 커버 확인 |

### 핵심 2: "환경으로 제어" 🛡️

> **"다른 것들은 시스템적으로 제약하고 관리한다."**

```
문제: 문서로 규칙 제공 → AI가 안 읽거나 회피
해결: "환경"을 구축해서 제약

예시:
┌─────────────────────────────────────┐
│ 규칙: "print() 사용 금지"            │
│ DNA: src/core/logging/ (structlog)  │
│ 강제: pre-commit hook → 커밋 차단    │
└─────────────────────────────────────┘

핵심: "조심해라" (X) → "못하게 막는다" (O)
```

### 추적성 메커니즘: Stage 간 연결

```
Stage 간 명시적 참조 체계:

Stage 6 (표준) → Stage 7 (블루프린트) → Stage 9 (체크리스트)
"모든 PK는 UUIDv7"  → "User.id = UUIDv7"   → "id 필드 검증"
(Ln 45-50)          (Ref: 06D-01 Ln 45)    (Ref: 07B-01)

핫픽스 루프 (양방향 피드백):
하위 문제 발견 → 상위 ADR 수정 → Stage 5-6 업데이트 → 이후 반영
```

---

## Part 3: Stage의 진짜 의미 ⚠️ **중요!**

### ❌ 흔한 착각
```
Stage 1 = 한 번의 세션에서 완료하는 작업 (X)
```

### ✅ 실제 의미
```
Stage = 여러 세션에 걸친 점진적 누적 (O)
```

> **"Stage는 한 개의 작업이 아니에요."** - Jason

### 예시: Stage 3 (ADR 작성)
```
├─ 전체: 18개 ADR 작성 필요
├─ 한번에? NO! (컨텍스트 초과)
├─ 분할: 세션당 3개씩
│   ├─ Session 1: ADR 001-003
│   ├─ Session 2: ADR 004-006
│   └─ ...
└─ 누적: 6 세션 → 18개 ADR 완성
```

---

## Part 4: 9-Stage 구조

### 전체 흐름: 2개의 Phase

```
┌─────────────────────────────────────────────────────────────┐
│  Phase A: 아이디어 → Blueprint (Stage 1-6)                   │
│  ═══════════════════════════════════════════                │
│  "무엇을 만들 것인가" 결정 + "환경" 구축                      │
│                                                              │
│  Stage 1-2: 분류와 조사                                      │
│  Stage 3: 결정 문서화 (ADR)                                  │
│  Stage 4-6: Bridge (환경 구축) ← 핵심 발견!                  │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│  Phase B: Blueprint → 구현 (Stage 7-9)                       │
│  ═══════════════════════════════════════════                │
│  "어떻게 만들 것인가" 상세화 + 실행                          │
│                                                              │
│  Stage 7: 도메인 청사진                                      │
│  Stage 8: 작업 분해                                          │
│  Stage 9: 체크리스트 + 구현                                  │
└─────────────────────────────────────────────────────────────┘
```

### Stage 1-2: 분류와 조사

#### Stage 1: 패밀리 분류

**목표**: 시스템의 본질적 특성 파악 → 7가지 패밀리 중 하나로 분류

**10가지 ADQ (Architecture-Driving Questions)**:

| 카테고리 | 질문 | 목적 |
|---------|------|------|
| **A. 비즈니스** | Q1: 실패 시 손실은? | 치명도 판단 |
| | Q2: 핵심 품질 속성은? | NFR 우선순위 |
| **B. 사용자** | Q3: 핵심 사용자 여정은? | 주요 흐름 |
| | Q4: 사용자 규모는? | 확장성 요구 |
| **C. 데이터** | Q5: 데이터 민감도는? | 보안 수준 |
| | Q6: 데이터 원천은? | 통합 복잡도 |
| | Q7: 보관 기간은? | 저장소 설계 |
| **D. 환경** | Q8: 연동 시스템은? | 의존성 파악 |
| | Q9: 배포 환경은? | 인프라 제약 |
| | Q10: 변경 주기는? | 유지보수 전략 |

**산출물**:
- 01C-01_family_classification.md (패밀리 코드, NFR 프로파일)

#### Stage 2: 환경 제약 조사

**목표**: Layer 3 제약조건 파악, 충돌 패턴 식별, 기술 스택 결정

**산출물**:
- 02C-01_external_constraints.md (외부 API, 규제, 시간 제약)
- 02C-02_conflict_patterns.md (트레이드오프 분석)
- 02D-01_tech_stack.md (기술 선택 근거)

---

### Stage 3: 결정 문서화 (ADR)

**목표**: 모든 아키텍처 결정을 ADR로 문서화

**5대 ADR 카테고리**:

| 카테고리 | 설명 | 예시 |
|---------|------|------|
| **1. 외부 제약** | 변경 불가능한 제약 | 법규, API 제한, 시장 시간 |
| **2. 충돌 해결** | Trade-off 결정 | 속도 vs 정확성, 일관성 vs 가용성 |
| **3. 기술 스택** | 비교 후 선택 | PostgreSQL vs MySQL |
| **4. 도메인 기술** | 자체 설계 | 도메인 특화 알고리즘 |
| **5. DNA 시스템** | 공통 표준 | 로깅, 에러 처리, 설정 관리 |

**ADR과 Design Doc의 관계**:
```
복잡한 결정: Design Doc (상세 분석) → ADR (최종 요약)
간단한 결정: ADR 자체가 제안서 역할
```

**산출물**:
- 03A-001~099.md (Bootstrap ADR: DNA 시스템 관련)
- 03A-100+.md (Domain ADR: 도메인 특화)

---

### Stage 4-6: Bridge (환경 구축) ⭐ 핵심 발견

> **"Stage 4-6은 Gap이 아니라 Bridge다"** - Gemini 연구 결과

**역할**: ADR(결정)을 실행 가능한 환경으로 변환

**4대 구성요소**:

| 구성요소 | Stage | 역할 | 비유 |
|---------|-------|------|------|
| **성문화된 결정** | Stage 3 | 왜/무엇 | 법률 |
| **재사용 가능한 컴포넌트** | Stage 5 | 도구 | 공구 |
| **의무적 규칙** | Stage 6 | 규칙 | 교통법규 |
| **자동화된 거버넌스** | Stage 6 | 경찰 | 단속 카메라 |

**핵심 인사이트**:
```
DNA 시스템 = "환경/플랫폼" (Stage 4-6에서 구축)
도메인 = "애플리케이션" (Stage 7-9에서 구현)

DNA가 먼저 구축되어야 도메인이 일관되게 구현됨
```

#### Stage 4: DNA 시스템 청사진
```
목표: DNA 시스템 11개의 설계
산출물: 04B-01_dna_blueprint.md
```

#### Stage 5: DNA 시스템 구현
```
목표: src/core/ 공통 모듈 구현
산출물: src/core/logging/, config/, types/, ...
```

#### Stage 6: Project Standards
```
목표: 강제 규칙 + 자동화 설정
산출물:
- PROJECT_STANDARDS.md (DO/DON'T)
- pyproject.toml (Ruff, MyPy)
- .pre-commit-config.yaml

자동화 성숙도:
- Day 1: pre-commit (정적 분석)
- Week 2: ArchUnit/import-linter (아키텍처)
- Month 1+: Fitness Functions
```

---

### Stage 7-9: Blueprint → 구현 ✅ 검증됨

#### Stage 7: Project Blueprint
```
목표: 도메인 ADR 기반 상세 청사진
산출물: 07B-01_project_blueprint.md (여러 파트 가능)
특징: Stage 6 표준을 명시적으로 참조
```

#### Stage 8: Task Breakdown
```
목표: AI가 한 세션에 완료할 크기로 분할
산출물: 08T-01_task_breakdown.md
기준: 80-90K 토큰 범위, 독립 테스트 가능 (줄 수는 참고)
```

#### Stage 9: Checklist + 구현
```
목표: TDD 기반 9-Step 체크리스트 작성 및 실행
산출물: 09L-001_task1_checklist.md, ...

9-Step:
1. 목표이해  2. 테스트작성  3. 구현
4. 정적검증  5. 단위테스트  6. 리팩토링
7. 종합테스트 8. 문서화     9. 커밋

품질 기준: Ruff 0, MyPy 0, Coverage 95%+
```

---

## Part 5: AI 협업 기법 (4가지 핵심 기법)

### 인지 글쓰기 이론 기반

```
기획(Planning) → 작성(Translating) → 검토(Reviewing) → 반복

AI 협업에서도 동일:
아이디어 정제 → 구조화 → 확장 → 검증 → 반복
```

### 1. Skeleton-of-Thought (SoT) - 구조 우선

```
원리: 뼈대 먼저 → 각 부분 병렬 확장

적용:
├─ 청사진 목차 생성 (뼈대)
├─ 각 섹션 병렬 작성 (확장)
└─ 전체 일관성 검토

효과: 논리적 표류 방지, 구조적 완성도
```

### 2. Chain of Density (CoD) - 정보 밀도 증가

```
원리: 고정 길이 내에서 정보 밀도 점진적 증가

과정:
├─ 초기 요약 작성
├─ 핵심 엔티티 식별
├─ 불필요한 단어 제거 + 새 사실 추가
└─ 4-5회 반복

적용: 모호한 요구사항 → 구체적 기술 명세 변환
```

### 3. Tree of Thoughts (ToT) - 대안 탐색

```
원리: 여러 사고 경로 생성 → 자기 평가 → 최적 선택

과정:
├─ 문제 분해
├─ 각 단계 다수 후보 생성
├─ 평가 기준으로 점수화
└─ 최적 경로 선택 (또는 역추적)

적용: 아키텍처 대안 비교 (모놀리식 vs MSA vs 하이브리드)
```

### 4. RDoLT - 난이도별 분해

```
원리: 난이도별 3단계 분해

단계:
├─ Easy: 기본 기능 (CRUD, 단순 로직)
├─ Intermediate: 상호작용 (통합, 흐름)
└─ Final: 예외/성능/보안 (엣지 케이스)

적용: 아이디어 정제, 요구사항 도출
```

### Stage별 기법 적용

| Stage | 주요 기법 | 목적 |
|-------|----------|------|
| **1-2** | CoD + RDoLT | 아이디어 정제, 요구사항 구체화 |
| **3** | ToT | ADR 대안 비교, 결정 근거 |
| **7** | SoT | 청사진 구조화 |
| **8-9** | SoT + RDoLT | 작업 분해, 체크리스트 |

---

## Part 6: 작업 예시 (축약)

### 주식 거래 플랫폼 예시

```
아이디어: "한국 주식 거래 플랫폼"

Stage 1-2 (6 세션):
├─ 패밀리 분류: A-C-A (치명적, 비구조화, 밀리초)
├─ 10가지 ADQ 적용 → NFR 프로파일
└─ 외부 제약: KIS API, 금융규제, KRX 시장시간

Stage 3 (10 세션):
├─ Bootstrap ADR 9개 (DNA 시스템)
└─ Domain ADR 9개 (도메인 특화)

Stage 4-6 (14 세션):
├─ DNA 청사진 + 구현 (11개 시스템)
└─ PROJECT_STANDARDS + 자동화

Stage 7-9 (20 세션):
├─ 도메인 Blueprint (5 파트)
├─ Task Breakdown (20개 작업)
└─ Checklist 작성 (20개)

구현 (20 세션):
└─ 체크리스트 실행 → 완성!

총 70 세션, 각 세션의 특징:
✅ 명확한 입력/출력
✅ 일관성 유지 (제약조건 항상 제공)
✅ 컨텍스트 효율 (필요한 정보만)
✅ 검증 가능 (산출물 확인)
```

---

## Part 7: 세 가지 컴포넌트의 역할

### Skills / Commands / Agents

| 컴포넌트 | 역할 | 비유 | 특징 |
|----------|------|------|------|
| **Skills** | 지식 저장소 | 전문 서적 | Progressive Disclosure |
| **Commands** | 실행 트리거 | 버튼 | 간단한 진입점 |
| **Agents** | 작업 수행자 | 전문가 | Phase 구조 |

### Skills 구성 (계획)

```
1. 핵심 개념: 7개 패밀리, NFR, Context Rot 방지
2. 템플릿: ADR (5 Categories), 체크리스트 (9-Step)
3. 패턴: 아키텍처, 기술 선택 가이드
4. 참조: 기존 가이드 링크
```

### 상호작용 흐름

```
사용자: /stage3 "Bootstrap ADR 001-003"
    ↓
Command: 인자 파싱 → Agent 선택
    ↓
Agent:
  Phase 0: 이전 작업 읽기 (02C-*.md)
  Phase 1: Skills 참조 (ADR 템플릿)
  Phase 2-4: ADR 3개 작성
  Phase 5: 검증
    ↓
산출물: 03A-001.md, 002.md, 003.md
```

---

## 요약: 1호/2호가 기억해야 할 것

### 🎯 프로젝트 목표
```
전체 9-Stage를 프레임워크화하여
아이디어 → 완성된 소프트웨어까지 완전한 방법론 확립
```

### 🔑 핵심 원칙
```
1. 부분으로 전체 완성 (레고블럭) - 4가지 질문
2. 환경으로 제어 (DNA 시스템) - 못하게 막는다
3. Stage ≠ 한 작업, Stage = 여러 세션 누적
4. 추적성 메커니즘 - Stage 간 명시적 참조
```

### 📊 현재 상태
```
| 구분 | Stage 1-6 | Stage 7-9 |
|------|-----------|-----------|
| 역할 정립 | ✅ 완료 | ✅ 완료 |
| 프레임워크화 | ❌ 미착수 | ❌ 미착수 |

다음 작업: Skills/Commands/Agents 조합으로 프레임워크화
```

### 🧠 AI 협업 기법
```
SoT: 구조 우선 (청사진)
CoD: 정보 밀도 증가 (요구사항 정제)
ToT: 대안 탐색 (ADR 비교)
RDoLT: 난이도별 분해 (작업 분해)
```

### 📁 핵심 참조 문서
```
- GEMINI_RESEARCH_SYNTHESIS.md: 8개 연구 통합
- DNA Methodology v3.6 (프로젝트 문서): 이론적 검증
- DNA Methodology v3.6 완전성 검증: 18가지 조합 분석
- UNIFIED_AI_COLLABORATION_METHODOLOGY_v4.0.md: 통합 방법론
```

---

**이 문서를 다 읽었다면, DNA 프로젝트의 전체 맥락과 현재 위치를 파악한 것입니다!** 🎉
