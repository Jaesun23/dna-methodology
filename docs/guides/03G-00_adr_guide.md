# Stage 3: ADR 작성 가이드 (Architecture Decision Records Guide)

> **목적**: Stage 2에서 결정된 기술 스택과 충돌 해결을 공식 ADR로 문서화
>
> **버전**: v4.1 (2025-12-03)
>
> - v5.0 (2025-12-03): Gemini 연구 기반 전면 재작성, DNA_METHODOLOGY_DETAILED.md 기준
> - v3.0 (2025-11-13): Stage 3 분리

---

## 📚 이 가이드의 위치

```
DNA 방법론 문서 체계:

Tier 1: DNA_PROJECT_OVERVIEW_v2.md (전체 맥락)
           ↓
Tier 2: DNA_METHODOLOGY_DETAILED.md (상세 원리) - Part 4
           ↓
Tier 3: 이 문서 (Stage 3 실행 가이드) ← 지금 여기!
```

**참조 문서**:
- **원리 이해**: `DNA_METHODOLOGY_DETAILED.md` Part 4
- **실전 사례**: `IMPLEMENTATION_CASES.md`

---

## 🧬 DNA 방법론 4대 핵심 원칙 (Stage 3 적용)

> **"AI가 한 세션에서 최고 성과를 낼 수 있는 크기로 작업하고, 완전해질 때까지 반복하며, 오류 발견 시 되돌아가서 수정한다"**

Stage 3 (ADR 작성)에서 DNA 4대 핵심 원칙이 적용되는 방식:

---

### DNA 핵심 원칙 1: AI 최적 크기

**"컨텍스트 범위 내에서 작업한다"**

#### Stage 3의 작업 크기 전략

```
❌ 잘못된 접근: 모든 ADR 한 번에
"20개 ADR을 한 세션에서 모두 작성하세요"
→ 컨텍스트 초과 (200K 토큰 한계)
→ 후반부 ADR 품질 저하
→ 일관성 없는 형식

✅ 올바른 접근: 카테고리별 순차 작성
Session 1: 외부 제약 ADR (03A-001 ~ 03A-00N)
Session 2: 충돌 해결 ADR (03A-101 ~ 03A-1NN)
Session 3: 기술 스택 ADR (03A-201 ~ 03A-2NN)
Session 4: 도메인 기술 ADR (03A-301 ~ 03A-3NN)
Session 5: DNA 시스템 ADR (03A-401 ~ 03A-4NN)

각 세션: 3-5개 ADR, 80-90K 토큰 범위
```

#### 컨텍스트 구성 (각 세션)

```
Claude 200K 토큰 윈도우:
├─ 시스템 프롬프트: ~30K 토큰
├─ 대화 히스토리: ~20K 토큰
├─ Stage 2 참조 문서: ~30-40K 토큰
│   ├─ 02C-01_external_constraints.md
│   ├─ 02C-02_conflict_patterns.md
│   └─ 02D-01_tech_stack.md
├─ ADR 템플릿: ~10K 토큰
├─ 작업 중 ADR 작성: ~20K 토큰 (3-5개 × 4-6K)
└─ 응답 생성 여유: ~80K 토큰
```

#### 세션당 작업량 기준

| 카테고리 | 평균 ADR 수 | 세션 수 | 세션당 ADR 수 |
|---------|------------|--------|--------------|
| 외부 제약 | 3-5개 | 1 session | 3-5개 |
| 충돌 해결 | 5-10개 | 2 sessions | 3-5개 |
| 기술 스택 | 10-15개 | 3 sessions | 3-5개 |
| 도메인 기술 | 5-10개 | 2 sessions | 3-5개 |
| DNA 시스템 | 11개 | 3 sessions | 3-4개 |

**핵심**: 한 세션에 3-5개 ADR이 최적 (각 4-6K 토큰)

---

### DNA 핵심 원칙 2: 완전해질 때까지 반복

**"부족하면 반복해서 부족함이 없어질 때까지"**

#### ADR 완전성 기준

각 ADR은 다음 5가지 섹션을 모두 포함해야 함:

```
✅ 완전한 ADR 체크리스트:
□ 1. Status & Context (상태 및 맥락)
   - 상태: Proposed/Accepted/Deprecated/Superseded
   - 날짜: 작성일, 승인일, 폐기일
   - 맥락: 왜 이 결정이 필요한가?

□ 2. Decision (결정 사항)
   - 무엇을 선택했는가?
   - 구체적 기술/방법 명시

□ 3. Rationale (근거)
   - 왜 이것을 선택했는가?
   - 어떤 대안이 있었는가?
   - 각 대안의 장단점은?

□ 4. Consequences (결과)
   - 긍정적 결과 (이점)
   - 부정적 결과 (트레이드오프)
   - 영향받는 시스템/모듈

□ 5. Compliance (준수 사항)
   - 검증 방법 (어떻게 확인?)
   - 위반 시 조치 (어떻게 강제?)
   - 재검토 조건 (언제 다시 평가?)
```

#### 3단계 검증 프로토콜

```python
def validate_adr_session(adrs: list[ADR]) -> ValidationResult:
    """ADR 세션 완전성 검증."""

    # 검증 1: 각 ADR 구조 검증
    for adr in adrs:
        if not all([
            adr.has_status_and_context(),
            adr.has_decision(),
            adr.has_rationale(),
            adr.has_consequences(),
            adr.has_compliance()
        ]):
            return ValidationResult(
                passed=False,
                message=f"ADR {adr.id}: 5개 섹션 중 누락 발견",
                action="해당 ADR 재작성"
            )

    # 검증 2: 카테고리 일관성 검증
    category = adrs[0].category
    if not all(adr.category == category for adr in adrs):
        return ValidationResult(
            passed=False,
            message="한 세션에 여러 카테고리 혼재",
            action="카테고리별로 세션 분리"
        )

    # 검증 3: Stage 2 추적성 검증
    for adr in adrs:
        if not adr.has_stage2_reference():
            return ValidationResult(
                passed=False,
                message=f"ADR {adr.id}: Stage 2 참조 누락",
                action="Stage 2 문서 참조 추가"
            )

    return ValidationResult(passed=True)
```

#### 불완전 → 재작성 사례

```markdown
## 사례: ADR-201 데이터베이스 선택

### ❌ 불완전한 버전 (1차 작성)
**결정**: PostgreSQL 사용
**이유**: 관계형 데이터베이스가 필요해서

❌ 문제점:
- 대안 검토 없음 (MySQL, MongoDB는?)
- 구체적 근거 없음 ("필요해서"는 설명 아님)
- 결과/영향 명시 없음
- 준수 사항 없음

### ✅ 완전한 버전 (2차 재작성)
**맥락**: 주문 데이터는 ACID 보장 필요, 복잡한 조인 쿼리 빈번

**결정**: PostgreSQL 13+ 사용

**근거**:
- 검토한 대안:
  1. PostgreSQL: ACID 완벽, JSON 지원, 성능 우수
  2. MySQL: ACID 지원하나 JSON 기능 제한적
  3. MongoDB: 유연하나 트랜잭션 복잡
- 선택 이유: 주문 데이터의 ACID 필수, JSON 컬럼 필요

**결과**:
- 긍정: 데이터 일관성 보장, 복잡한 쿼리 가능
- 부정: NoSQL 대비 스키마 변경 부담
- 영향: DNA Database 시스템, Order 도메인

**준수**:
- 검증: SQLAlchemy ORM으로만 접근
- 위반 시: pre-commit hook으로 raw SQL 차단
- 재검토: 쓰기 속도 < 100 TPS 시
```

---

### DNA 핵심 원칙 3: 기능별 분해 + 연결부 + 조립

**"모듈이 크면 기능별로 나누고, 연결부 설계 후 조립"**

#### Stage 3에서의 적용

Stage 3는 "문서 작성" 단계이므로 원칙 3은 직접 적용되지 않습니다.

다만, ADR 자체가 "연결부" 역할을 합니다:

```
Stage 2 (결정) ←─┐
                  ├─ ADR (연결부) ─→ Stage 4 (DNA 계획)
Stage 8 (작업)  ←─┘                     ↓
   ↓                                 Stage 5 (DNA 구현)
Stage 9 (체크리스트)

ADR의 연결 역할:
├─ Stage 2 결정을 공식 기록
├─ Stage 4-5에서 참조
└─ Stage 8-9 작업 시 검증 기준
```

#### ADR 간 연결 관리

```markdown
## ADR 간 의존성 예시

ADR-001: Python 3.11+ 사용
   ↓ supersedes
ADR-005: Python 3.9+ 사용 (폐기됨)

ADR-201: PostgreSQL 사용
   ↓ related to
ADR-401: DNA Database 시스템 (SQLAlchemy 2.0)

ADR-102: 캐시는 조회만 사용
   ↓ enforced by
ADR-402: DNA Cache 시스템 (Redis 구조)
```

---

### DNA 핵심 원칙 4: 역방향 수정 프로토콜

**"앞선 결정의 오류 발견 시 → 되돌아가서 수정 → 다시 현재까지 진행"**

#### Stage 3에서 역방향 수정이 발생하는 경우

```
시나리오 1: Stage 2 결정 오류 발견
├─ Stage 3 ADR 작성 중
├─ Stage 2 충돌 해결이 잘못됨을 발견
├─ → Stage 2로 돌아가 수정
├─ → Stage 3 ADR 재작성
└─ → 추적성 업데이트

시나리오 2: Stage 4-5에서 ADR 오류 발견
├─ Stage 5 DNA 구현 중
├─ ADR-201 (PostgreSQL) 제약 불가능 발견
├─ → Stage 3로 돌아가 ADR-201 수정
├─ → Stage 4 청사진 업데이트
├─ → Stage 5 구현 재진행
└─ → 추적성 업데이트
```

#### 6단계 수정 프로토콜

```markdown
## 실제 사례: ADR-102 캐시 전략 수정

### Step 1: 오류 발견 및 문서화
**발견 시점**: Stage 5 (DNA Cache 시스템 구현 중)
**파일**: `docs/adr/category-2-conflict/03A-102_cache_strategy.md`
**문제**: "조회만 캐시 사용"인데, 통계 데이터도 캐시 필요함을 발견

### Step 2: 영향 범위 파악
**영향받는 문서**:
- Stage 2: `02D-01_tech_stack.md` (Line 234-256)
- Stage 3: `03A-102_cache_strategy.md` (전체)
- Stage 4: `04D-02_dna_cache_blueprint.md` (Line 45-67)

**영향받는 구현**: 없음 (아직 구현 전)

### Step 3: 해당 Stage로 이동 및 수정
```bash
# Stage 2 재검토
$ edit 02D-01_tech_stack.md
  Line 234-256: "조회 + 통계 데이터에 캐시 사용" 으로 수정

# Stage 3 ADR 수정
$ edit 03A-102_cache_strategy.md
  - Status: Accepted → Superseded
  - Superseded by: 03A-102-v2

$ create 03A-102-v2_cache_strategy_updated.md
  - 새로운 결정: 조회 + 통계 → 캐시
  - 주문/결제 → 캐시 없음
```

### Step 4: 중간 Stage 전파
```bash
# Stage 4 청사진 업데이트
$ edit 04D-02_dna_cache_blueprint.md
  Line 45-67: 통계 데이터 캐시 구조 추가
  Ref: 03A-102-v2 (Line 23-45)
```

### Step 5: 현재 Stage 재진행
```bash
# Stage 5 재구현
$ implement src/core/cache/
  - stats_cache.py 추가
  - Ref: 03A-102-v2
```

### Step 6: 재진행 결과 검증
**검증 항목**:
- [ ] Stage 2 충돌 재분석 완료
- [ ] ADR-102-v2 5개 섹션 완전
- [ ] Stage 4 청사진 ADR 참조 업데이트
- [ ] Stage 5 구현 ADR 준수
- [ ] 모든 파일에 추적성 명시
```

#### 추적성 (Traceability) 유지

**모든 수정은 명시적으로 참조**:

```markdown
## Stage 2 문서 (02D-01_tech_stack.md)
Line 234-256: 캐시 전략
> **History**:
> - v1.0 (2024-11-10): "조회만 캐시"
> - v2.0 (2024-11-15): "조회 + 통계 캐시" (Reason: ADR-102-v2)

## Stage 3 ADR (03A-102-v2_cache_strategy_updated.md)
**Supersedes**: ADR-102 (2024-11-10)
**Reason**: 통계 데이터 캐시 필요성 발견
**Impact**: Stage 4 (04D-02, Line 45-67), Stage 5 (src/core/cache/)

## Stage 4 청사진 (04D-02_dna_cache_blueprint.md)
Line 45-67: 통계 데이터 캐시 구조
> **Ref**: ADR-102-v2 (Line 23-45)
> **Updated**: 2024-11-15 (Reason: ADR 수정)

## Stage 5 구현 (src/core/cache/stats_cache.py)
Line 1: # Ref: ADR-102-v2 (docs/adr/category-2-conflict/03A-102-v2)
Line 5: # Updated: 2024-11-15 (통계 데이터 캐시 추가)
```

---

## 🎯 DNA 원칙 적용 요약 (Stage 3)

| 원칙 | Stage 3 적용 방법 | 체크포인트 |
|------|------------------|-----------|
| **1. AI 최적 크기** | 카테고리별 세션 분리 (3-5 ADR/세션) | 세션당 80-90K 토큰 |
| **2. 완전해질 때까지** | 5개 섹션 완전성, 3단계 검증 | 모든 ADR 5 sections |
| **3. 기능별 분해** | (문서 단계라 직접 적용 안 됨) | ADR 자체가 연결부 |
| **4. 역방향 수정** | 6단계 프로토콜, 추적성 유지 | Superseded/History |

---

## 🤔 왜 ADR이 필요한가?

### 문제 상황: "왜 이렇게 했지?"

```
6개월 후...

새로운 팀원: "왜 PostgreSQL인가요? MongoDB가 더 좋을 것 같은데..."
기존 팀원: "음... 그때 뭔가 이유가 있었는데..."

결과:
├─ 같은 논의 반복 (시간 낭비)
├─ 근거 없이 기술 변경 시도
├─ 변경 후 예상치 못한 문제 발생
└─ "그냥 원래대로 하자" (발전 없음)
```

### 실제 사례: 주식 거래 플랫폼

```
상황:
- Stage 2에서 "정확성 > 속도" 결정
- 주문 처리에 캐시 사용 안 함
- 조회에만 캐시 사용

6개월 후:
- 새 개발자: "주문도 캐시 쓰면 빨라질 텐데?"
- ADR 없다면 → 캐시 적용 → 금액 불일치 사고
- ADR 있다면 → ADR-101 확인 → "아, 이래서 안 쓰는구나"

ADR-101 정확성 우선 전략:
├─ 맥락: 주문 금액 정확성 필수
├─ 검토한 대안: 캐시 사용, 실시간 조회, 하이브리드
├─ 결정: 주문은 실시간, 조회만 캐시
├─ 결과: 500ms 느려지지만 정확도 100%
└─ 재검토 조건: 정확도 문제 발생 시
```

### ADR의 핵심 가치

| 가치 | 설명 | 없을 때 문제 |
|------|------|-------------|
| **기억** | 결정 근거 보존 | 왜 이렇게 했는지 모름 |
| **방지** | 같은 실수 반복 방지 | 이미 검토한 대안 재논의 |
| **속도** | 신규 인원 온보딩 | 모든 결정을 다시 설명 |
| **변경** | 영향 범위 파악 | 변경 시 뭐가 깨지는지 모름 |

---

## 📥 입력 문서

### Stage 2에서 전달받는 것

| 파일 | 핵심 내용 | 이 Stage에서 사용 |
|------|----------|-----------------|
| `02C-01_external_constraints.md` | 외부 제약 조사 | ADR 카테고리 1 |
| `02C-02_conflict_patterns.md` | 충돌 패턴 분석 | ADR 카테고리 2 |
| `02D-01_tech_stack.md` | 기술 스택 결정 | ADR 카테고리 3, 5 |

---

## 📤 출력 문서

### 필수 산출물

```
docs/adr/
├── 03A-000_adr_index.md           # ADR 목록 및 상태
├── category-1-external/           # 외부 제약 ADR
│   └── 03A-001_*.md ~ 03A-00N.md
├── category-2-conflict/           # 충돌 해결 ADR
│   └── 03A-101_*.md ~ 03A-1NN.md
├── category-3-tech-stack/         # 기술 스택 ADR
│   └── 03A-201_*.md ~ 03A-2NN.md
├── category-4-domain/             # 도메인 기술 ADR
│   └── 03A-301_*.md ~ 03A-3NN.md
└── category-5-dna-system/         # DNA 시스템 ADR
    └── 03A-401_*.md ~ 03A-4NN.md
```

---

## 🎯 ADR이란?

> **ADR = Architecture Decision Record**
> 
> "코드는 '무엇'을 보여주지만, ADR은 '왜'를 설명한다"

### ADR의 역할

```
왜 필요한가?
├─ 왜 이 결정을 했는지 기록
├─ 어떤 대안이 있었는지 기록
├─ 나중에 "왜 이렇게 했지?" 질문에 답변
└─ 결정 변경 시 영향 범위 파악
```

### ADR vs Design Doc

| 구분 | Design Doc | ADR |
|------|------------|-----|
| **목적** | 상세 분석 | 결정 기록 |
| **분량** | 10-50 페이지 | 1-2 페이지 |
| **내용** | 문제 정의, 대안 분석, 벤치마크 | 맥락, 결정, 결과 |
| **사용 시점** | 복잡한 결정 전 | 모든 결정 후 |
| **관계** | "어머니" 문서 | Design Doc의 "결론" |

**판단 기준**:
```
├─ 간단한 결정: ADR만 작성
│   예: "로깅은 structlog 사용"
│
├─ 복잡한 결정: Design Doc → ADR
│   예: "DB 선택 (PostgreSQL vs MySQL vs MongoDB)"
│
└─ 매우 복잡: RFC/KEP → Design Doc → ADR
    예: "마이크로서비스 vs 모놀리식"
```

---


## 5대 ADR 카테고리

### 카테고리 1: 외부 제약 ADR (001-099)

> **정의**: 변경할 수 없는 외부 요인에 의한 결정

```
특징:
├─ 우리가 선택할 수 없음
├─ 반드시 따라야 함
├─ 위반 시 시스템 작동 불가 또는 법적 문제
└─ "왜?"보다 "무엇?"이 중요
```

**예시**:
| 유형 | 예시 | ADR 제목 |
|------|------|---------|
| 법규 | 거래 기록 5년 보관 | ADR-001: 전자금융거래법 준수 |
| API 제한 | KIS API 초당 20회 | ADR-002: KIS API Rate Limit 대응 |
| 시장 시간 | KRX 정규장 09:00-15:30 | ADR-003: 시장 시간 기반 스케줄링 |
| 지역 제한 | 개인정보 국내 서버 필수 | ADR-004: 데이터 거주지 요건 |

---

### 카테고리 2: 충돌 해결 ADR (101-199)

> **정의**: 상충하는 요구사항 간 Trade-off 결정

```
특징:
├─ 둘 다 중요하지만 둘 다 만족 불가
├─ 하나를 선택하면 다른 하나 희생
├─ "왜 이걸 선택했나?"가 핵심
└─ 나중에 재검토 가능성 있음
```

**예시**:
| 충돌 | 결정 | ADR 제목 |
|------|------|---------|
| 정확성 vs 속도 | 주문=정확성, 조회=속도 | ADR-101: 정확성 우선 전략 |
| 일관성 vs 가용성 | CP 선택 (장애 시 거부) | ADR-102: CAP 선택 - CP |
| 보안 vs 편의성 | 거래=MFA, 조회=단순 | ADR-103: 인증 레벨 차등화 |
| 비용 vs 성능 | 피크=성능, 비피크=비용 | ADR-104: 오토스케일링 전략 |

---

### 카테고리 3: 기술 스택 ADR (201-299)

> **정의**: 여러 기술 대안 중 하나를 선택하는 결정

```
특징:
├─ 비교 가능한 대안 존재
├─ 정량적 비교 가능 (성능, 비용, 생태계)
├─ Context7 검증 필수
└─ 팀 역량, 생태계 고려
```

**예시**:
| 영역 | 선택 | 대안 | ADR 제목 |
|------|------|------|---------|
| DB | PostgreSQL | MySQL, MongoDB | ADR-201: PostgreSQL 선택 |
| 프레임워크 | FastAPI | Django, Flask | ADR-202: FastAPI 선택 |
| 메시지 큐 | Redis Streams | Kafka, RabbitMQ | ADR-203: Redis Streams 선택 |
| 캐시 | Redis | Memcached | ADR-204: Redis 캐시 선택 |

---

### 카테고리 4: 도메인 기술 ADR (301-399)

> **정의**: 프로젝트 특화 로직/알고리즘 설계 결정

```
특징:
├─ 외부 라이브러리로 해결 안 됨
├─ 자체 설계/구현 필요
├─ 비즈니스 로직 깊숙이 관련
└─ 성능/정확도가 핵심
```

**예시**:
| 영역 | 설계 내용 | ADR 제목 |
|------|----------|---------|
| 주문 처리 | 상태 머신, 재시도 전략 | ADR-301: 주문 실행 전략 |
| 데이터 모델 | 주문 스키마, 관계 | ADR-302: 주문 데이터 모델 |
| API 설계 | 엔드포인트, 응답 형식 | ADR-303: REST API 설계 |
| 동시성 | 낙관적 락, 충돌 해결 | ADR-304: 동시성 제어 전략 |

---

### 카테고리 5: DNA 시스템 ADR (401-499)

> **정의**: 프로젝트 공통 인프라/표준 결정

```
특징:
├─ 전체 프로젝트에 영향
├─ Stage 4-6 (Bridge)에서 구현
├─ 일관성이 핵심
└─ 변경 시 영향 범위 큼
```

**예시**:
| 시스템 | 결정 내용 | ADR 제목 |
|--------|----------|---------|
| 로깅 | structlog + JSON | ADR-401: 로깅 표준화 |
| 에러 처리 | 예외 계층 + 에러 코드 | ADR-402: 에러 처리 표준 |
| 설정 관리 | Pydantic Settings | ADR-403: 설정 관리 표준 |
| 테스트 | pytest + 95% 커버리지 | ADR-404: 테스트 전략 |
| 인증 | JWT + RS256 | ADR-405: 인증 표준 |

---


## ADR 작성 우선순위

### 권장 순서

```
Phase 1: 외부 제약 ADR (카테고리 1)
────────────────────────────────────
- 가장 먼저 작성 (변경 불가능)
- Stage 2 02C-01_external_constraints.md 기반
- 다른 ADR의 제약 조건이 됨

Phase 2: 충돌 해결 ADR (카테고리 2)
────────────────────────────────────
- 외부 제약 기반 해결책
- Stage 2 02C-02_conflict_patterns.md 기반
- 기술 스택 선택에 영향

Phase 3: 기술 스택 ADR (카테고리 3)
────────────────────────────────────
- Stage 2 02D-01_tech_stack.md 기반
- 핵심 기술 선택 근거

Phase 4: DNA 시스템 ADR (카테고리 5)
────────────────────────────────────
- 공통 인프라 결정
- Stage 4-6에서 구현할 내용

Phase 5: 도메인 기술 ADR (카테고리 4)
────────────────────────────────────
- 비즈니스 로직 설계
- Stage 7-9에서 구현할 내용
```

---

## 📋 ADR 템플릿

### 표준 ADR 템플릿

```markdown
# ADR-XXX: {Decision Title}

**상태**: Proposed | Accepted | Deprecated | Superseded
**작성일**: YYYY-MM-DD
**카테고리**: 외부제약 | 충돌해결 | 기술스택 | 도메인기술 | DNA시스템

---

## 맥락 (Context)

왜 이 결정이 필요한가?
- 문제 상황
- 제약 조건
- 요구사항

## 검토한 대안 (Alternatives)

### 대안 1: [이름]
- 설명: ...
- 장점: ...
- 단점: ...

### 대안 2: [이름]
- 설명: ...
- 장점: ...
- 단점: ...

### 대안 3: [이름]
- 설명: ...
- 장점: ...
- 단점: ...

## 결정 (Decision)

**선택**: [대안 N]

**핵심 근거**:
1. [이유 1]
2. [이유 2]
3. [이유 3]

## 결과 (Consequences)

### 긍정적 영향
- ✅ [영향 1]
- ✅ [영향 2]

### 트레이드오프
- ⚠️ [트레이드오프 1]
- ⚠️ [트레이드오프 2]

### 부정적 영향
- ❌ [영향 1] (해결 방안: ...)

## 후속 조치 (Follow-up)

- [ ] [조치 1]
- [ ] [조치 2]

## 참조 (References)

- Stage 2 문서: `02C-01_external_constraints.md`
- 관련 ADR: ADR-XXX
- 외부 링크: [URL]
```

---

### 카테고리별 템플릿 변형

#### 외부 제약 ADR (간소화)

```markdown
# ADR-00X: [외부 제약 제목]

**상태**: Accepted
**카테고리**: 외부제약
**작성일**: YYYY-MM-DD

---

## 제약 조건

| 항목 | 내용 |
|------|------|
| 출처 | [법규/API/규제 등] |
| 제약 내용 | [구체적 제약] |
| 위반 시 영향 | [결과] |

## 대응 방안

[제약을 준수하기 위한 구현 방안]

## 결과

- 모든 [관련 기능]은 [제약]을 준수해야 함
- [구현 위치/방법]
```

---

#### 기술 스택 ADR (비교표 포함)

```markdown
# ADR-2XX: [기술 선택 제목]

**상태**: Accepted
**카테고리**: 기술스택
**작성일**: YYYY-MM-DD

---

## 맥락

[왜 이 기술이 필요한가]

## 대안 비교

| 기준 | [기술 A] | [기술 B] | [기술 C] |
|------|---------|---------|---------|
| 성능 | ⭐⭐⭐ | ⭐⭐ | ⭐ |
| 비용 | 무료 | 무료 | $$$ |
| 팀 경험 | ✅ 있음 | ⚠️ 적음 | ❌ 없음 |
| 생태계 | ✅ 풍부 | ⚠️ 보통 | ⚠️ 보통 |
| [기타 기준] | ... | ... | ... |

## 결정

**선택**: [기술 A]

**핵심 근거**:
1. [이유 1]
2. [이유 2]

## 결과

- [구현에 미치는 영향]
- [함께 사용할 라이브러리]
```

---


### ADR Index 템플릿 (03A-000_adr_index.md)

```markdown
# ADR Index

**프로젝트**: [프로젝트명]
**최종 업데이트**: YYYY-MM-DD
**총 ADR 수**: [N]개

---

## 상태별 요약

| 상태 | 개수 |
|------|------|
| Proposed | N |
| Accepted | N |
| Deprecated | N |
| Superseded | N |

---

## 카테고리 1: 외부 제약 (001-099)

| 번호 | 제목 | 상태 | 작성일 |
|------|------|------|--------|
| ADR-001 | [제목] | Accepted | YYYY-MM-DD |
| ADR-002 | [제목] | Accepted | YYYY-MM-DD |

---

## 카테고리 2: 충돌 해결 (101-199)

| 번호 | 제목 | 충돌 유형 | 상태 | 작성일 |
|------|------|----------|------|--------|
| ADR-101 | [제목] | 정확성 vs 속도 | Accepted | YYYY-MM-DD |

---

## 카테고리 3: 기술 스택 (201-299)

| 번호 | 제목 | 영역 | 선택 | 상태 |
|------|------|------|------|------|
| ADR-201 | [제목] | DB | PostgreSQL | Accepted |
| ADR-202 | [제목] | Framework | FastAPI | Accepted |

---

## 카테고리 4: 도메인 기술 (301-399)

| 번호 | 제목 | 도메인 | 상태 |
|------|------|--------|------|
| ADR-301 | [제목] | 주문 | Accepted |

---

## 카테고리 5: DNA 시스템 (401-499)

| 번호 | 제목 | 시스템 | 상태 |
|------|------|--------|------|
| ADR-401 | [제목] | 로깅 | Accepted |
| ADR-402 | [제목] | 에러처리 | Accepted |

---

## 의존성 그래프

```
ADR-001 (외부제약)
    ↓
ADR-101 (충돌해결) ← ADR-002 (외부제약)
    ↓
ADR-201 (기술스택)
    ↓
ADR-401 (DNA시스템)
```
```

---

## 📝 ADR 작성 예시 (주식 거래 플랫폼)

### 예시 1: 외부 제약 ADR

```markdown
# ADR-002: KIS API 호출 제한 대응

**상태**: Accepted
**카테고리**: 외부제약
**작성일**: 2024-01-15

---

## 제약 조건

| 항목 | 내용 |
|------|------|
| 출처 | 한국투자증권 KIS API 문서 |
| 제약 내용 | 초당 20회 호출 제한, 초과 시 일시 차단 |
| 위반 시 영향 | API 차단으로 서비스 중단 |

## 대응 방안

1. Rate Limiter 구현
   - 초당 15회로 제한 (5회 여유분)
   - Token Bucket 알고리즘 사용
   
2. 요청 큐잉
   - 초과 요청은 큐에 대기
   - 최대 대기 시간: 5초

3. 벌크 요청 최적화
   - 여러 종목 조회 → 배치 API 활용

## 결과

- core/external/kis_client.py에 RateLimiter 구현
- 모든 KIS API 호출은 rate_limiter를 거쳐야 함
- 모니터링: 초당 호출 수, 큐 대기 시간
```

---

### 예시 2: 충돌 해결 ADR

```markdown
# ADR-101: 정확성 우선 전략

**상태**: Accepted
**카테고리**: 충돌해결
**작성일**: 2024-01-15

---

## 맥락

주문 처리에서 정확성(금액 정확)과 속도(빠른 응답)가 충돌.
캐시 사용 시 속도↑ but 정확성 위험.

## 검토한 대안

### 대안 1: 캐시 전면 사용
- 장점: 응답 속도 200ms → 50ms
- 단점: 가격 불일치 가능, 금융 사고 위험
- 거부 이유: 금융 거래에서 정확성 타협 불가

### 대안 2: 실시간 조회 전면 사용
- 장점: 100% 정확
- 단점: 모든 요청 500ms, 시세 조회도 느림
- 거부 이유: 시세 조회까지 느릴 필요 없음

### 대안 3: 하이브리드 (선택)
- 주문 관련: 항상 실시간
- 시세 조회: 1초 캐시 허용
- 장점: 정확성 + 사용성 균형

## 결정

**선택**: 대안 3 (하이브리드)

**핵심 근거**:
1. 주문 정확성은 금융 서비스의 핵심 가치
2. 시세 조회는 1초 지연 허용 가능
3. 사용자 경험과 안전성 균형

## 결과

### 긍정적 영향
- ✅ 주문 금액 100% 정확
- ✅ 시세 조회 응답 속도 개선

### 트레이드오프
- ⚠️ 주문 응답 500ms (캐시 사용 시 50ms)

### 부정적 영향
- ❌ 구현 복잡도 증가 (해결: 명확한 분리 설계)

## 재검토 조건

- 주문 응답 시간이 1초 초과 시
- 정확도 관련 이슈 발생 시
```

---

### 예시 3: 기술 스택 ADR

```markdown
# ADR-201: PostgreSQL 선택

**상태**: Accepted
**카테고리**: 기술스택
**작성일**: 2024-01-15

---

## 맥락

CRUD/트랜잭션 패밀리(A-A-B)로, ACID 준수 DB 필요.
주문, 계좌, 포트폴리오 데이터 저장.

## 대안 비교

| 기준 | PostgreSQL | MySQL | MongoDB |
|------|------------|-------|---------|
| ACID | ✅ 완전 지원 | ✅ 지원 | ⚠️ 제한적 |
| JSON 지원 | ✅ JSONB | ⚠️ JSON | ✅ 네이티브 |
| 복잡 쿼리 | ✅ 우수 | ⚠️ 보통 | ❌ 제한적 |
| 비용 | 무료 | 무료 | Atlas$$$ |
| 팀 경험 | ✅ 있음 | ✅ 있음 | ⚠️ 적음 |
| 비동기 | asyncpg | aiomysql | motor |

## 결정

**선택**: PostgreSQL 15

**핵심 근거**:
1. ACID 완전 지원 (금융 거래 필수)
2. JSONB로 유연한 스키마 가능 (설정, 메타데이터)
3. 팀 경험 있음, 생태계 풍부

## 결과

- ORM: SQLAlchemy 2.0 (async 지원)
- 마이그레이션: Alembic
- 연결: asyncpg (비동기)
- 풀링: connection pool size 20
```

---

## ✅ Stage 3 완료 체크리스트

```
□ ADR 구조 설정
  □ docs/adr/ 디렉토리 생성
  □ 카테고리별 하위 디렉토리 생성
  □ 03A-000_adr_index.md 생성

□ 카테고리 1: 외부 제약 ADR
  □ Stage 2 02C-01 기반 작성
  □ 법규, API 제한, 시간 제약 등
  □ 최소 1개 이상

□ 카테고리 2: 충돌 해결 ADR
  □ Stage 2 02C-02 기반 작성
  □ 각 충돌 패턴별 해결 전략
  □ 최소 1개 이상

□ 카테고리 3: 기술 스택 ADR
  □ Stage 2 02D-01 기반 작성
  □ DB, 프레임워크, 캐시 등
  □ 주요 기술별 1개씩

□ 카테고리 4: 도메인 기술 ADR
  □ 핵심 비즈니스 로직 설계
  □ 데이터 모델, API 설계

□ 카테고리 5: DNA 시스템 ADR
  □ 로깅, 에러 처리, 설정 관리
  □ 테스트, 인증 전략

□ ADR Index 업데이트
  □ 모든 ADR 등록
  □ 상태별 요약
  □ 의존성 그래프
```

---

## 🔜 다음 단계

### Stage 3 → Stage 4 전달 사항

| 항목 | 예시 | Stage 4에서 사용 |
|------|------|-----------------|
| DNA 시스템 ADR | ADR-401~499 | DNA 시스템 청사진 |
| 기술 스택 ADR | ADR-201~299 | 개발 환경 설정 |
| 도메인 기술 ADR | ADR-301~399 | 도메인 청사진 |

### Stage 4에서 할 일
- 🔄 DNA 시스템 ADR 기반 청사진 작성
- 🔄 src/core/ 모듈 구조 설계
- 🔄 공통 컴포넌트 인터페이스 정의

**다음 문서**: `04G-00_dna_system_blueprint_guide.md`

---

## ⏪ 이전 Stage 검증 및 수정 프로토콜

### 검증 시점
- Stage 3 시작 전 필수 체크
- 각 ADR 카테고리 작성 완료 후 재검증

### 검증 대상

| Stage | 산출물 | 검증 항목 |
|-------|--------|----------|
| Stage 1 | 01C-01_*.md (패밀리) | ADR이 패밀리 특성과 일치? |
| Stage 1 | 01C-01_*.md (NFR) | ADR이 NFR 우선순위 반영? |
| Stage 2 | 02C-01_*.md (제약) | 기술 제약이 ADR에 반영? |
| Stage 2 | 02C-01_*.md (충돌) | 충돌 해결이 ADR로 문서화? |

### 오류 발견 시 프로토콜

```
Stage 3에서 Stage 1-2 오류 발견 시:

Step 1: 오류 발견 및 문서화
├─ 발견 위치: ADR-[NNN] 작성 중
├─ 오류 내용: [구체적 설명]
├─ 영향 Stage: Stage [1 또는 2]
└─ 기록: 해당 ADR에 "발견된 이슈" 추가

Step 2: 영향 범위 파악
├─ Stage 1 영향: 패밀리/NFR 수정 필요?
├─ Stage 2 영향: 제약/충돌 분석 수정 필요?
├─ 재작업 예상: [X]시간
└─ 기록 완료

Step 3: 해당 Stage로 이동 → 수정
├─ 01C-01 또는 02C-01 수정
├─ 버전 업데이트
└─ 수정 검증

Step 4: Stage 3 재진행
├─ 수정된 입력으로 ADR 재검토
├─ 관련 ADR 업데이트
└─ 일관성 확인

Step 5: 검증
├─ 오류 해결 확인
└─ Stage 4 전달 가능 ✅
```

### 흔한 오류 패턴

| 오류 유형 | 예시 | 해결 |
|----------|------|------|
| NFR 충돌 누락 | 성능 vs 보안 충돌 미식별 | Stage 2 충돌 분석 추가 |
| 제약 미반영 | 예산으로 SaaS 불가인데 ADR에 SaaS 선택 | Stage 2 제약 재검토 |
| 패밀리 불일치 | 실시간 패밀리인데 배치 DB 선택 | Stage 1 재검토 또는 ADR 수정 |

### 추적성

```
수정 이력 파일: docs/revision_log.md

기록 형식:
## [날짜] Stage 3 → Stage [N] 수정
- **발견 ADR**: ADR-[NNN]
- **오류**: [오류 내용]
- **수정 Stage**: Stage [N]
- **수정 내용**: [구체적 수정]
- **영향 ADR**: [재검토 필요한 ADR 목록]
- **검증**: [검증 결과]
```

---

## 📚 참고 문서

| 문서 | 용도 |
|------|------|
| `DNA_METHODOLOGY_DETAILED.md` Part 4 | Stage 3 상세 원리 |
| `IMPLEMENTATION_CASES.md` | ADR 실전 사례 |
| `./standards/00_STAGE_STRUCTURE.md` | Stage 간 연결 구조 |

---

## 💡 핵심 원칙 요약

```
ADR 작성의 3가지 원칙:

1. "왜"를 기록
   - 코드는 "무엇"을 보여줌
   - ADR은 "왜"를 설명
   - 나중에 질문에 답할 수 있어야 함

2. 대안을 기록
   - 선택한 것만 기록 ❌
   - 검토한 대안과 거부 이유도 기록 ✅
   - 재검토 시 불필요한 반복 방지

3. 결과를 예측
   - 긍정적 영향
   - 트레이드오프
   - 부정적 영향과 완화 방안
```

```
카테고리 분류 원칙:

1. 외부 제약: "변경 불가, 따라야 함"
2. 충돌 해결: "둘 다 원하지만 선택해야 함"
3. 기술 스택: "여러 대안 중 하나 선택"
4. 도메인 기술: "직접 설계해야 함"
5. DNA 시스템: "전체에 영향, 일관성 핵심"
```

---

**버전 이력**:
- v5.0 (2025-12-03): Gemini 연구 기반 전면 재작성, DNA_METHODOLOGY_DETAILED.md 기준
- v3.0 (2025-11-13): Stage 3 분리
- v2.0 (2025-11-12): ADR 유형 구분
- v1.0 (2025-11-10): 초기 버전
