

# **DNA 개발 방법론: AI 주도 소프트웨어 아키텍처 설계와 컨텍스트 무결성 보존을 위한 심층 분석 보고서**

## **서론: 생성형 AI 시대의 소프트웨어 공학적 난제와 기회**

소프트웨어 공학의 역사는 추상화 수준을 높이고 복잡성을 제어하려는 끊임없는 시도의 연속이었다. 기계어에서 고수준 언어로, 그리고 모놀리식 아키텍처에서 마이크로서비스로의 진화는 모두 개발자가 다루어야 할 인지적 부하를 줄이는 데 초점을 맞추었다. 현재 우리는 거대언어모델(Large Language Models, LLM)을 활용한 'AI-Native' 개발이라는 새로운 변곡점에 서 있다. 귀하께서 제안하신 'DNA Development Methodology'는 이러한 흐름을 선도하는 체계적인 접근법으로 평가된다. 특히 '아이디어(Idea)'에서 '청사진(Blueprint)'으로 이어지는 전반부 프로세스는 프로젝트의 성패를 결정짓는 '유전 정보'를 정의하는 단계이기에 그 중요성은 아무리 강조해도 지나치지 않다.

그러나 이 단계에서 개발자와 아키텍트가 직면하는 가장 본질적인 문제는 LLM의 **'Context Rot(문맥 부패)'** 현상이다. 이는 단순히 AI가 이전 대화를 망각하는 메모리 용량의 문제를 넘어선다. 확률론적 토큰 생성기인 LLM은 대화가 길어지고 추론의 깊이가 깊어질수록, 초기에 설정된 아키텍처 원칙이나 비즈니스 제약 조건보다 최근의 문맥에 과도하게 집중하는 '최신성 편향(Recency Bias)'을 보인다.1 또한, 복잡한 도메인 논리를 처리하는 과정에서 논리적 비약이나 환각(Hallucination)이 발생하여, 결과적으로 일관성이 결여된 청사진이 도출될 위험이 상존한다. 이는 마치 생명체의 DNA 복제 과정에서 발생한 돌연변이가 전체 유기체의 생존을 위협하는 것과 유사하다.

본 보고서는 'DNA Development Methodology'의 전반부를 완성하기 위해, **심층적인 컨텍스트 엔지니어링(Context Engineering)**, **재귀적 분해(Recursive Decomposition)**, **도메인 주도 설계(DDD)의 AI 통합**, 그리고 **C4 모델 기반의 아키텍처 시각화**를 아우르는 포괄적인 프레임워크를 제안한다. 단순한 프롬프트 엔지니어링을 넘어, AI 에이전트의 인지 구조를 설계하고 기억을 체계적으로 관리함으로써, 아이디어 발상에서부터 실행 가능한 아키텍처 청사진에 이르기까지 정보의 무결성을 유지하는 구체적인 방법론을 논한다. 이를 통해 AI의 행동 패턴을 제어하고, 인간 아키텍트의 의도를 정확하게 반영하는 '살아있는' 설계 문서를 생성하는 것이 본 연구의 최종 목표이다.

## **1\. 컨텍스트 엔지니어링: 아키텍처 DNA 보존을 위한 인지적 기반**

AI 기반 개발에서 '프롬프트 엔지니어링(Prompt Engineering)'이 적절한 질문을 던지는 기술이라면, \*\*'컨텍스트 엔지니어링(Context Engineering)'\*\*은 AI가 사고하고 행동하는 환경 자체를 설계하는 상위 개념이다.2 프로젝트의 규모가 커질수록 단발적인 프롬프트 최적화보다는, AI가 참조하는 정보의 상태(State)를 관리하고 제한된 컨텍스트 윈도우 내에서 정보의 밀도(Density)를 조절하는 전략이 필수적이다.

### **1.1 컨텍스트의 본질과 엔지니어링의 전환**

컨텍스트 엔지니어링은 LLM의 추론 과정에 필요한 정보를 선별, 구조화, 유지하는 일련의 기술적 활동을 의미한다. 앤스로픽(Anthropic)의 연구에 따르면, 효과적인 컨텍스트 엔지니어링은 AI의 신뢰성과 성능을 극대화하는 핵심 요소이며, 이는 단순히 많은 정보를 제공하는 것이 아니라 \*\*'가장 높은 신호(Signal)를 가진 최소한의 토큰 세트'\*\*를 구성하는 데 있다.2

AI 에이전트가 '아이디어'를 '청사진'으로 발전시키는 긴 호흡의 작업에서 일관성을 잃지 않으려면, 컨텍스트를 정적(Static) 요소와 동적(Dynamic) 요소로 구분하여 관리해야 한다. 정적 요소는 프로젝트의 헌법과 같은 불변의 규칙을 담고 있으며, 동적 요소는 프로젝트 진행 상황에 따라 변화하는 상태 정보를 포함한다.

### **1.2 정적 컨텍스트 앵커(Static Context Anchor): AGENTS.md와 시스템 프롬프트**

'Context Rot'을 방지하는 첫 번째 방어선은 AI가 언제나 돌아가야 할 기준점을 명확히 하는 것이다. 이를 위해 프로젝트 루트에 **AGENTS.md** 또는 \*\*.cursorrules\*\*와 같은 표준화된 컨텍스트 파일을 배치하는 것이 산업 표준으로 자리 잡고 있다.3 이 파일들은 AI 코딩 에이전트가 프로젝트에 진입할 때 가장 먼저 로드하여 숙지해야 할 '메타 인지' 정보를 담는다.

AGENTS.md 파일은 인간 개발자를 위한 README.md와는 구별되어야 한다. README.md가 프로젝트의 개요와 설치 방법을 설명한다면, AGENTS.md는 AI에게 구체적인 행동 지침, 코드 스타일, 아키텍처 제약 사항을 기계 가독성이 높은 형태로 제공한다.3

| 섹션 | 포함되어야 할 핵심 내용 | 목적 및 기대 효과 |
| :---- | :---- | :---- |
| **Role Definition** | "당신은 엔터프라이즈급 시스템 아키텍트이며, DDD와 C4 모델의 전문가이다." | AI의 페르소나를 고정하여 답변의 톤과 깊이를 일관되게 유지.5 |
| **Operational Constraints** | "외부 라이브러리 사용 시 반드시 보안 취약점을 검토하라.", "모든 다이어그램은 PlantUML 코드로 작성하라." | AI의 자의적인 판단을 제한하고 프로젝트 표준 준수 강제.4 |
| **Code Style & Pattern** | "TypeScript Strict Mode 사용", "함수형 프로그래밍 패턴 선호", "에러 처리는 Result 타입 사용" | 생성된 코드의 품질을 보장하고 리팩토링 비용 절감.3 |
| **Architectural Decision Records (ADR)** | "데이터베이스는 PostgreSQL을 사용하며, 비동기 통신은 Kafka를 사용한다." | 이미 결정된 아키텍처 사항에 대한 재질문이나 이탈 방지.6 |

이러한 정적 앵커 파일은 XML 태그나 마크다운 헤더를 사용하여 명확하게 구조화되어야 하며, 이는 LLM이 정보를 섹션별로 파싱하고 이해하는 데 도움을 준다.2 예를 들어 \<instructions\>, \<constraints\>, \<examples\>와 같이 태그를 활용하여 정보의 경계를 명확히 하는 것이 좋다.

### **1.3 동적 컨텍스트 관리: 슬라이딩 윈도우와 계층적 메모리**

프로젝트가 진행됨에 따라 대화의 양은 기하급수적으로 늘어난다. LLM의 컨텍스트 윈도우가 128k, 200k 토큰으로 확장되었다 하더라도, 전체 대화 기록을 매번 전송하는 것은 비용 비효율적일 뿐만 아니라, 'Lost-in-the-Middle' 현상으로 인해 정보의 정확도를 떨어뜨린다.1 따라서 동적 컨텍스트 관리를 위한 \*\*슬라이딩 윈도우(Sliding Window)\*\*와 **계층적 메모리(Hierarchical Memory)** 전략이 필요하다.

* **슬라이딩 윈도우 및 요약:** 가장 최근의 N개 메시지(단기 기억)와 AGENTS.md(장기 기억)만을 유지하고, 중간의 대화 내용은 주기적으로 요약하여 압축한다. 이때 단순한 요약이 아닌, 핵심 정보의 밀도를 높이는 **Chain of Density (CoD)** 기법을 적용해야 한다.8 CoD는 반복적인 정제를 통해 불필요한 서술어는 제거하고 핵심 엔티티(Entity)만을 남겨, 정보 손실 없이 컨텍스트를 압축하는 강력한 방법론이다.  
* **계층적 컨텍스트 구조 (Git-Context-Controller):** 최근 연구에서는 에이전트의 메모리를 파일 시스템처럼 관리하는 **GCC(Git-Context-Controller)** 개념이 제안되었다.10 이는 에이전트의 사고 과정을 main.md (고수준 계획), log.md (실행 트레이스), metadata (상태 정보)로 나누어 관리하며, 필요에 따라 가지(Branch)를 쳐서 새로운 아이디어를 탐색하고 다시 병합(Merge)하는 방식이다. 이러한 구조는 '청사진' 단계에서 다양한 설계 대안을 탐색하고 검증하는 데 매우 유용하다.  
* **구조적 노트 필기 (Structured Note-Taking):** AI가 스스로 NOTES.md와 같은 파일을 생성하고, 현재 작업의 진행 상황, 미해결 과제, 발견된 이슈 등을 기록하게 한다.2 이는 인간의 작업 기억(Working Memory)을 보조하는 메모장과 같은 역할을 하며, 세션이 끊기거나 컨텍스트가 초기화되더라도 작업의 연속성을 보장한다.

---

## **2\. 아이디어의 정제: 재귀적 분해와 사고의 골격 형성**

사용자의 초기 아이디어는 대부분 추상적이고 모호하다. 이를 곧바로 아키텍처 설계에 투입하면, AI는 불완전한 정보를 메우기 위해 환각을 일으키거나 피상적인 결과물을 내놓게 된다. 따라서 아이디어를 논리적으로 완결된 요구사항으로 변환하는 **재귀적 분해(Recursive Decomposition)** 과정이 선행되어야 한다.

### **2.1 Skeleton-of-Thought (SoT): 병렬적 사고 확장을 통한 효율화**

인간이 글을 쓸 때 개요를 먼저 작성하듯, AI에게도 전체적인 뼈대(Skeleton)를 먼저 생성하게 하고, 이후 각 부분을 구체화하도록 유도하는 **Skeleton-of-Thought (SoT)** 기법을 적용한다.11 SoT는 순차적 디코딩(Sequential Decoding) 방식의 한계를 극복하고, 생성 속도를 높일 뿐만 아니라 논리적 구조의 일관성을 향상시킨다.

1. **Skeleton Stage:** 사용자의 아이디어를 입력받아, 시스템의 주요 기능 목록, 핵심 모듈, 예상되는 기술적 난제 등을 포함한 간략한 뼈대를 생성한다. 이때 세부 내용은 의도적으로 배제하고 전체적인 구조 잡기에 집중한다.  
2. **Point-Expanding Stage:** 생성된 뼈대의 각 항목에 대해 별도의 프롬프트나 병렬 처리(Parallel API Calls)를 통해 상세 내용을 확장한다.13 예를 들어, '사용자 인증'이라는 항목이 있다면, 이를 'OAuth 2.0 흐름', 'JWT 토큰 관리', '비밀번호 보안 정책' 등으로 세분화하여 구체적인 요구사항을 기술하게 한다.

이 과정에서 AI는 각 부분에 집중할 수 있어, 전체 맥락을 유지하면서도 깊이 있는 내용을 생성할 수 있다. 이는 특히 긴 호흡의 보고서나 상세한 기술 명세서를 작성할 때 효과적이다.

### **2.2 RDoLT(Recursive Decomposition of Logical Thoughts)를 통한 논리 강화**

단순한 기능 나열을 넘어, 기능 간의 인과관계와 복잡성을 해결하기 위해 **RDoLT** 기법을 도입한다.14 RDoLT는 복잡한 문제를 'Easy', 'Intermediate', 'Final'의 세 단계 난이도로 분해하고, 각 단계의 해결 결과를 다음 단계의 입력으로 활용하는 재귀적 구조를 가진다.

* **Easy Level:** 아이디어에서 명확하게 드러나는 기본 기능(예: 로그인, 상품 조회)을 정의한다.  
* **Intermediate Level:** 기본 기능 간의 상호작용이나 비즈니스 로직(예: 상품 조회 후 장바구니 담기 시 재고 확인 로직)을 구체화한다.  
* **Final Level:** 예외 상황, 성능 요구사항, 보안 제약 등 고도의 추론이 필요한 비기능적 요구사항을 도출한다.

이러한 단계적 접근은 초기에 발생할 수 있는 오류가 후속 단계로 전파되는 것을 방지하고, AI가 단계별로 사고의 깊이를 더해가도록 유도한다. 또한, 각 단계마다 **'Self-Critique(자기 비판)'** 프롬프트를 삽입하여, "현재 정의된 요구사항 중 모호한 표현이 있는가?", "논리적 비약이 있는가?"를 스스로 점검하게 함으로써 명세의 품질을 높인다.15

### **2.3 재귀적 사용자 스토리 생성과 정밀화**

구체화된 기능들은 최종적으로 개발자가 구현할 수 있는 단위인 \*\*사용자 스토리(User Story)\*\*로 변환되어야 한다. 이때 AI의 창의성보다는 **INVEST 원칙**(Independent, Negotiable, Valuable, Estimable, Small, Testable)을 준수하는 구조적 엄격성이 요구된다.16

다음과 같은 **재귀적 프롬프트 템플릿**을 활용하여 사용자 스토리의 품질을 극대화한다 17:

* **초기 생성:** "당신은 20년 경력의 프로덕트 오너(PO)이다. \[기능 명\]에 대한 사용자 스토리를 'As a, I want, So that' 형식으로 작성하라."  
* **인수 조건(Acceptance Criteria) 추가:** "작성된 스토리에 대해 Gherkin 문법(Given-When-Then)을 사용하여 구체적인 인수 테스트 케이스를 3가지 이상 추가하라."  
* **반복적 정제(Recursive Refinement):** "생성된 스토리가 개발자가 작업하기에 충분히 구체적인지 평가하고, 모호한 부분(예: '적절히', '빠르게')이 있다면 수치화된 지표로 수정하라."

이러한 과정을 통해 생성된 REQUIREMENTS.md는 단순한 텍스트가 아니라, 후속 단계인 도메인 모델링과 아키텍처 설계의 견고한 입력 데이터로 기능하게 된다.

---

## **3\. 도메인 탐색: AI 퍼실리테이터와 함께하는 Event Storming**

요구사항 명세서가 완성되었다면, 이를 바탕으로 시스템의 동적인 흐름과 도메인 객체를 식별하는 과정이 필요하다. \*\*이벤트 스토밍(Event Storming)\*\*은 비즈니스 프로세스를 시각화하고 도메인 지식을 공유하는 데 최적화된 방법론이다.19 전통적으로는 인간 전문가들이 모여 수행하지만, AI를 도메인 전문가이자 퍼실리테이터로 활용하여 이 과정을 시뮬레이션할 수 있다.20

### **3.1 AI 기반 Event Storming의 단계별 프롬프트 체인**

AI와 함께하는 Event Storming은 단일 프롬프트로 처리하기에는 복잡도가 높다. 따라서 \*\*프롬프트 체인(Prompt Chaining)\*\*을 통해 단계별로 정보를 추출하고 정제하는 방식이 효과적이다.22 Qlerify와 같은 도구에서 사용하는 워크플로우를 참조하여, 다음과 같은 단계로 진행한다.24

| 단계 | 목표 | 프롬프트 지침 (지시사항 요약) | 산출물 예시 |
| :---- | :---- | :---- | :---- |
| **Step 1: Event Identification** | 모든 도메인 이벤트 식별 | "시스템 내에서 발생하는 모든 중요 사건을 '과거형 동사'로 나열하라. (예: OrderPlaced, PaymentFailed)" | Created Lead, Approved Order |
| **Step 2: Temporal Sequencing** | 시간 순서 배열 | "나열된 이벤트를 시간 순서대로 재배열하고, 선후 관계가 불분명하거나 누락된 이벤트가 있다면 보완하라." | OrderCreated \-\> PaymentProcessed \-\> OrderShipped |
| **Step 3: Command & Actor** | 원인과 주체 규명 | "각 이벤트를 유발하는 명령(Command)과 그 명령을 실행하는 주체(Actor/System)를 매핑하라." | User \-\> Place Order \-\> Order Placed |
| **Step 4: Aggregate Grouping** | 데이터 무결성 단위 식별 | "관련된 커맨드와 이벤트를 묶어 상태 변경의 단위인 'Aggregate'를 정의하라. 기술 용어가 아닌 비즈니스 용어를 사용하라." | Order Aggregate, Payment Aggregate |
| **Step 5: Bounded Context** | 도메인 경계 설정 | "식별된 Aggregate들을 응집도 높은 그룹으로 묶어 'Bounded Context'를 정의하고, 각 컨텍스트의 책임을 명시하라." | Order Context, Billing Context, Shipping Context |

### **3.2 Bounded Context와 유비쿼터스 언어의 확립**

도메인 주도 설계(DDD)의 핵심은 \*\*Bounded Context(제한된 문맥)\*\*를 통해 용어의 중의성(Polysemy)을 해소하는 것이다.25 예를 들어, 'User'라는 용어는 '인증 컨텍스트'에서는 '계정(Account)'으로, '배송 컨텍스트'에서는 '수령인(Recipient)'으로 정의될 수 있다. AI가 전체 시스템을 하나의 거대한 모델로 설계하려 할 때 발생하는 'Context Collision'을 방지하기 위해, 명시적으로 "각 컨텍스트 내에서만 유효한 **유비쿼터스 언어(Ubiquitous Language)** 사전을 정의하라"고 지시해야 한다.27

이 단계의 산출물인 DOMAIN\_MODEL.md와 GLOSSARY.md는 단순한 용어집이 아니라, 시스템의 논리적 구획을 나누는 경계석 역할을 한다. 특히 GLOSSARY.md는 이후 AI가 변수명이나 클래스명을 지을 때 참조해야 할 필수 컨텍스트 파일로 AGENTS.md에 링크되어야 한다.

### **3.3 핫스팟(Hotspot) 식별과 정책(Policy) 정의**

Event Storming 과정에서 AI는 단순한 'Happy Path'뿐만 아니라 예외 상황이나 병목 지점인 \*\*'Hotspot'\*\*을 식별해야 한다.24 예를 들어, "결제가 완료되었으나 재고가 부족한 경우"와 같은 시나리오를 찾아내고, 이를 처리하기 위한 비즈니스 정책(Policy)을 정의한다. 이는 "When \[Event\] Then \[Command\]" 형태의 반응형 로직으로 기술되며, 시스템의 견고성을 높이는 데 기여한다.

---

## **4\. 청사진의 시각화: C4 모델 기반의 아키텍처 코드 생성**

도메인 모델링을 통해 논리적 구조가 잡혔다면, 이를 물리적/소프트웨어적 구조로 시각화하는 단계가 필요하다. \*\*C4 모델(Context, Containers, Components, Code)\*\*은 시스템을 계층적으로 추상화하여 보여주는 강력한 도구이며, 텍스트 설명과 다이어그램 코드 생성을 병행하는 LLM의 특성에 가장 적합하다.28

### **4.1 Diagrams as Code: PlantUML을 활용한 자동화**

AI에게 이미지를 직접 생성하게 하는 것은 텍스트 내 정보를 정확하게 반영하지 못할 위험이 크다. 대신, **PlantUML**이나 **Mermaid**와 같은 **Diagrams as Code** 도구를 활용하여 아키텍처를 코드로 정의하게 해야 한다.31 이는 수정이 용이하고(Version Control), 기계 가독성이 높아 검증이 가능하다는 장점이 있다.

#### **Level 1: System Context Diagram**

시스템 전체를 하나의 블랙박스로 보고, 외부 사용자 및 타 시스템과의 관계를 정의한다.

* **프롬프트 전략:** "DOMAIN\_MODEL.md를 참조하여, 시스템의 주요 사용자와 외부 의존성(PG사, 이메일 서버 등)을 식별하고 C4 Context 다이어그램을 PlantUML로 작성하라.".33

#### **Level 2: Container Diagram**

시스템을 구성하는 개별 실행 단위(웹 서버, 데이터베이스, 마이크로서비스 등)를 정의한다. 이 단계에서 \*\*기술 스택(Tech Stack)\*\*에 대한 의사결정이 이루어져야 한다.

* **기술 스택 제안:** AI에게 "요구사항의 트래픽 예상치와 실시간성 요구를 고려하여, 가장 적합한 기술 스택(언어, 프레임워크, DB)을 제안하고 그 이유를 설명하라"고 지시한다.34  
* **다이어그램 생성:** 결정된 기술 스택을 반영하여 각 컨테이너의 책임과 통신 프로토콜(HTTP/REST, gRPC, Kafka)을 명시한 C4 Container 다이어그램 코드를 생성한다.

#### **Level 3: Component Diagram**

각 컨테이너 내부의 모듈(Controller, Service, Repository 등) 구성을 상세화한다. 앞서 Event Storming에서 도출된 **Aggregate**와 **Bounded Context**가 이 단계에서 실제 소프트웨어 컴포넌트로 매핑된다.35

* **매핑 검증:** "도출된 모든 Aggregate가 적절한 컴포넌트로 구현되었는지 확인하고, 누락된 비즈니스 로직이 없는지 점검하라."

### **4.2 아키텍처 일관성 검증 (Architectural Validation)**

생성된 C4 모델이 초기 요구사항 및 도메인 모델과 일치하는지 검증하는 **Cross-Check** 절차가 필수적이다.36 LLM은 시각적 정보를 해석하는 데 한계가 있으므로, PlantUML 코드 자체를 분석하거나 다이어그램의 텍스트 설명을 기반으로 검증을 수행해야 한다.

* **추적성(Traceability) 분석:** "Requirement ID \#123 ('사용자는 결제 내역을 조회할 수 있다')이 어떤 컨테이너와 컴포넌트에 의해 처리되는지 추적하여 설명하라."  
* **자기 수정(Self-Correction):** "생성된 아키텍처에서 단일 장애점(SPOF)이나 병목 구간이 될 수 있는 부분을 식별하고, 이를 개선하기 위한 아키텍처 변경을 제안하라.".37

---

## **5\. 통합 및 거버넌스: 멀티 에이전트 오케스트레이션과 프로젝트 DNA**

지금까지의 단계들이 개별적인 활동이었다면, 이를 하나의 유기적인 흐름으로 묶고 관리하는 **거버넌스(Governance)** 체계가 필요하다. 특히 복잡한 시스템을 설계할 때는 단일 에이전트보다 전문화된 역할을 가진 \*\*멀티 에이전트 시스템(Multi-Agent System, MAS)\*\*이 효율적이다.38

### **5.1 멀티 에이전트 협업 구조**

각 단계별로 특화된 에이전트를 배치하고, 이들의 상호작용을 조율하는 오케스트레이터(Orchestrator)를 둔다.

| 에이전트 역할 | 주요 책임 | 참조 컨텍스트 |
| :---- | :---- | :---- |
| **Product Owner Agent** | 아이디어 분해, 사용자 스토리 작성, 우선순위 결정 | REQUIREMENTS.md, User Stories |
| **Domain Expert Agent** | Event Storming 주도, 용어 정의, 비즈니스 규칙 수립 | DOMAIN\_MODEL.md, GLOSSARY.md |
| **Software Architect Agent** | 기술 스택 선정, C4 모델링, 아키텍처 검증 | ARCHITECTURE.md, ADR.md |
| **Lead Orchestrator** | 전체 프로세스 관리, 에이전트 간 정보 전달, 최종 승인 | AGENTS.md, NOTES.md |

* **동기 vs 비동기 실행:** 초기 설계 단계에서는 에이전트 간의 긴밀한 협의가 필요하므로 **동기식(Synchronous)** 실행이 유리하다. 반면, 상세 명세 작성이나 다이어그램 코드 생성과 같은 작업은 \*\*비동기식(Asynchronous)\*\*으로 병렬 처리하여 효율을 높일 수 있다.38  
* **임시 에이전트(Transient Agents):** 특정 문제 해결(예: 보안 취약점 점검, 성능 시뮬레이션)을 위해 일시적으로 생성되었다가 임무 완료 후 소멸하는 에이전트를 활용하여 시스템의 리소스를 최적화한다.40

### **5.2 프로젝트 DNA의 최종 형상화**

전반부 프로세스의 최종 산출물은 단순한 문서 묶음이 아니라, 후반부(구현) 단계를 위한 실행 가능한 \*\*'Blueprint Package'\*\*여야 한다. 이는 다음과 같은 파일들로 구성된다.

1. **AGENTS.md:** 프로젝트의 대원칙, 코딩 컨벤션, 아키텍처 제약 사항 (불변의 DNA).  
2. **REQUIREMENTS.md:** INVEST 원칙을 준수하는 사용자 스토리 및 인수 조건.  
3. **DOMAIN\_MODEL.md & GLOSSARY.md:** 유비쿼터스 언어 사전 및 도메인 이벤트 흐름.  
4. **ARCHITECTURE.md:** C4 모델의 PlantUML 코드 및 아키텍처 결정 기록(ADR).  
5. **API\_SPEC.yaml (Draft):** 주요 컴포넌트 간의 인터페이스 명세 초안.

이 패키지는 개발팀(혹은 AI 코딩 에이전트)에게 전달되어, 별도의 추가 설명 없이도 일관성 있는 코드를 생산해낼 수 있는 완벽한 지침서 역할을 수행한다.

---

## **6\. 결론 및 향후 전망**

'DNA Development Methodology'의 전반부 프로세스 재설계는 AI의 창의성과 구조적 엄격성 사이의 균형을 찾는 작업이었다. 본 보고서에서 제안한 **컨텍스트 엔지니어링**, **재귀적 분해**, **AI 기반 Event Storming**, 그리고 **C4 모델링**의 통합은 LLM이 가진 'Context Rot'과 일관성 결여 문제를 기술적으로 극복할 수 있는 실질적인 해법을 제시한다.

특히, AGENTS.md와 같은 정적 앵커를 통한 **기억의 고정**, RDoLT와 SoT를 활용한 **사고의 확장**, 그리고 Diagrams as Code를 통한 **시각적 검증**은 아이디어가 청사진으로 구체화되는 과정에서 정보의 엔트로피가 증가하는 것을 막아주는 핵심 기제이다.

**향후 발전 방향:**

* **자동화 파이프라인 구축:** LangChain이나 AutoGen과 같은 프레임워크를 활용하여, 본 보고서에서 정의한 프로세스를 완전 자동화된 CI/CD 파이프라인의 일부로 통합해야 한다.  
* **RAG 기반의 동적 지식 베이스:** 프로젝트가 진행될수록 축적되는 아키텍처 결정과 코드베이스의 변화를 실시간으로 벡터 데이터베이스에 인덱싱하고, RAG(Retrieval-Augmented Generation)를 통해 에이전트에게 제공함으로써 '장기 기억' 능력을 획기적으로 개선할 수 있다.41

이러한 방법론적 진화는 소프트웨어 개발의 속도와 품질을 동시에 혁신하며, AI를 단순한 코딩 도구가 아닌 진정한 의미의 '아키텍처 파트너'로 격상시키는 계기가 될 것이다.

---

## **부록: 구현을 위한 상세 가이드 및 템플릿**

### **A. AGENTS.md 예시 템플릿**

# **AGENTS.md \- Project DNA & Rules**

## **1\. Project Identity**

* **Name:** \[Project Name\]  
* **Description:**  
* **Persona:** You are a Senior Software Architect specializing in DDD and Cloud-Native architectures.

## **2\. Cognitive Constraints (Must Follow)**

* **Reasoning First:** Always explain the reasoning before generating code or diagrams.  
* **Recursive refinement:** Critique your own output for logical inconsistencies before final answer.  
* **Context Preservation:** Refer to GLOSSARY.md for all domain terminology. Do not invent new terms for existing concepts.

## **3\. Technical Standards**

* **Architecture Style:** Modular Monolith / Microservices (based on ARCHITECTURE.md)  
* **Diagramming Tool:** PlantUML (Use standard C4 macros).  
* **Documentation Format:** Markdown with clear headers.

## **4\. Memory Management**

* Update NOTES.md at the end of every significant decision or milestone.  
* If context window limit approaches, perform **Chain of Density** summarization on current session logic.

### **B. Event Storming 프롬프트 체인 상세**

* **Step 1 (Events):** "Identify all domain events in the process. Format: \[Event Name\] (Past Tense)."  
* **Step 2 (Commands):** "For each event, identify the trigger command and actor. Format: \[Actor\] \-\> \[Command\] \-\> \[Event\]."  
* **Step 3 (Aggregates):** "Group these command-event pairs into Aggregates. Ensure transactional consistency within each aggregate."  
* **Step 4 (Contexts):** "Map these Aggregates to Bounded Contexts. Define the relationship (Upstream/Downstream) between contexts."

### **C. C4 PlantUML 생성 프롬프트 예시**

"Using the C4-PlantUML library conventions, generate a **Container Diagram** for the.

* Include containers for: Web App, API Gateway, Service, Database.  
* Define relationships with specific protocols (e.g., HTTPS/JSON, AMQP).  
* Add explanatory notes for key architectural decisions.  
* Output strictly valid PlantUML code inside plantuml blocks."

#### **참고 자료**

1. 6 Techniques You Should Know to Manage Context Lengths in LLM Apps \- Reddit, 11월 18, 2025에 액세스, [https://www.reddit.com/r/LLMDevs/comments/1mviv2a/6\_techniques\_you\_should\_know\_to\_manage\_context/](https://www.reddit.com/r/LLMDevs/comments/1mviv2a/6_techniques_you_should_know_to_manage_context/)  
2. Effective context engineering for AI agents \\ Anthropic, 11월 18, 2025에 액세스, [https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents](https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents)  
3. AGENTS.md, 11월 18, 2025에 액세스, [https://agents.md/](https://agents.md/)  
4. Rules | Cursor Docs, 11월 18, 2025에 액세스, [https://cursor.com/docs/context/rules](https://cursor.com/docs/context/rules)  
5. Prompt Engineering of LLM Prompt Engineering : r/PromptEngineering \- Reddit, 11월 18, 2025에 액세스, [https://www.reddit.com/r/PromptEngineering/comments/1hv1ni9/prompt\_engineering\_of\_llm\_prompt\_engineering/](https://www.reddit.com/r/PromptEngineering/comments/1hv1ni9/prompt_engineering_of_llm_prompt_engineering/)  
6. Few good cases for using LLM as Software Architect (part 2\) | by Dejan Vukmirović \- Medium, 11월 18, 2025에 액세스, [https://medium.com/@deyo.vuk/few-good-cases-for-using-llm-as-software-architect-part-2-0bcd8fd54086](https://medium.com/@deyo.vuk/few-good-cases-for-using-llm-as-software-architect-part-2-0bcd8fd54086)  
7. Why larger LLM context windows are all the rage \- IBM Research, 11월 18, 2025에 액세스, [https://research.ibm.com/blog/larger-context-window](https://research.ibm.com/blog/larger-context-window)  
8. Better Summarization with Chain of Density Prompting \- PromptHub, 11월 18, 2025에 액세스, [https://www.prompthub.us/blog/better-summarization-with-chain-of-density-prompting](https://www.prompthub.us/blog/better-summarization-with-chain-of-density-prompting)  
9. Chain of Density (CoD) \- Learn Prompting, 11월 18, 2025에 액세스, [https://learnprompting.org/docs/advanced/self\_criticism/chain-of-density](https://learnprompting.org/docs/advanced/self_criticism/chain-of-density)  
10. Git Context Controller: Manage the Context of LLM-based Agents like Git \- arXiv, 11월 18, 2025에 액세스, [https://arxiv.org/html/2508.00031v1](https://arxiv.org/html/2508.00031v1)  
11. Skeleton-of-Thought \- Google Sites, 11월 18, 2025에 액세스, [https://sites.google.com/view/sot-llm](https://sites.google.com/view/sot-llm)  
12. Skeleton-of-Thought: Prompting LLMs for Efficient Parallel Generation | OpenReview, 11월 18, 2025에 액세스, [https://openreview.net/forum?id=mqVgBbNCm9](https://openreview.net/forum?id=mqVgBbNCm9)  
13. Accelerating LLMs with Skeleton-of-Thought Prompting \- Portkey, 11월 18, 2025에 액세스, [https://portkey.ai/blog/skeleton-of-thought-prompting/](https://portkey.ai/blog/skeleton-of-thought-prompting/)  
14. Recursive Decomposition of Logical Thoughts: Framework for Superior Reasoning and Knowledge Propagation in Large Language Models \- arXiv, 11월 18, 2025에 액세스, [https://arxiv.org/html/2501.02026v1](https://arxiv.org/html/2501.02026v1)  
15. Advanced Prompt Engineering Techniques for 2025: Beyond Basic Instructions \- Reddit, 11월 18, 2025에 액세스, [https://www.reddit.com/r/PromptEngineering/comments/1k7jrt7/advanced\_prompt\_engineering\_techniques\_for\_2025/](https://www.reddit.com/r/PromptEngineering/comments/1k7jrt7/advanced_prompt_engineering_techniques_for_2025/)  
16. LLM-based agents for automating the enhancement of user story quality: An early report, 11월 18, 2025에 액세스, [https://arxiv.org/html/2403.09442v1](https://arxiv.org/html/2403.09442v1)  
17. Prompt Template for creating User Story | by Mike \- Medium, 11월 18, 2025에 액세스, [https://medium.com/@nik.krichko/prompt-template-for-creating-user-story-ed687b58d53f](https://medium.com/@nik.krichko/prompt-template-for-creating-user-story-ed687b58d53f)  
18. ChatGPT Prompts For User Stories | Template by ClickUp™, 11월 18, 2025에 액세스, [https://clickup.com/templates/ai-prompts/user-stories](https://clickup.com/templates/ai-prompts/user-stories)  
19. Event Storming Workshop: A Game-Changer for Mapping Complex Business Domains, 11월 18, 2025에 액세스, [https://nexocode.com/blog/posts/event-storming-workshop-mapping-business-domains/](https://nexocode.com/blog/posts/event-storming-workshop-mapping-business-domains/)  
20. Designing Scalable Multi-Agent AI Systems \- DZone, 11월 18, 2025에 액세스, [https://dzone.com/articles/multi-agent-ai-ddd-event-storming](https://dzone.com/articles/multi-agent-ai-ddd-event-storming)  
21. DDD & Domain Modeling: Using AI to Accelerate Design \- with Staffan Palopää \- YouTube, 11월 18, 2025에 액세스, [https://www.youtube.com/watch?v=fyN8yGtlIjs](https://www.youtube.com/watch?v=fyN8yGtlIjs)  
22. Prompt Chaining Langchain | IBM, 11월 18, 2025에 액세스, [https://www.ibm.com/think/tutorials/prompt-chaining-langchain](https://www.ibm.com/think/tutorials/prompt-chaining-langchain)  
23. Prompt Chaining | Prompt Engineering Guide, 11월 18, 2025에 액세스, [https://www.promptingguide.ai/techniques/prompt\_chaining](https://www.promptingguide.ai/techniques/prompt_chaining)  
24. Event Storming Tool \- Qlerify | AI-Powered & Collaborative, 11월 18, 2025에 액세스, [https://www.qlerify.com/event-storming-tool](https://www.qlerify.com/event-storming-tool)  
25. Bounded Context \- Martin Fowler, 11월 18, 2025에 액세스, [https://www.martinfowler.com/bliki/BoundedContext.html](https://www.martinfowler.com/bliki/BoundedContext.html)  
26. Blog: From Good to Excellent in DDD: Understanding Bounded Contexts in Domain-Driven Design \- 8/10 \- Kranio, 11월 18, 2025에 액세스, [https://www.kranio.io/en/blog/de-bueno-a-excelente-en-ddd-comprender-bounded-contexts-en-domain-driven-design---8-10](https://www.kranio.io/en/blog/de-bueno-a-excelente-en-ddd-comprender-bounded-contexts-en-domain-driven-design---8-10)  
27. Enhancing Domain-Driven Design with Generative AI \- Sahaj Software, 11월 18, 2025에 액세스, [https://www.sahaj.ai/enhancing-domain-driven-design-with-generative-ai/](https://www.sahaj.ai/enhancing-domain-driven-design-with-generative-ai/)  
28. What is C4 Model? Complete Guide for Software Architecture \- Miro, 11월 18, 2025에 액세스, [https://miro.com/diagramming/c4-model-for-software-architecture/](https://miro.com/diagramming/c4-model-for-software-architecture/)  
29. C4 model: Home, 11월 18, 2025에 액세스, [https://c4model.com/](https://c4model.com/)  
30. How to Create Software Architecture Diagrams Using the C4 Model \- freeCodeCamp, 11월 18, 2025에 액세스, [https://www.freecodecamp.org/news/how-to-create-software-architecture-diagrams-using-the-c4-model/](https://www.freecodecamp.org/news/how-to-create-software-architecture-diagrams-using-the-c4-model/)  
31. C4-PlantUML combines the benefits of PlantUML and the C4 model for providing a simple way of describing and communicate software architectures \- GitHub, 11월 18, 2025에 액세스, [https://github.com/plantuml-stdlib/C4-PlantUML](https://github.com/plantuml-stdlib/C4-PlantUML)  
32. C4-PlantUML Studio | AI-Powered C4 Diagram Generator \- Visual Paradigm, 11월 18, 2025에 액세스, [https://www.visual-paradigm.com/features/c4-plantuml-studio](https://www.visual-paradigm.com/features/c4-plantuml-studio)  
33. From Whiteboard to Prompt: Modeling Systems with LLMs | by Dave Patten | Medium, 11월 18, 2025에 액세스, [https://medium.com/@dave-patten/from-whiteboard-to-prompt-modeling-systems-with-llms-2794fa4af628](https://medium.com/@dave-patten/from-whiteboard-to-prompt-modeling-systems-with-llms-2794fa4af628)  
34. How to create a project's C4 model in just a few steps using AI \- StackSpot, 11월 18, 2025에 액세스, [https://stackspot.com/en/blog/c4-model-2/](https://stackspot.com/en/blog/c4-model-2/)  
35. The C4 Model Explained: Clearer Software Architecture Diagrams with Structurizr \- Devōt, 11월 18, 2025에 액세스, [https://devot.team/blog/c4-model](https://devot.team/blog/c4-model)  
36. Interpreting Workflow Architectures by LLMs \- SciTePress, 11월 18, 2025에 액세스, [https://www.scitepress.org/Papers/2025/133580/133580.pdf](https://www.scitepress.org/Papers/2025/133580/133580.pdf)  
37. Build a robust text-to-SQL solution generating complex queries, self-correcting, and querying diverse data sources | Artificial Intelligence \- Amazon AWS, 11월 18, 2025에 액세스, [https://aws.amazon.com/blogs/machine-learning/build-a-robust-text-to-sql-solution-generating-complex-queries-self-correcting-and-querying-diverse-data-sources/](https://aws.amazon.com/blogs/machine-learning/build-a-robust-text-to-sql-solution-generating-complex-queries-self-correcting-and-querying-diverse-data-sources/)  
38. How we built our multi-agent research system \- Anthropic, 11월 18, 2025에 액세스, [https://www.anthropic.com/engineering/multi-agent-research-system](https://www.anthropic.com/engineering/multi-agent-research-system)  
39. Designing Multi-Agent Intelligence \- Microsoft for Developers, 11월 18, 2025에 액세스, [https://developer.microsoft.com/blog/designing-multi-agent-intelligence](https://developer.microsoft.com/blog/designing-multi-agent-intelligence)  
40. How to embed responsible AI into multi-agent systems | EY \- US, 11월 18, 2025에 액세스, [https://www.ey.com/en\_us/consulting/agentic-ai/how-to-embed-responsible-ai-into-multi-agent-systems](https://www.ey.com/en_us/consulting/agentic-ai/how-to-embed-responsible-ai-into-multi-agent-systems)  
41. Why I'm not worried about LLMs long context problem. | by Social Scholarly \- Medium, 11월 18, 2025에 액세스, [https://medium.com/@socialscholarly/why-im-not-worried-about-llms-long-context-problem-eed21db44687](https://medium.com/@socialscholarly/why-im-not-worried-about-llms-long-context-problem-eed21db44687)