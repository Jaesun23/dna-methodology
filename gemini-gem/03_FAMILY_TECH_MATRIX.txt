# DNA Family Tech Matrix - 7가지 패밀리별 기술 스택 옵션
# 생성일: 2025-12-10
# 포함된 파일 수: 8

================================================================================

📄 FILE: 00_overview.md
--------------------------------------------------------------------------------

# 패밀리별 기술 매트릭스 디렉토리 안내

**작성일**: 2025-11-14 11:56  
**목적**: DNA 방법론 v4.0의 7가지 아키텍처 패밀리별 기술 선택 가이드

---

## 🎯 이 디렉토리의 역할

### DNA 방법론에서의 위치

```
Stage 1: 핵심 정의 (Core Definition)
  - 패밀리 구분 (3-Layer Decision Tree)
  ↓
🔥 여기! 패밀리별 기술 매트릭스 🔥
  ↓
Stage 2: 구현 방법 (Implementation Method)
  - Layer 3 제약사항 조사
  - NFR 우선순위 결정
  - 5단계 설계 프로세스
  ↓
Stage 3: ADR 작성 (Architecture Decision Records)
  - DNA 시스템 ADR
  - 도메인 특화 ADR
```

### 3가지 핵심 역할

#### 1. 패밀리별 필수 기술 자동 결정
- 패밀리 코드 (예: B-C-A) → 필수 DNA 시스템 도출
- 개발자가 "뭘 써야 하지?"를 고민하지 않도록
- 검증된 기술 조합 제시

#### 2. DNA 시스템 vs 도메인 기술 구분
- **DNA 시스템**: 패밀리가 강제하는 필수 요소 (공통 인프라)
- **도메인 기술**: 프로젝트 특성에 따라 선택 (서비스 로직)
- ADR 작성 범위 명확화

#### 3. 다음 단계로 자연스럽게 연결
- 기술 선택 → Stage 3 ADR 작성
- ADR → Stage 4 청사진 작성
- 체계적 의사결정 프로세스

---

## 🧬 DNA 11개 시스템

DNA 방법론의 핵심은 **11개의 표준 시스템**입니다. 모든 소프트웨어 프로젝트는 이 11개 시스템의 조합으로 구성됩니다.

### 11개 시스템 목록

| # | 시스템 이름 | 역할 | 모든 패밀리 필수? |
|---|------------|------|-----------------|
| **1** | Testing System | 테스트 전략, TDD, 품질 검증 | ✅ 필수 |
| **2** | Code Quality | 코딩 표준, Linting, 포맷팅 | ✅ 필수 |
| **3** | Architecture | 모듈 구조, 의존성 관리, 경계 강제 | ✅ 필수 |
| **4** | Type System | 타입 안전성, 정적 분석 | ✅ 필수 |
| **5** | Error Handling | 에러 처리 전략, 롤백, 복구 | ✅ 필수 |
| **6** | Configuration | 환경 설정, Feature Flags, Secrets | ✅ 필수 |
| **7** | Identity & Access | 인증, 권한, 사용자 관리 | ⚠️ 조건부 |
| **8** | Observability | 로깅, 모니터링, 추적, 메트릭 | ✅ 필수 |
| **9** | API Gateway | 요청 라우팅, Rate Limiting, 인증 | ⚠️ 조건부 |
| **10** | Resilience | 장애 허용, Circuit Breaker, Retry | ✅ 필수 |
| **11** | Performance | 벤치마크, 프로파일링, 최적화 | ✅ 필수 |

**조건부 시스템 설명**:
- **Identity & Access (#7)**: 사용자가 있는 시스템만 필요 (라이브러리/CLI는 불필요)
- **API Gateway (#9)**: 네트워크 API가 있는 시스템만 필요 (로컬 라이브러리는 불필요)

### DNA 시스템 vs 메인 서비스 기술

이 디렉토리의 각 패밀리 파일은 **두 종류의 기술**을 다룹니다:

**1. DNA 시스템 관련 기술** (모든 프로젝트 공통)
- Testing 프레임워크 (pytest, Jest)
- Code Quality 도구 (ESLint, Ruff)
- Observability 도구 (winston, structlog)
- 등등...

**2. 메인 서비스 기술** (패밀리별로 다름)
- A-A-B: RDBMS, 캐시, 메시징
- B-C-A: 스트리밍 플랫폼, 시계열 DB, 캐시
- B-B-B: Vector DB, 검색엔진, Embedding
- 등등...

---

## 📂 7개 패밀리 파일 구조

각 패밀리는 **3차원 코드**로 분류됩니다:

| 파일 | 패밀리 코드 | 패밀리 이름 | 대표 사례 |
|------|------------|------------|-----------|
| `01_ultra_high_frequency_trading_tech_options.md` | **A-A-A** | 초고속 거래 | NASDAQ (14μs), HFT |
| `02_transaction_crud_tech_options.md` | **A-A-B** | 트랜잭션/CRUD | Amazon 주문, Stripe 결제 |
| `03_collaboration_sync_tech_options.md` | **B-A-A** | 협업/동기화 | Google Docs, Figma |
| `04_search_recommendation_tech_options.md` | **B-B-B** | 검색/추천 | Elasticsearch, AI 외부메모리 |
| `05_real_time_streaming_tech_options.md` | **B-C-A** | 실시간 스트리밍 | Netflix RDG, Uber GPS |
| `06_analytics_batch_tech_options.md` | **B-A-C** | 분석/배치 | Snowflake, BigQuery |
| `07_safety_critical_iot_tech_options.md` | **A-B-A** | 안전-임계 IoT | 산업 제어, 긴급 경보 |

### 패밀리별 필요 DNA 시스템 매트릭스

| DNA 시스템 | A-A-A | A-A-B | B-A-A | B-B-B | B-C-A | B-A-C | A-B-A |
|-----------|-------|-------|-------|-------|-------|-------|-------|
| 1. Testing | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| 2. Code Quality | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| 3. Architecture | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| 4. Type System | ⭐⭐⭐ | ✅ | ✅ | ✅ | ✅ | ✅ | ⭐⭐⭐ |
| 5. Error Handling | ✅ | ⭐⭐⭐ | ✅ | ✅ | ✅ | ✅ | ⭐⭐⭐ |
| 6. Configuration | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| 7. Identity & Access | ❌ | ⭐⭐⭐ | ⭐⭐⭐ | ✅ | ✅ | ✅ | ⚠️ |
| 8. Observability | ⭐⭐⭐ | ✅ | ✅ | ✅ | ⭐⭐⭐ | ✅ | ⭐⭐⭐ |
| 9. API Gateway | ❌ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ✅ | ✅ | ⭐⭐⭐ |
| 10. Resilience | ⭐⭐⭐ | ⭐⭐⭐ | ✅ | ✅ | ⭐⭐⭐ | ✅ | ⭐⭐⭐ |
| 11. Performance | ⭐⭐⭐ | ✅ | ⭐⭐⭐ | ✅ | ⭐⭐⭐ | ✅ | ✅ |

**범례**:
- ✅ 필수 (기본 수준)
- ⭐⭐⭐ 매우 중요 (높은 우선순위, 특별한 주의 필요)
- ⚠️ 조건부 (프로젝트 특성에 따라)
- ❌ 불필요 (해당 패밀리에서 거의 사용 안 함)

**패밀리별 특징**:
- **A-A-A (초고속 거래)**: Type System, Performance, Observability 극대화
- **A-A-B (트랜잭션)**: Identity, API Gateway, Error Handling, Resilience 중요
- **B-A-A (협업)**: Identity, API Gateway, Performance (실시간 동기화)
- **B-B-B (검색)**: API Gateway (검색 API), Identity (접근 제어)
- **B-C-A (스트리밍)**: Observability, Resilience, Performance (메시지 처리량)
- **B-A-C (분석)**: 기본 DNA 시스템으로 충분
- **A-B-A (IoT)**: Type System, Error Handling, Observability, Resilience 중요

### 패밀리별 메인 서비스 기술

각 패밀리는 DNA 시스템 외에 **메인 서비스 기술**이 필요합니다:

| 패밀리 | 메인 서비스 핵심 기술 | 이유 |
|-------|-------------------|------|
| **A-A-A** | FPGA, 코로케이션, RDMA 네트워킹 | 마이크로초급 레이턴시 필수 |
| **A-A-B** | RDBMS, 캐시, 메시징 | ACID 트랜잭션 + 성능 + 비동기 |
| **B-A-A** | CRDT/OT 엔진, WebSocket, 동기화 DB | 실시간 협업 + 충돌 해결 |
| **B-B-B** | Vector DB, Embedding 모델, 검색엔진 | 유사도 검색 + 랭킹 |
| **B-C-A** | 스트리밍 플랫폼, 시계열 DB, 캐시 | 대용량 이벤트 처리 |
| **B-A-C** | 데이터 웨어하우스, ETL, BI 도구 | 대규모 배치 분석 |
| **A-B-A** | MQTT, SCADA, 센서 융합 | IoT 프로토콜 + 실시간 제어 |

---

### 3차원 코드 의미

**첫 번째 글자 (실패의 파급력)**:
- **A** (Critical): 치명적 - 실패 시 생명/재산/시장 손실
- **B** (Graceful): 점진적 - 실패 시 성능 저하, 계속 작동 가능

**두 번째 글자 (데이터의 형태)**:
- **A** (Structured): 구조화 - 고정 스키마, 명확한 관계
- **B** (Semi-Structured): 반구조화 - 유연한 스키마, JSON/XML
- **C** (Unstructured): 비구조화 - 스키마 없음, 이벤트/로그

**세 번째 글자 (응답 시점)**:
- **A** (Real-time): 밀리초 - 즉각 응답 (< 100ms)
- **B** (Interactive): 수초 - 사람이 기다릴 수 있는 속도 (1~10초)
- **C** (Batch): 배치 - 스케줄 기반 (시간/일 단위)

---

## 📖 각 파일의 구조 (4-Part)

모든 패밀리 파일은 동일한 구조를 따릅니다:

### Part 1: 패밀리가 요구하는 시스템 구조 ⭐⭐⭐
- 각 차원(A/B/C)이 강제하는 기술적 요구사항
- 검증 사례 (Netflix, Google, Uber 등)
- **이 패밀리에 필요한 DNA 시스템** (11개 중 선택)
- **메인 서비스 필수 기술** (2~5개)

### Part 2: 메인 서비스 기술 선택 ⭐⭐⭐
- 각 메인 서비스 기술마다 **3가지 옵션** 제시:
  - 옵션 1: 고성능/고비용
  - 옵션 2: 균형 (중간)
  - 옵션 3: 저비용/경량
- 구체적 스펙, 비용, 장단점, 적합 사례
- 비교표 + 의사결정 플로우차트

### Part 2.5: DNA 시스템 기술 선택 (새로 추가) 🆕
- **이 패밀리에 특별히 중요한 DNA 시스템**에 대한 기술 옵션
- 예: A-A-A는 Performance 시스템이 매우 중요 → 벤치마크 도구 3가지 비교
- 예: A-A-B는 Identity 시스템이 중요 → 인증 솔루션 3가지 비교
- 모든 DNA 시스템을 다루지 않고, **⭐⭐⭐ 표시된 것만** 다룸

### Part 3: 도메인 선택 요소
- 패밀리와 무관하게 프로젝트별로 선택하는 기술
- 프론트엔드, 백엔드 언어, 인증 등
- 간결하게 (20~50줄)

### Part 4: Stage 2 통합
- Layer 3 제약사항 반영 예시
- NFR 충돌 해결 예시
- ADR 작성 준비 (DNA 시스템 vs 도메인 구분)

---

## 🚀 사용 방법

### Step 1: 패밀리 코드 확정
Stage 1에서 3-Layer Decision Tree로 패밀리 코드를 확정합니다.

**예시**:
```
Q1: 실패하면? → B (점진적, 일부 손실 허용)
Q2: 데이터 형태? → C (비구조화, 이벤트 스트림)
Q3: 응답 시점? → A (밀리초, 실시간)

→ 패밀리 코드: B-C-A (실시간 스트리밍)
```

### Step 2: 해당 패밀리 파일 열기
`05_real_time_streaming_tech_options.md` 파일을 엽니다.

### Step 3: Part 1 확인 - 필요한 시스템 파악
패밀리가 요구하는 두 종류의 시스템을 확인합니다.

**1. DNA 시스템** (11개 중 필요한 것):
```
✅ 필수: Testing, Code Quality, Architecture, Error Handling, Configuration, Observability, Resilience, Performance
⭐⭐⭐ 특별 중요: Performance (마이크로초 최적화), Type System (안전성)
❌ 불필요: Identity, API Gateway (네트워크 서비스 아님)
```

**2. 메인 서비스 기술** (패밀리 특화):
```
- FPGA/ASIC 하드웨어
- RDMA 네트워킹
- 커널 바이패스 스택
```

### Step 4: Part 2 확인 - 메인 서비스 기술 선택
각 메인 서비스 기술마다 3가지 옵션을 비교하고 선택합니다.

**FPGA 하드웨어 예시**:
- 옵션 1: Custom FPGA (초고성능, 매우 비쌈)
- 옵션 2: 상용 FPGA 카드 (고성능, 비쌈)
- 옵션 3: Software 최적화 (저렴, 마이크로초급 어려움)

비교표와 플로우차트를 참고하여 의사결정합니다.

### Step 4.5: Part 2.5 확인 - 중요 DNA 시스템 기술 선택 🆕
이 패밀리에서 **⭐⭐⭐ 표시된 DNA 시스템**의 기술을 선택합니다.

**Performance System 예시** (A-A-A에서 ⭐⭐⭐):
- 옵션 1: VTune (Intel, 전문가용)
- 옵션 2: perf (Linux 기본)
- 옵션 3: Custom Profiler

**Type System 예시** (A-A-A에서 ⭐⭐⭐):
- 옵션 1: Rust (소유권 시스템)
- 옵션 2: C++ (템플릿)
- 옵션 3: C (수동 관리)

### Step 5: Part 3 확인 - 도메인 기술 선택
프로젝트 특성에 따라 도메인 기술을 선택합니다.

**예시**:
- 백엔드: Node.js vs Python vs Go
- 프론트엔드: React vs Vue
- 인증: Auth0 vs Cognito

### Step 6: Part 4 활용 - Stage 2로 연결
- Layer 3 제약사항 반영 방법 참고
- NFR 충돌 해결 패턴 참고
- **DNA 시스템 ADR 목록 준비** (ADR-001 ~ ADR-011)
- **메인 서비스 ADR 목록 준비** (ADR-101 ~ ADR-1XX)
- **도메인 ADR 목록 준비** (ADR-201 ~ ADR-2XX)

---

## 🎓 핵심 원칙

### 1. 패밀리가 시스템 구조를 결정합니다
- 개발자의 "취향"이 아닌 **시스템 특성**이 필요한 시스템을 강제
- B-C-A 패밀리는 **무조건** 스트리밍 플랫폼 필요
- A-A-B 패밀리는 **무조건** ACID DB 필요
- A-A-A 패밀리는 **무조건** Performance 시스템 극대화 필요

### 2. 3가지 기술 계층 구분이 중요합니다
- **DNA 시스템**: 11개 표준 시스템, 모든 프로젝트 공통 기반 (ADR-001~011)
- **메인 서비스**: 패밀리가 강제하는 핵심 기술 (ADR-101~1XX)
- **도메인 기술**: 프로젝트 특화, 팀 역량/선호도 반영 (ADR-201~2XX)
- 구분하지 않으면 ADR이 뒤죽박죽!

### 3. DNA 시스템은 우선순위가 있습니다
- **✅ 필수**: 모든 패밀리에 기본 수준 필요
- **⭐⭐⭐ 특별 중요**: 해당 패밀리에서 높은 우선순위
- **⚠️ 조건부**: 프로젝트 특성에 따라
- **❌ 불필요**: 해당 패밀리에서 거의 사용 안 함

### 4. 실증 데이터 기반입니다
- 모든 기술 옵션은 **실제 프로덕션 사례** 검증
- 구체적 수치 (처리량, 레이턴시, 비용) 제시
- "빠름" ✗ → "p99 <10ms" ✓

### 4. 의사결정을 지원합니다
- 3가지 옵션 비교 (고/중/저)
- 비교표 + 플로우차트 제공
- "무엇을 선택할지" 명확히 안내

---

## ⚠️ 주의사항

### ❌ 이 파일들은 구현 가이드가 아닙니다
- 코드 예시 없음 (단 한 줄도!)
- 패턴 설명 최소화
- 도구 나열 최소화
- **목적**: 기술 **선택** 지원

### ✅ 구현은 공식 문서를 참고하세요
- PostgreSQL 설정 → PostgreSQL 공식 문서
- Kafka 튜닝 → Kafka 공식 문서
- Redis 패턴 → Redis 공식 문서

### 📝 Context7 MCP 활용
- 모든 기술 정보는 Context7에서 확보
- 출처 확인된 공식 문서만 사용
- 토큰 효율 6~10배 (WebSearch 대비)

---

## 🔗 다음 단계

### 패밀리 선택 완료 후
1. **Stage 2**: 구현 방법 설계
   - Layer 3 제약사항 조사
   - NFR 우선순위 결정
   - 5단계 설계 프로세스

2. **Stage 3**: ADR 작성
   - DNA 시스템 ADR (예: ADR-001 ~ ADR-011)
   - 도메인 특화 ADR (예: ADR-101 ~ ADR-1XX)

3. **Stage 4**: 청사진 작성
   - DNA 시스템 청사진 (common/ 폴더)
   - 도메인 청사진 (services/ 폴더)

4. **Stage 5~9**: 분해 → 체크리스트 → 구현

---

## 📊 완성도 검증

### 7개 패밀리 이론적 완전성
- 3×3×3 = 27가지 이론 조합 중
- ✅ **16개 조합** 프로덕션 검증
- ⭐ **7개 핵심 패밀리** 선정
- 실무 커버리지: **95%+**

### 검증 근거
- **SEI Quality Attributes Framework** 매핑
- **Martin Fowler Patterns** 조합
- **CAP/ACID/BASE Theorem** 반영
- Netflix, Google, Uber, Amazon 등 실증

---

## 💡 자주 묻는 질문

### Q1: 우리 시스템이 여러 패밀리에 걸쳐 있다면?
**A**: 하이브리드 시스템입니다. 각 하위 시스템별로 패밀리를 구분하세요.

**예시 - Netflix**:
- 스트리밍: B-C-A (실시간 스트리밍)
- 결제: A-A-B (트랜잭션/CRUD)
- 추천: B-B-B (검색/추천)

### Q2: 패밀리 코드가 애매하다면?
**A**: 가장 중요한 특성(코어 기능)을 기준으로 선택하세요.

**예시 - 주문 시스템**:
- 코어: 주문 트랜잭션 → A-A-B
- 부가: 실시간 알림 → B-C-A (별도 모듈)

### Q3: DNA 시스템, 메인 서비스, 도메인 기술 구분이 애매하다면?
**A**: 두 가지 기준으로 판단하세요.

**기준 1: 패밀리 변경 시 함께 바뀌는가?**
- **DNA 시스템**: 패밀리 무관, 모든 프로젝트 공통 (Testing, Observability 등)
- **메인 서비스**: A-A-B → B-C-A 변경 시 RDBMS → Kafka로 변경 필수
- **도메인 기술**: 패밀리 변경과 무관 (React → Vue 선택은 패밀리와 무관)

**기준 2: 11개 표준 시스템에 해당하는가?**
- **DNA 시스템**: Testing, Code Quality, Architecture, Type System, Error Handling, Configuration, Identity & Access, Observability, API Gateway, Resilience, Performance
- **메인 서비스**: 위 11개에 해당 안 함 (RDBMS, Kafka, Redis, CRDT 등)
- **도메인 기술**: 위 11개에 해당 안 함 (React, FastAPI, Auth0 등)

**예시**:
- PostgreSQL → 메인 서비스 (A-A-B 패밀리 강제)
- pytest → DNA 시스템 #1 (Testing)
- FastAPI → 도메인 기술 (프로젝트 선택)

### Q4: DNA 시스템 중 ⭐⭐⭐가 많은데 모두 다뤄야 하나요?
**A**: 아니요, Part 2.5에서는 **가장 중요한 1~3개만** 다룹니다.

**예시 - A-A-A**:
- ⭐⭐⭐ 4개: Type System, Observability, Resilience, Performance
- Part 2.5에서 다룰 것: Performance (가장 특수함), Type System (안전성 극대화)
- 나머지는 일반 DNA 시스템 가이드 참고

---

**이 디렉토리는 DNA 방법론의 핵심 연결고리입니다!**

패밀리 선택 → 기술 매트릭스 참고 → ADR 작성 → 청사진 작성 → 구현

체계적이고 검증된 기술 선택으로 프로젝트 성공률을 높이세요! 💪


================================================================================

📄 FILE: 01_ultra_high_frequency_trading_tech_options.md
--------------------------------------------------------------------------------

# 초고속 거래 패밀리 (A-A-A) - 기술 매트릭스

**작성일**: 2025-11-12  
**패밀리**: 초고속 거래 (A-A-A)  
**검증 사례**: NASDAQ X-Stream (37μs), HFT FPGA (480ns), CME Globex

---

## Part 1: 패밀리가 요구하는 시스템 구조 ⭐⭐⭐

### 1.1 A-A-A 특성이 강제하는 것

#### A (치명적 실패) → ACID 트랜잭션 필수

**특성**:
- 단일 거래 오류가 시장 붕괴 유발
- 2010 플래시 크래시: 20분에 1조 달러 손실
- 마이크로초당 수백만 달러 손실 가능
- 롤백 불가능, 실패 방지가 핵심

**강제되는 기술적 요구**:
```
✅ ACID 트랜잭션 보장
✅ 결정론적 성능 (일관된 레이턴시)
✅ 동기식 복제
✅ 원자적 연산 (All-or-Nothing)
```

**검증 사례**:
- NASDAQ: 단일 주문 오류가 전체 시장 중단 유발
- Knight Capital (2012): 45분에 $440M 손실 (버그로 인한 잘못된 주문)

---

#### A (구조화 데이터) → 고정 스키마 필수

**특성**:
- 주문, 체결, 가격 - 엄격한 포맷
- 밀리초 내 검증 필수
- 규제 준수 (MiFID II, Reg NMS)
- 감사 추적 (Audit Trail)

**강제되는 기술적 요구**:
```
✅ 고정 스키마 (Fixed Schema)
✅ 컴파일 타임 타입 체크
✅ 빠른 직렬화 (Protobuf, FIX Protocol)
✅ 인덱싱 최적화
```

**검증 사례**:
- FIX Protocol: 금융 업계 표준 메시지 포맷
- NASDAQ ITCH: 바이너리 프로토콜, 고정 길이 메시지

---

#### A (마이크로초~밀리초) → 극단적 저지연 필수

**특성**:
- NASDAQ: 14-37μs 평균
- HFT FPGA: 480ns-2.6μs
- NYSE: 650μs 미만
- 마이크로초 단위 경쟁

**강제되는 기술적 요구**:
```
✅ 인메모리 연산
✅ 코로케이션 (Co-location)
✅ 커널 바이패스 네트워킹
✅ FPGA/하드웨어 가속
✅ NUMA 최적화
```

**검증 사례**:
- Citadel, Jump Trading: FPGA 기반 480ns 달성 (IEEE 검증)
- SIX Swiss Exchange: 37μs 평균 레이턴시

---

### 1.2 이 패밀리에 필요한 DNA 시스템 및 메인 서비스

#### DNA 11개 시스템 중 필요한 것

A-A-A 패밀리는 다음 DNA 시스템이 필요합니다:

| DNA 시스템 | 중요도 | 이유 |
|-----------|-------|------|
| 1. Testing | ✅ 필수 | 레이턴시 회귀 방지 |
| 2. Code Quality | ✅ 필수 | 결정론적 코드 품질 |
| 3. Architecture | ✅ 필수 | 저지연 모듈 분리 |
| 4. **Type System** | **⭐⭐⭐ 매우 중요** | **Zero-cost abstraction, 컴파일 타임 검증** |
| 5. Error Handling | ✅ 필수 | 패닉 없는 에러 처리 |
| 6. Configuration | ✅ 필수 | 런타임 설정 변경 최소화 |
| 7. Identity & Access | ✅ 필수 | 거래 인증/인가 |
| 8. **Observability** | **⭐⭐⭐ 매우 중요** | **마이크로초급 프로파일링, 핫스팟 추적** |
| 9. API Gateway | ⚠️ 조건부 | 외부 연동 시 필요 |
| 10. Resilience | ✅ 필수 | 장애 복구, Circuit Breaker |
| 11. **Performance** | **⭐⭐⭐ 매우 중요** | **레이턴시 벤치마크, 회귀 방지** |

**특별히 중요한 DNA 시스템 (⭐⭐⭐)**:
- **Type System**: Rust/C++ zero-cost abstraction, GC 없는 메모리 관리 필수
- **Observability**: 마이크로초급 추적, 하드웨어 카운터, CPU 캐시 미스 분석
- **Performance**: 나노초급 벤치마크, 레이턴시 회귀 CI/CD 통합

→ **Part 2.5에서 이 3가지 DNA 시스템의 기술 옵션을 다룹니다.**

#### 메인 서비스 필수 요소 (패밀리 강제)

A-A-A 패밀리는 다음 3가지 시스템 요소를 **반드시** 포함해야 합니다:

#### 1. 인메모리 DB (ACID 지원) (필수!)
**역할**: 거래 상태 저장, ACID 보장
**이유**: 치명적 실패(A) + 마이크로초(A)
**선택지**: VoltDB, Redis Enterprise (ACID), Aerospike

#### 2. 저지연 메시징 (필수!)
**역할**: 주문, 체결, 시장 데이터 전송
**이유**: 구조화(A) + 마이크로초(A)
**선택지**: Aeron, Chronicle Queue, 직접 구현

#### 3. 하드웨어 가속 (선택적이지만 나노초 경쟁 시 필수)
**역할**: 극한의 레이턴시 달성 (나노초~마이크로초)
**이유**: 마이크로초(A) - 경쟁 우위 확보
**선택지**: FPGA, Kernel Bypass (DPDK), RDMA
**참고**: 마이크로초 이하 목표 시 필수, 수 마이크로초 허용 시 선택적

---

## Part 2: 메인 서비스 기술 선택 ⭐⭐⭐

### 2.1 인메모리 DB (ACID) 선택

**패밀리 요구**:
- 마이크로초~밀리초 레이턴시
- ACID 트랜잭션 보장
- 고정 스키마, 빠른 쿼리
- 결정론적 성능

---

#### 옵션 1: VoltDB

**핵심 스펙**:
- **쓰기 처리량**: 초당 100만+ 트랜잭션
- **레이턴시**: 평균 <10ms, p99 <20ms
- **ACID**: 완전한 ACID 지원
- **확장**: 수평 확장 (파티셔닝)

**비용**:
- **Community**: 무료 (제한적)
- **Enterprise**: 월 $5,000~$20,000+ (노드당)

**장점**:
- ⚡ 초고속 인메모리 ACID
- 🔧 SQL 지원 (표준 쿼리)
- 📈 선형 확장 (노드 추가)
- 💪 결정론적 성능

**단점**:
- 💰 높은 라이선스 비용
- 🧑‍💻 전문 지식 필요
- 📊 메모리 제한 (모든 데이터 RAM)
- 🔧 복잡한 튜닝

**적합한 경우**:
- 거래소 수준 (NASDAQ, CME)
- 초당 100만+ 트랜잭션
- ACID 필수
- 예산 $100K+ /year

**검증 사례**: 금융 거래소, 리스크 관리 시스템

---

#### 옵션 2: Redis Enterprise (ACID 모듈)

**핵심 스펙**:
- **레이턴시**: 마이크로초급 (150μs GET)
- **처리량**: 초당 120만 트랜잭션
- **ACID**: RediSearch + RedisJSON (부분적)
- **지속성**: AOF, RDB 스냅샷

**비용**:
- **Redis Stack**: 무료 (제한적)
- **Redis Enterprise**: 월 $3,000~$15,000
- **클라우드**: $0.063~$0.126/hour per GB

**장점**:
- ⚡ 극한의 속도 (마이크로초)
- 🔧 간단한 운영
- 💵 VoltDB 대비 저렴
- 🌐 클라우드 네이티브

**단점**:
- 📊 제한적 ACID (단일 키)
- 💾 메모리 기반 (비쌈)
- 🔧 SQL 미지원 (스크립트 필요)
- ⚠️ 복잡한 트랜잭션 어려움

**적합한 경우**:
- 소규모 HFT 펌
- 단순한 거래 로직
- 마이크로초 필수
- 예산 $50K~$200K /year

**검증 사례**: 중소 HFT, 가격 피드 캐싱

---

#### 옵션 3: Aerospike (Enterprise)

**핵심 스펙**:
- **쓰기 처리량**: 초당 100만+ 쓰기
- **레이턴시**: 밀리초 미만 (SSD)
- **ACID**: Strong Consistency 옵션
- **하이브리드**: RAM + SSD

**비용**:
- **Community**: 무료 (단일 노드)
- **Enterprise**: 월 $5,000~$15,000 (노드당)

**장점**:
- 🚀 초고속 쓰기
- 💰 하이브리드 스토리지 (저렴)
- 📈 페타바이트 확장
- 💪 강한 일관성

**단점**:
- 🔧 SQL 미지원
- 📊 복잡한 트랜잭션 제한
- 🧑‍💻 운영 복잡도
- 💰 Enterprise 고가

**적합한 경우**:
- 대량 데이터 (TB~PB)
- 밀리초급 허용 (마이크로초 불필요)
- 비용 효율성
- 장기 데이터 보관

**검증 사례**: 광고 기술, 사기 탐지, 일부 HFT

---

#### 인메모리 DB 비교표

| 항목 | VoltDB | Redis Enterprise | Aerospike |
|------|--------|------------------|-----------|
| **레이턴시** | <10ms | 150μs | <1ms |
| **ACID** | 완전 지원 | 제한적 | Strong Consistency |
| **SQL** | ✅ | ❌ | ❌ |
| **확장성** | 노드 추가 | 샤딩 | 페타바이트 |
| **비용** | $5K~$20K/월 | $3K~$15K/월 | $5K~$15K/월 |

**의사결정 가이드**:
```
완전한 ACID + SQL 필수? → VoltDB
  └─ NO
     ↓
마이크로초 필수? → Redis Enterprise
  └─ NO
     ↓
대량 데이터 (TB+)? → Aerospike
  └─ NO → Redis Enterprise
```

---

### 2.2 저지연 메시징 선택

**패밀리 요구**:
- 마이크로초~밀리초 레이턴시
- 결정론적 성능
- 순서 보장
- 높은 처리량

---

#### 옵션 1: Aeron (Real Logic)

**핵심 스펙**:
- **레이턴시**: 수십 마이크로초 (LAN)
- **처리량**: 초당 수백만 메시지
- **전송**: UDP 유니캐스트/멀티캐스트, IPC
- **언어**: Java, C, C++

**비용**:
- **오픈소스**: 무료 (Apache 2.0)
- **지원**: $10,000~$50,000/year (Real Logic)

**장점**:
- ⚡ 극한의 저지연 (마이크로초)
- 🔧 오픈소스, 무료
- 💪 결정론적 성능
- 🌐 멀티캐스트 지원

**단점**:
- 🧑‍💻 높은 학습 곡선
- 🔧 직접 운영 필요
- 📚 제한적 생태계
- ⚠️ UDP 기반 (네트워크 의존)

**적합한 경우**:
- HFT, 거래소
- 마이크로초 필수
- 멀티캐스트 시장 데이터
- 전담 DevOps 팀

**검증 사례**: 대형 HFT 펌, 거래소 인프라

---

#### 옵션 2: Chronicle Queue

**핵심 스펙**:
- **레이턴시**: 마이크로초급
- **처리량**: 초당 수백만 메시지
- **지속성**: 메모리 매핑 파일
- **언어**: Java, C++

**비용**:
- **오픈소스**: 무료 (제한적)
- **Enterprise**: $20,000~$100,000/year

**장점**:
- ⚡ 초저지연 (마이크로초)
- 💾 지속성 (MMF 기반)
- 🔧 Java 친화적
- 📚 풍부한 문서

**단점**:
- 💰 Enterprise 고가
- 🔧 단일 머신 제한
- 📊 네트워크 전송 별도 구현
- 🧑‍💻 전문 지식 필요

**적합한 경우**:
- 단일 서버 HFT
- Java 기반 시스템
- 이벤트 소싱 필요
- 예산 $50K~$200K /year

**검증 사례**: 금융 기관, HFT 펌

---

#### 옵션 3: 직접 구현 (Kernel Bypass + Shared Memory)

**핵심 스펙**:
- **레이턴시**: 수백 나노초 (가능)
- **처리량**: 하드웨어 한계
- **기술**: DPDK, RDMA, Shared Memory
- **언어**: C, C++, Rust

**비용**:
- **개발 비용**: $200,000~$1M (6~12개월)
- **운영**: 전담 팀 필요

**장점**:
- ⚡ 최저 레이턴시 (나노초 가능)
- 🔧 완전한 제어
- 🏆 경쟁 우위
- 💪 맞춤형 최적화

**단점**:
- 💰 막대한 개발 비용
- 🧑‍💻 최고 수준 전문가 필수
- ⏱️ 긴 개발 기간 (6~12개월)
- 🔧 유지보수 부담

**적합한 경우**:
- 최상위 HFT 펌 (Citadel, Jump)
- 나노초 경쟁
- 예산 $1M+ /year
- 전담 인프라 팀

**검증 사례**: Citadel, Jump Trading, Virtu Financial

---

#### 저지연 메시징 비교표

| 항목 | Aeron | Chronicle Queue | 직접 구현 |
|------|-------|-----------------|-----------|
| **레이턴시** | 수십 μs | 수 μs | 수백 ns |
| **처리량** | 수백만 msg/s | 수백만 msg/s | 하드웨어 한계 |
| **지속성** | 선택적 | ✅ | 맞춤형 |
| **비용** | 무료 | $20K~$100K/년 | $200K~$1M 개발 |
| **운영** | ⚙️⚙️ 중간 | ⚙️⚙️⚙️ 높음 | ⚙️⚙️⚙️ 매우 높음 |

**의사결정 가이드**:
```
나노초 필수? → 직접 구현
  └─ NO
     ↓
예산 < $50K/년? → Aeron
  └─ NO
     ↓
Java 기반 + 지속성? → Chronicle Queue
  └─ NO → Aeron
```

---

### 2.3 하드웨어 가속 선택 (선택적)

**패밀리 요구**:
- 나노초~마이크로초 레이턴시
- 결정론적 성능
- 경쟁 우위

---

#### 옵션 1: FPGA (Field-Programmable Gate Array)

**핵심 스펙**:
- **레이턴시**: 480ns~2.6μs (검증)
- **처리량**: 수백만 msg/s
- **전력**: 25~75W
- **개발**: Verilog, VHDL, HLS

**비용**:
- **FPGA 보드**: $5,000~$50,000
- **개발 비용**: $500,000~$2M (12~18개월)
- **코로케이션**: $10,000~$50,000/월

**장점**:
- ⚡ 최저 레이턴시 (나노초)
- 💪 병렬 처리
- 🔧 재프로그래밍 가능
- 🏆 경쟁 우위

**단점**:
- 💰 막대한 비용
- 🧑‍💻 희귀한 전문가 필요
- ⏱️ 긴 개발 주기
- 🔧 디버깅 어려움

**적합한 경우**:
- 최상위 HFT 펌
- 나노초 경쟁
- 예산 $5M+ /year
- 전담 FPGA 팀

**검증 사례**: Citadel (480ns), Jump Trading, HFT 펌

---

#### 옵션 2: Kernel Bypass (DPDK, Solarflare)

**핵심 스펙**:
- **레이턴시**: 수 마이크로초
- **처리량**: 초당 수백만 패킷
- **기술**: DPDK, Solarflare OpenOnload
- **언어**: C, C++

**비용**:
- **오픈소스**: 무료 (DPDK)
- **Solarflare NIC**: $1,000~$5,000
- **개발 비용**: $100,000~$500,000 (3~6개월)

**장점**:
- ⚡ 저지연 (마이크로초)
- 💰 FPGA 대비 저렴
- 🔧 소프트웨어 개발
- 📚 커뮤니티 지원

**단점**:
- 🧑‍💻 전문 지식 필요
- 🔧 하드웨어 의존성
- 📊 FPGA 대비 느림
- ⚠️ 유지보수 복잡

**적합한 경우**:
- 중상위 HFT 펌
- 마이크로초 목표
- 예산 $500K~$2M /year
- 소프트웨어 팀

**검증 사례**: 중형 HFT 펌, 자영업 트레이더

---

#### 옵션 3: RDMA (Remote Direct Memory Access)

**핵심 스펙**:
- **레이턴시**: 1~5 마이크로초
- **처리량**: 100 Gbps+
- **기술**: InfiniBand, RoCE
- **언어**: C, C++

**비용**:
- **RDMA NIC**: $500~$2,000
- **InfiniBand 스위치**: $10,000~$50,000
- **개발 비용**: $50,000~$200,000

**장점**:
- ⚡ 저지연 (마이크로초)
- 🚀 높은 대역폭 (100 Gbps)
- 💰 합리적 비용
- 📈 클러스터 확장

**단점**:
- 🔧 특수 네트워크 장비 필요
- 🧑‍💻 RDMA 전문 지식
- 📊 FPGA 대비 느림
- 🌐 데이터센터 제약

**적합한 경우**:
- 클러스터 간 통신
- 고대역폭 + 저지연
- 예산 $200K~$1M /year
- 온프레미스 데이터센터

**검증 사례**: 거래소 백엔드, 리스크 시스템

---

#### 하드웨어 가속 비교표

| 항목 | FPGA | Kernel Bypass | RDMA |
|------|------|---------------|------|
| **레이턴시** | 480ns~2.6μs | 수 μs | 1~5μs |
| **개발 비용** | $500K~$2M | $100K~$500K | $50K~$200K |
| **전문성** | 매우 희귀 | 희귀 | 중간 |
| **확장성** | 제한적 | 중간 | 높음 |
| **적합** | 나노초 경쟁 | 마이크로초 목표 | 클러스터 |

**의사결정 가이드**:
```
나노초 필수 + 예산 $5M+? → FPGA
  └─ NO
     ↓
마이크로초 + 단일 서버? → Kernel Bypass
  └─ NO
     ↓
클러스터 간 통신? → RDMA
  └─ NO → Kernel Bypass
```

---

## Part 2.5: 핵심 DNA 시스템 기술 선택 ⭐⭐⭐

이 패밀리에서 특별히 중요한 DNA 시스템(⭐⭐⭐)에 대한 기술 선택입니다.

### 2.5.1 Type System (DNA #4) - Zero-Cost Abstraction ⭐⭐⭐

**패밀리 요구**:
- GC 없는 결정론적 메모리 관리
- Zero-cost abstraction (런타임 오버헤드 0)
- 컴파일 타임 최적화 최대화
- 인라인 강제, 가상 함수 제거
- 캐시 지역성 최적화

---

#### 옵션 1: Rust

**핵심 스펙**:
- **메모리 관리**: Ownership + Borrow Checker (GC 없음)
- **최적화**: LLVM 백엔드, 인라인 강제
- **안전성**: 컴파일 타임 메모리 안전성
- **성능**: C/C++ 동등 (Zero-cost abstraction)

**비용**: 오픈소스 (무료)

**장점**:
- 🔧 메모리 안전성 + 성능 동시 달성
- 🔧 No GC pause (결정론적)
- 🔧 LLVM 최적화 (auto-vectorization)
- 🔧 현대적 타입 시스템 (ADT, 패턴 매칭)

**단점**:
- ⚠️ 학습 곡선 (Borrow Checker)
- ⚠️ 기존 C++ 라이브러리 FFI 필요
- ⚠️ 금융 업계 도입 초기 단계
- ⚠️ 일부 최적화 패턴 표현 어려움

**적합한 경우**:
- 신규 시스템 개발
- 메모리 안전성 + 성능 동시 필요
- 현대적 도구체인 선호
- 팀 Rust 학습 의지 있음

**검증 사례**: Cloudflare, Discord, AWS Firecracker

---

#### 옵션 2: C++ (Modern C++17/20)

**핵심 스펙**:
- **메모리 관리**: RAII, unique_ptr, 수동 최적화
- **최적화**: 템플릿 메타프로그래밍, constexpr
- **컴파일러**: GCC, Clang, MSVC (고도 최적화)
- **성능**: 최고 수준 (수십 년 최적화)

**비용**: 오픈소스 (무료)

**장점**:
- 🔧 금융 업계 표준 (수십 년)
- 🔧 방대한 라이브러리 생태계
- 🔧 템플릿 메타프로그래밍 (컴파일 타임 계산)
- 🔧 숙련된 개발자 풀

**단점**:
- ⚠️ 메모리 안전성 보장 없음
- ⚠️ 복잡한 언어 (UB, 암묵적 변환)
- ⚠️ 빌드 시간 (템플릿 과다 시)
- ⚠️ ABI 호환성 이슈

**적합한 경우**:
- 기존 C++ 코드베이스
- 팀 C++ 전문성
- 금융 업계 검증된 패턴 필요
- 레거시 라이브러리 활용

**검증 사례**: NASDAQ, CME, Goldman Sachs, Bloomberg

---

#### 옵션 3: C (ANSI C11)

**핵심 스펙**:
- **메모리 관리**: 완전 수동 (malloc/free)
- **최적화**: 어셈블리 수준 제어
- **오버헤드**: 최소 (런타임 거의 없음)
- **이식성**: 모든 플랫폼

**비용**: 오픈소스 (무료)

**장점**:
- 🔧 최소 오버헤드 (런타임 없음)
- 🔧 어셈블리 수준 제어
- 🔧 FPGA 드라이버 직접 작성
- 🔧 모든 플랫폼 지원

**단점**:
- ⚠️ 안전성 전무 (수동 관리)
- ⚠️ 추상화 부족 (보일러플레이트)
- ⚠️ 버그 발생 확률 높음
- ⚠️ 개발 속도 느림

**적합한 경우**:
- FPGA 드라이버 개발
- 어셈블리 수준 제어 필수
- 극한의 최소 오버헤드
- 임베디드 시스템

**검증 사례**: Linux 커널, DPDK, FPGA 드라이버

---

**Type System 의사결정 플로우차트**:
```
신규 시스템 + 메모리 안전성? → Rust
  └─ NO
     ↓
기존 C++ 코드베이스? → C++ Modern
  └─ NO
     ↓
FPGA 드라이버 또는 극한 제어? → C
```

---

### 2.5.2 Observability (DNA #8) - 마이크로초급 프로파일링 ⭐⭐⭐

**패밀리 요구**:
- 마이크로초~나노초 수준 추적
- 하드웨어 카운터 접근 (CPU cycles, cache miss)
- 핫스팟 식별 (함수별 레이턴시)
- 프로덕션 오버헤드 최소화 (<1%)
- 레이턴시 분포 분석 (p50, p99, p999)

---

#### 옵션 1: Intel VTune Profiler

**핵심 스펙**:
- **정밀도**: CPU 사이클 수준 (나노초)
- **하드웨어**: CPU 카운터, 캐시 분석, NUMA
- **분석**: 핫스팟, 마이크로아키텍처, 메모리
- **오버헤드**: 1-5% (샘플링 모드)

**비용**: 무료 (Intel 프로세서)

**장점**:
- 🔧 CPU 사이클 수준 정밀 분석
- 🔧 캐시 미스, 브랜치 예측 분석
- 🔧 GUI + CLI 모두 지원
- 🔧 무료 (Intel CPU)

**단점**:
- ⚠️ Intel CPU 전용
- ⚠️ 프로덕션 사용 어려움 (GUI 의존)
- ⚠️ 학습 곡선
- ⚠️ AMD 미지원

**적합한 경우**:
- Intel 서버 환경
- 개발/테스트 환경 분석
- CPU 마이크로아키텍처 최적화
- 캐시 최적화 필요

**검증 사례**: Intel 내부, 금융 거래소

---

#### 옵션 2: Linux perf + 커스텀 계측

**핵심 스펙**:
- **정밀도**: 마이크로초 (하드웨어 카운터)
- **하드웨어**: perf_events (Intel, AMD, ARM)
- **분석**: 샘플링, 트레이싱, 카운터
- **오버헤드**: <1% (샘플링)

**비용**: 오픈소스 (무료)

**장점**:
- 🔧 모든 CPU 아키텍처 지원
- 🔧 프로덕션 사용 가능
- 🔧 커널 레벨 통합
- 🔧 eBPF 확장 가능

**단점**:
- ⚠️ CLI 기반 (GUI 제한적)
- ⚠️ 분석 자동화 직접 구현
- ⚠️ 커스텀 계측 필요
- ⚠️ 학습 곡선

**적합한 경우**:
- 멀티 아키텍처 환경
- 프로덕션 모니터링
- eBPF 확장 계획
- 자동화 파이프라인

**검증 사례**: Netflix, Google, Meta

---

#### 옵션 3: 커스텀 인라인 계측

**핵심 스펙**:
- **정밀도**: RDTSC 기반 (나노초)
- **오버헤드**: ~20ns per measurement
- **분석**: 직접 구현 (히스토그램, 분포)
- **통합**: 코드 인라인

**비용**: 개발 비용만

**장점**:
- 🔧 나노초 수준 정밀도
- 🔧 최소 오버헤드 (~20ns)
- 🔧 완전한 제어
- 🔧 프로덕션 상시 실행

**단점**:
- ⚠️ 직접 구현 필요
- ⚠️ 유지보수 부담
- ⚠️ 분석 도구 직접 제작
- ⚠️ 코드 침습적

**적합한 경우**:
- 나노초급 측정 필수
- HFT 전문 팀
- 프로덕션 상시 모니터링
- 외부 도구 오버헤드 불가

**검증 사례**: HFT 전문 회사, Jump Trading

---

**Observability 의사결정 플로우차트**:
```
개발 환경 + Intel CPU? → VTune
  └─ NO
     ↓
프로덕션 + 멀티 아키텍처? → perf + eBPF
  └─ NO
     ↓
나노초급 + 상시 모니터링? → 커스텀 RDTSC
```

---

### 2.5.3 Performance (DNA #11) - 레이턴시 벤치마크 ⭐⭐⭐

**패밀리 요구**:
- 나노초~마이크로초 정밀 측정
- 레이턴시 회귀 감지 (CI/CD 통합)
- 통계적 유의성 검증
- JIT 워밍업 제거
- 결정론적 벤치마크

---

#### 옵션 1: Criterion.rs (Rust)

**핵심 스펙**:
- **정밀도**: 나노초 (RDTSC 기반)
- **통계**: 부트스트랩, 신뢰구간, 회귀 감지
- **리포트**: HTML, 그래프, 비교
- **CI 통합**: GitHub Actions, GitLab CI

**비용**: 오픈소스 (무료)

**장점**:
- 🔧 통계적 회귀 감지 자동
- 🔧 HTML 리포트 (시각화)
- 🔧 CI/CD 쉬운 통합
- 🔧 워밍업 자동 처리

**단점**:
- ⚠️ Rust 전용
- ⚠️ C++ 코드 FFI 필요
- ⚠️ 일부 고급 설정 제한
- ⚠️ 대규모 벤치마크 시 느림

**적합한 경우**:
- Rust 프로젝트
- 자동 회귀 감지 필요
- CI/CD 통합 우선
- 통계적 신뢰성 필요

**검증 사례**: Rust 생태계 표준

---

#### 옵션 2: Google Benchmark (C++)

**핵심 스펙**:
- **정밀도**: 나노초 (RDTSC, 클록)
- **통계**: 평균, 표준편차, 복잡도 분석
- **리포트**: JSON, CSV, 콘솔
- **CI 통합**: CMake, Bazel

**비용**: 오픈소스 (무료)

**장점**:
- 🔧 C++ 업계 표준
- 🔧 Google 검증
- 🔧 복잡도 분석 (Big-O)
- 🔧 템플릿 기반 확장

**단점**:
- ⚠️ 통계적 회귀 감지 수동
- ⚠️ 리포트 도구 별도 필요
- ⚠️ 워밍업 수동 처리
- ⚠️ CI 통합 직접 구현

**적합한 경우**:
- C++ 프로젝트
- 복잡도 분석 필요
- Google 도구체인 사용
- 템플릿 확장 계획

**검증 사례**: Google, Bloomberg, Chromium

---

#### 옵션 3: 커스텀 RDTSC 벤치마크

**핵심 스펙**:
- **정밀도**: CPU 사이클 (1ns 미만)
- **오버헤드**: 최소 (~10ns)
- **제어**: 완전한 제어
- **통합**: 직접 구현

**비용**: 개발 비용만

**장점**:
- 🔧 최고 정밀도 (CPU 사이클)
- 🔧 최소 오버헤드
- 🔧 완전한 제어
- 🔧 프로덕션 통합 가능

**단점**:
- ⚠️ 직접 구현 필요
- ⚠️ 통계 분석 직접 구현
- ⚠️ 유지보수 부담
- ⚠️ CPU 아키텍처 의존

**적합한 경우**:
- 나노초 미만 정밀도
- HFT 전문 팀
- 외부 도구 오버헤드 불가
- 프로덕션 측정 필수

**검증 사례**: HFT 전문 회사

---

**Performance 의사결정 플로우차트**:
```
Rust 프로젝트 + 자동 회귀 감지? → Criterion.rs
  └─ NO
     ↓
C++ 프로젝트 + 복잡도 분석? → Google Benchmark
  └─ NO
     ↓
나노초 미만 + 완전 제어? → 커스텀 RDTSC
```

---

## Part 3: 도메인 선택 요소 (프로젝트별)

이 요소들은 **패밀리와 무관**하게 프로젝트 요구사항에 따라 선택합니다.

### 3.1 프론트엔드 프레임워크

**선택지**:
- React, Angular (관리 도구, 대시보드)
- 모바일: React Native, Flutter (트레이더 앱)

**선택 기준**:
- HFT는 프론트엔드 최소화 (관리 도구만)
- 트레이딩 플랫폼은 실시간 차트 필수

**A-A-A 영향**: 최소 (백오피스만)

---

### 3.2 백엔드 언어/프레임워크

**선택지**:
- **C++**: 최고 성능, 마이크로초 제어 (HFT 표준)
- **Java**: VoltDB/Chronicle 통합, GC 튜닝 필수
- **Rust**: 메모리 안전 + 성능 (신규 프로젝트)
- Go: 동시성, 네트워크 (주변 시스템)

**선택 기준**:
- 핫 패스 (Hot Path): C++ 또는 Rust 필수
- 백오피스: Java, Go 허용
- 팀 역량 vs 성능 요구 트레이드오프

**A-A-A 영향**: **매우 큼** - 언어 선택이 레이턴시 결정  
(C++: 나노초~마이크로초, Java: 수 마이크로초, Python: 불가능)

---

### 3.3 인증/권한

**선택지**:
- OAuth2 + JWT (표준)
- LDAP/Active Directory (엔터프라이즈)
- Custom (초고보안)

**선택 기준**:
- 거래 API: 강력한 인증 (X.509, API Key)
- 관리 도구: 표준 인증 (OAuth2)
- 감사 추적 (Audit Trail) 필수

**A-A-A 영향**: 중간 (API 보안 중요)

---

### 3.4 모니터링/로깅

**선택지**:
- **Prometheus + Grafana**: 표준 메트릭
- **커스텀 시스템**: 마이크로초 단위 추적, 오버헤드 최소화
- ELK Stack: 로그 집계 (백오피스)

**선택 기준**:
- 핫 패스: 비동기 로깅, 샘플링 필수 (오버헤드 <1%)
- 백오피스: 표준 도구 허용
- 감사 추적: 규제 준수 (MiFID II, Reg NMS)

**A-A-A 영향**: **큼** - 모니터링 오버헤드가 레이턴시 영향  
(1% 오버헤드 = 수백 나노초 추가)

---

## Part 4: Stage 2 통합

### 4.1 Layer 3 제약 반영 예시

**시나리오**: 소규모 HFT 스타트업

**Layer 3 제약 발견**:
- 거래소 API: 코로케이션 필수 ($50K/월)
- 규제: MiFID II, Reg NMS 준수
- 예산: $500K/년 (전체)
- 팀: 3명 (Java 경험, FPGA 없음)

**기술 선택 영향**:
```
인메모리 DB:
- VoltDB (선호) → Redis Enterprise
- 이유: 예산 제약 ($20K/월 vs $5K/월)

저지연 메시징:
- FPGA (불가능) → Aeron
- 이유: 팀 역량, 예산

하드웨어 가속:
- FPGA (불가능) → Kernel Bypass (DPDK)
- 이유: Java 팀이지만 C++ 학습 가능, 예산

코로케이션:
- 필수: $50K/월 (거래소 인접)
- 이유: 마이크로초 필수
```

---

### 4.2 충돌 해결 예시

**NFR 목표 vs Layer 3 제약**:

**충돌 1**: 레이턴시 A (나노초) + 예산 제약
- **NFR**: 나노초 레이턴시
- **제약**: 예산 $500K/년 (FPGA 불가능)
- **해결**: FPGA 포기 → Kernel Bypass (DPDK)
- **트레이드오프**: 
  - ⚠️ 레이턴시 480ns → 수 μs (10~20배 느림)
  - ⚠️ 경쟁 열위 (최상위 HFT 대비)
  - ✅ 개발 비용 $2M → $500K (75% 절감)
  - ✅ 개발 기간 18개월 → 6개월

---

**충돌 2**: ACID A + 코로케이션 비용
- **NFR**: 완전한 ACID 트랜잭션
- **제약**: 코로케이션 $50K/월 (VoltDB 비용 부담)
- **해결**: VoltDB → Redis Enterprise (ACID 모듈)
- **트레이드오프**:
  - ⚠️ 완전한 ACID → 제한적 ACID (단일 키)
  - ⚠️ SQL 지원 상실 (쿼리 복잡도 증가)
  - ✅ 비용 $20K/월 → $5K/월 (75% 절감)
  - ✅ 레이턴시 <10ms → 150μs (66% 개선)

---

**충돌 3**: 팀 역량 + FPGA
- **NFR**: 나노초 레이턴시 (FPGA 필요)
- **제약**: Java 팀, FPGA 전문가 없음
- **해결**: 옵션 A: 외주 FPGA 개발 / 옵션 B: Kernel Bypass 내재화
- **트레이드오프 (옵션 A - 외주)**:
  - ✅ 나노초 레이턴시 달성 (480ns)
  - ⚠️ 비용 $1M~$2M (외주 개발)
  - ⚠️ 의존성 (외주사에 종속)
  - ⚠️ 유지보수 어려움
- **트레이드오프 (옵션 B - 내재화)**:
  - ⚠️ 레이턴시 수 μs (FPGA 대비 느림)
  - ✅ 비용 $100K~$500K (내부 개발)
  - ✅ 팀 역량 축적 (C++ 전문성)
  - ✅ 장기 유지보수 가능

**선택**: 옵션 B (Kernel Bypass 내재화)  
**이유**: 예산 제약 + 팀 역량 축적 우선

---

### 4.3 ADR 작성 준비

**선택한 기술 스택 정리**:
```
Bootstrap 필수:
✅ 인메모리 DB: Redis Enterprise (ACID 모듈)
✅ 저지연 메시징: Aeron
✅ 하드웨어 가속: Kernel Bypass (DPDK)

도메인 선택:
✅ 백엔드: Java (Spring Boot) + C++ (핫패스)
✅ 프론트엔드: React (관리 도구)
✅ 모니터링: 자체 구현 (오버헤드 최소화)
```

**ADR 작성 대상**:
1. 인메모리 DB 선택 (VoltDB vs Redis Enterprise)
2. 저지연 메시징 선택 (Aeron vs Chronicle)
3. 하드웨어 가속 전략 (DPDK vs FPGA)
4. 코로케이션 전략 (거래소 인접 배치)
5. 규제 준수 방안 (MiFID II, Reg NMS)

---

## 📚 참고 자료

### 거래소 레이턴시 벤치마크
- [NASDAQ X-Stream: 37μs](https://www.nasdaq.com/solutions/x-stream-global-trade-engine)
- [SIX Swiss Exchange: 14μs](https://www.six-group.com/)
- [CME Globex](https://www.cmegroup.com/trading/globex.html)

### FPGA 검증 사례
- IEEE: HFT FPGA 480ns~2.6μs (학술 논문)
- Citadel, Jump Trading (공개 정보 제한적)

### 인메모리 DB 벤치마크
- [VoltDB Performance](https://www.voltdb.com/company/performance/)
- [Redis Benchmark](https://redis.io/docs/latest/operate/oss_and_stack/management/optimization/benchmarks/)

### 저지연 메시징
- [Aeron](https://github.com/real-logic/aeron)
- [Chronicle Queue](https://chronicle.software/chronicle-queue/)

### 하드웨어 가속
- [DPDK](https://www.dpdk.org/)
- [Solarflare](https://www.xilinx.com/products/boards-and-kits/alveo.html)
- [RDMA](https://en.wikipedia.org/wiki/Remote_direct_memory_access)

### 규제 문서
- [MiFID II](https://www.esma.europa.eu/policy-rules/mifid-ii-and-mifir)
- [Reg NMS](https://www.sec.gov/rules/final/34-51808.pdf)

---

**마지막 업데이트**: 2025-11-12  
**다음 검토**: 2026-02-12 (기술 스택 업데이트 반영)


================================================================================

📄 FILE: 02_transaction_crud_tech_options.md
--------------------------------------------------------------------------------

# 트랜잭션/CRUD 패밀리 (A-A-B) - 기술 매트릭스

**작성일**: 2024-11-12  
**패밀리**: 트랜잭션/CRUD (A-A-B)  
**검증 사례**: Amazon 주문 시스템, Booking.com 예약, Stripe 결제, SAP ERP

---

## Part 1: 패밀리가 요구하는 시스템 구조 ⭐⭐⭐

### 1.1 A-A-B 특성이 강제하는 것

#### A (치명적 실패) → ACID 트랜잭션 필수

**특성**:
- 부분 성공 불가 (All-or-Nothing)
- 실패 = 재정 손실, 재고 불일치, 규제 위반
- 완전 롤백 메커니즘 필수
- 감사 추적 (Audit Trail) 의무

**강제되는 기술적 요구**:
```
✅ ACID 트랜잭션 DB 필수
✅ 격리 수준 제어 (Isolation Level)
✅ 분산 트랜잭션 조율 (2PC, Saga)
✅ 롤백 & 복구 메커니즘
✅ 데이터 무결성 제약
```

**검증 사례**:
- Amazon: 주문-재고-결제 트랜잭션, 실패 시 전체 롤백, 연간 수십억 건 처리
- Stripe: 결제 100% 정확성, PCI DSS 준수, 이중 청구 방지
- Booking.com: 객실 예약 트랜잭션, 초과 예약 방지

---

#### A (구조화 데이터) → 관계형 스키마 필수

**특성**:
- 명확한 엔티티 관계 (Order ↔ Customer ↔ Product)
- 참조 무결성 (Foreign Key Constraints)
- 복잡한 JOIN 쿼리 빈번
- 정규화된 스키마 설계

**강제되는 기술적 요구**:
```
✅ 관계형 데이터베이스 (RDBMS)
✅ 외래 키 제약 조건
✅ 스키마 마이그레이션 도구
✅ 인덱싱 전략
✅ 쿼리 최적화
```

**검증 사례**:
- Booking.com: 객실-호텔-예약-고객 복잡한 관계, 수백 개 테이블 JOIN
- SAP ERP: 수천 개 테이블 간 참조 무결성, 30년+ 스키마 진화

---

#### B (수초 응답) → 읽기 최적화 전략 필수

**특성**:
- 200ms~3초 응답 목표 (사용자 경험)
- 읽기 : 쓰기 = 90:10 (읽기 중심)
- 밀리초급 불필요 (A-A-A와 차이)
- 3초+ 지연 시 57% 사용자 이탈

**강제되는 기술적 요구**:
```
✅ 캐시 레이어 (Redis, Memcached)
✅ 읽기 복제본 (Read Replicas)
✅ 인덱스 전략 (B-tree, Hash)
✅ 쿼리 최적화 & 모니터링
✅ Connection Pooling
```

**검증 사례**:
- Amazon: 100ms 지연 = 매출 1% 손실 ($1.6B/년 추정)
- 산업 평균: 47% 사용자가 2초 내 로딩 기대, 3초+ 시 이탈

---

### 1.2 이 패밀리에 필요한 DNA 시스템 및 메인 서비스

#### DNA 11개 시스템 중 필요한 것

A-A-B 패밀리는 다음 DNA 시스템이 필요합니다:

| DNA 시스템 | 중요도 | 이유 |
|-----------|-------|------|
| 1. Testing | ✅ 필수 | 트랜잭션 로직 검증 |
| 2. Code Quality | ✅ 필수 | 비즈니스 로직 품질 |
| 3. Architecture | ✅ 필수 | 도메인 모듈 분리 |
| 4. Type System | ✅ 필수 | 엔티티 타입 안전성 |
| 5. **Error Handling** | **⭐⭐⭐ 매우 중요** | **트랜잭션 롤백, 보상 트랜잭션** |
| 6. Configuration | ✅ 필수 | DB 연결, 트랜잭션 타임아웃 |
| 7. **Identity & Access** | **⭐⭐⭐ 매우 중요** | **사용자 인증, RBAC, 감사 로그** |
| 8. Observability | ✅ 필수 | 쿼리 성능, 트랜잭션 추적 |
| 9. **API Gateway** | **⭐⭐⭐ 매우 중요** | **Rate Limiting, 인증, 버전 관리** |
| 10. **Resilience** | **⭐⭐⭐ 매우 중요** | **Circuit Breaker, 재시도, 타임아웃** |
| 11. Performance | ✅ 필수 | 쿼리 최적화, 인덱싱 |

**특별히 중요한 DNA 시스템 (⭐⭐⭐)**:
- **Identity & Access**: 사용자 인증 실패 = 보안 침해, RBAC 없으면 권한 관리 불가
- **API Gateway**: Rate limiting 없으면 DDoS 공격, 버전 관리 없으면 배포 중단
- **Error Handling**: 트랜잭션 롤백 실패 = 데이터 불일치, 보상 트랜잭션 필수
- **Resilience**: 외부 API 장애 시 전체 시스템 다운 방지

→ **Part 2.5에서 이 4가지 중 3가지 DNA 시스템의 기술 옵션을 다룹니다.**

#### 메인 서비스 필수 요소 (패밀리 강제)

A-A-B 패밀리는 다음 3가지 메인 서비스 기술을 **반드시** 포함해야 합니다:

#### 1. 관계형 데이터베이스 (필수!)
**역할**: ACID 트랜잭션, 참조 무결성, 복잡한 쿼리
**이유**: 치명적 실패(A) + 구조화 데이터(A)
**선택지**: PostgreSQL, MySQL, CockroachDB

#### 2. 캐시 레이어 (필수!)
**역할**: 읽기 성능 최적화 (<200ms)
**이유**: 수초 응답(B) + 높은 읽기 비율 (90%+)
**선택지**: Redis, Memcached

#### 3. 메시징 시스템 (강력 권장)
**역할**: 비동기 작업, 서비스 분리, 확장성
**이유**: 마이크로서비스 아키텍처, 이벤트 기반 통신
**선택지**: RabbitMQ, Kafka, AWS SQS

---

## Part 2: 메인 서비스 기술 선택 ⭐⭐⭐

### 2.1 관계형 데이터베이스 선택

**패밀리 요구**:
- ACID 트랜잭션 보장
- Serializable 격리 수준 지원
- 참조 무결성 제약
- 복잡한 JOIN 쿼리 성능
- 읽기/쓰기 확장성

---

#### 옵션 1: PostgreSQL

**핵심 스펙**:
- **읽기**: 50,000~100,000 QPS (최적화 시)
- **쓰기**: 15,000~30,000 TPS (SSD 기준)
- **트랜잭션 격리**: Serializable 완벽 지원
- **동시 연결**: 100~500 (PgBouncer로 10,000+)
- **데이터 크기**: 수백 TB (단일 인스턴스)

**비용**:
- **Self-hosted**: $0 (오픈소스)
- **AWS RDS**: $0.115/hour (db.t3.medium), 월 ~$84
- **Managed (Supabase)**: $25/월 (Hobby), $599/월 (Pro)
- **Enterprise**: $500~$5,000/월 (규모별)

**장점**:
- ⚡ 고급 ACID 지원: Serializable 격리 수준 완벽 구현
- 🔧 JSON/JSONB: 하이브리드 데이터 유연성
- 📈 성숙한 확장: 읽기 복제본, 파티셔닝, 샤딩
- 🌐 20년+ 검증: 엔터프라이즈급 안정성
- 🛠️ 풍부한 생태계: 마이그레이션, 모니터링 도구

**단점**:
- 🔧 복잡한 튜닝: 수백 개 설정 파라미터
- 📚 학습 곡선: 고급 기능 숙달 시간 필요
- 💰 고급 기능 비용: Replication, Clustering

**적합한 경우**:
- 복잡한 비즈니스 로직 (수십~수백 개 테이블)
- JSON과 관계형 혼합 데이터
- 장기 프로젝트 (10년+ 지원)
- 엔터프라이즈급 안정성 필요
- Serializable 트랜잭션 필수

**검증 사례**: Instagram (수십억 행), Discord (초당 120만 메시지), Stripe, Apple

---

#### 옵션 2: MySQL

**핵심 스펙**:
- **읽기**: 60,000~120,000 QPS (MyISAM, 단순 쿼리)
- **쓰기**: 10,000~20,000 TPS (InnoDB)
- **트랜잭션 격리**: Read Committed (기본), Serializable (제한)
- **동시 연결**: 100~300
- **데이터 크기**: 수십 TB (권장)

**비용**:
- **Self-hosted**: $0 (오픈소스)
- **AWS RDS**: $0.102/hour (db.t3.medium), 월 ~$74
- **Managed (PlanetScale)**: $15/월 (Scaler), $39/월 (Scaler Pro)
- **Enterprise**: $300~$3,000/월

**장점**:
- 📚 성숙도: LAMP 스택, 30년 역사
- 🔧 단순 설정: PostgreSQL 대비 쉬운 초기 설정
- 💰 저렴한 호스팅: 공유 호스팅 옵션 다수
- ⚡ 읽기 최적화: 단순 쿼리 고속 처리
- 🌐 광범위 채택: WordPress, Drupal 기본

**단점**:
- 🔒 제한적 트랜잭션: Serializable 성능 이슈
- 📊 약한 JSON 지원: PostgreSQL JSONB 대비 부족
- 🔧 고급 인덱스 부족: 부분 인덱스, 함수 인덱스 제한

**적합한 경우**:
- 읽기 중심 워크로드 (90%+ SELECT)
- 단순한 스키마 (수십 개 테이블)
- 예산 제약 (<$100/월)
- 팀이 MySQL 경험 풍부
- Read Committed 충분

**검증 사례**: Facebook (초기), WordPress (3천만 사이트), Shopify, GitHub (초기)

---

#### 옵션 3: CockroachDB

**핵심 스펙**:
- **읽기**: 30,000~50,000 QPS (단일 리전)
- **쓰기**: 10,000~15,000 TPS (다중 리전 시 감소)
- **트랜잭션 격리**: Serializable (분산 환경)
- **레이턴시**: +10~50ms (리전 간 증가)
- **데이터 크기**: PB급 (자동 샤딩)

**비용**:
- **Serverless**: $1 per 1M Request Units, 월 ~$50 (소규모)
- **Dedicated**: $0.50/vCPU/hour, 월 ~$360 (3노드 최소)
- **Enterprise**: $1,000~$10,000/월 (규모별)

**장점**:
- 🌐 전역 분산 ACID: 다중 리전 Serializable 트랜잭션
- 📈 자동 샤딩: 무한 수평 확장
- 🔄 PostgreSQL 호환: 기존 쿼리 재사용
- ☁️ 클라우드 네이티브: Kubernetes 친화적
- 🛡️ 내장 복제: 자동 failover

**단점**:
- 💰 높은 비용: PostgreSQL 대비 3~5배
- ⏱️ 레이턴시 증가: 분산 합의 오버헤드
- 🔧 운영 복잡도: 분산 시스템 전문 지식
- 📊 제한적 생태계: PostgreSQL 대비 도구 부족

**적합한 경우**:
- 글로벌 분산 필수 (다중 리전)
- 무한 확장 필요 (PB급 데이터)
- 지역 간 트랜잭션 빈번
- 예산 여유 ($500+/월)
- 클라우드 네이티브 환경

**검증 사례**: Bose, Lush Cosmetics, SpaceX Starlink, Hard Rock Digital

---

#### 데이터베이스 비교표

| 항목 | PostgreSQL | MySQL | CockroachDB |
|------|-----------|-------|-------------|
| **읽기 QPS** | 50K~100K | 60K~120K | 30K~50K |
| **쓰기 TPS** | 15K~30K | 10K~20K | 10K~15K |
| **격리 수준** | ⭐⭐⭐ Serializable | ⭐⭐ Read Committed | ⭐⭐⭐ Serializable (분산) |
| **비용 (중규모)** | $100~$300/월 | $80~$250/월 | $360~$1K/월 |
| **JSON 지원** | ⭐⭐⭐ 우수 | ⭐⭐ 보통 | ⭐⭐⭐ 우수 |
| **다중 리전** | 복제본 | 복제본 | ⭐⭐⭐ 네이티브 |
| **확장성** | 읽기 복제본 | 읽기 복제본 | 수평 자동 |
| **생태계** | ⭐⭐⭐ 풍부 | ⭐⭐⭐ 풍부 | ⭐⭐ 성장 중 |

**의사결정 가이드**:
```
글로벌 다중 리전 필수? → CockroachDB
  └─ NO
     ↓
Serializable 트랜잭션 필수?
  ├─ YES → PostgreSQL
  └─ NO
     ↓
예산 < $100/월?
  ├─ YES
  │  ├─ 복잡한 쿼리? → PostgreSQL (Managed)
  │  └─ 읽기 중심? → MySQL
  │
  └─ NO → PostgreSQL (장기 투자)
```

---

### 2.2 캐시 레이어 선택

**패밀리 요구**:
- 읽기 레이턴시 <10ms
- 높은 처리량 (100K+ ops/sec)
- TTL 관리
- 세션 저장 지원

---

#### 옵션 1: Redis

**핵심 스펙**:
- **레이턴시**: 0.15ms (GET, p99)
- **처리량**: 100,000~200,000 ops/sec (단일 인스턴스)
- **자료구조**: String, Hash, List, Set, Sorted Set, Stream, HyperLogLog
- **영속성**: RDB 스냅샷, AOF (Append-Only File)
- **메모리**: 1GB~수백 GB

**비용**:
- **Self-hosted**: $0 (오픈소스)
- **AWS ElastiCache**: $0.034/hour (cache.t3.micro), 월 ~$25
- **Redis Cloud**: $7/월 (250MB), $200/월 (10GB)
- **Enterprise**: $500~$5,000/월 (HA, 다중 리전)

**장점**:
- ⚡ 초고속: 0.15ms 평균 레이턴시
- 🔧 다양한 자료구조: 복잡한 캐싱 패턴 지원
- 📡 Pub/Sub: 실시간 알림 가능
- 💾 영속성: 재시작 후 데이터 복구
- 🌐 풍부한 클라이언트: 모든 주요 언어 지원

**단점**:
- 💰 메모리 기반: 디스크 대비 비쌈 (GB당)
- 🔧 단일 스레드: CPU 코어 1개만 활용
- 🛠️ 운영 복잡도: 클러스터링, 샤딩 수동 관리

**적합한 경우**:
- 세션 관리 필수
- API 응답 캐싱
- Rate Limiting
- Leaderboards, Counters
- Pub/Sub 필요
- 복잡한 자료구조 활용

**검증 사례**: Twitter (120만 TPS), GitHub, Stack Overflow, Pinterest

---

#### 옵션 2: Memcached

**핵심 스펙**:
- **레이턴시**: <0.1ms (마이크로초급)
- **처리량**: 120,000+ ops/sec
- **자료구조**: Key-Value만
- **영속성**: 없음 (휘발성)
- **메모리**: 1GB~수백 GB

**비용**:
- **Self-hosted**: $0 (오픈소스)
- **AWS ElastiCache**: $0.017/hour (cache.t3.micro), 월 ~$12
- **월 예상**: $30~$500

**장점**:
- 💰 Redis 대비 50% 저렴
- ⚡ 극도로 빠름: 마이크로초 레이턴시
- 🔧 멀티스레드: CPU 코어 활용 우수
- 🛠️ 단순함: 설정 & 운영 간단

**단점**:
- 📊 단순 자료구조: Key-Value만 지원
- 💾 영속성 없음: 재시작 시 데이터 손실
- 📡 Pub/Sub 없음: 이벤트 알림 불가
- 🔒 제한적 고급 기능: 트랜잭션, Lua 스크립트 없음

**적합한 경우**:
- 단순 Key-Value 캐싱만
- 예산 최소화 (<$50/월)
- 높은 동시성 필요 (멀티스레드)
- 영속성 불필요
- Facebook, Twitter 초기 규모

**검증 사례**: Facebook (역사적), Wikipedia, YouTube (콘텐츠 캐싱)

---

#### 캐시 비교표

| 항목 | Redis | Memcached |
|------|-------|-----------|
| **레이턴시** | 0.15ms | <0.1ms |
| **자료구조** | ⭐⭐⭐ 다양 | Key-Value만 |
| **영속성** | ⭐⭐ 옵션 있음 | ❌ 없음 |
| **비용** | 중간 | ⭐⭐⭐ 낮음 (50% 저렴) |
| **Pub/Sub** | ✅ | ❌ |
| **멀티스레드** | ❌ (단일) | ⭐⭐⭐ 우수 |
| **운영 복잡도** | 중간 | ⭐⭐⭐ 낮음 |

**의사결정 가이드**:
```
세션 관리 필요? → Redis
  └─ NO
     ↓
Pub/Sub 필요? → Redis
  └─ NO
     ↓
복잡한 자료구조? → Redis
  └─ NO
     ↓
예산 < $30/월? → Memcached
  └─ NO → Redis (범용)
```

---

### 2.3 메시징 시스템 선택

**패밀리 요구**:
- 비동기 작업 처리
- 서비스 간 분리
- At-Least-Once 전달 보장
- Task Queue 기능

---

#### 옵션 1: RabbitMQ

**핵심 스펙**:
- **처리량**: 10,000~50,000 msg/sec (단일 노드)
- **레이턴시**: 1~10ms (p99)
- **메시지 크기**: <128KB 권장, 512MB 최대
- **보장**: At-Least-Once, Persistent Queue
- **프로토콜**: AMQP 0-9-1

**비용**:
- **Self-hosted**: $0 (오픈소스)
- **CloudAMQP**: $13/월 (Tiger, 1M msg/월), $40/월 (Panda)
- **AWS AmazonMQ**: $0.50/hour (~$360/월, 3노드)
- **Enterprise**: $500~$3,000/월

**장점**:
- 📚 성숙도: 15년+ 검증, 엔터프라이즈급
- 🔧 유연한 라우팅: Exchange (Direct, Topic, Fanout, Headers)
- 💾 메시지 영속성: 디스크 저장 지원
- 🛠️ 관리 UI: 웹 기반 모니터링 & 관리
- 🌐 다양한 클라이언트: 모든 주요 언어

**단점**:
- 📉 제한적 확장: 클러스터링 복잡
- ⏱️ 부하 시 레이턴시: 큐 깊이 증가 시 성능 저하
- 🔧 운영 복잡도: 클러스터, Federation 수동 관리

**적합한 경우**:
- 전통적 메시징 패턴 (Queue, Pub/Sub)
- 복잡한 라우팅 규칙
- 메시지 영속성 필수
- 중소 규모 (초당 5만 미만)
- 예산 $50~$500/월

**검증 사례**: T-Mobile, Heroku, BBC, Reddit, Trivago

---

#### 옵션 2: Apache Kafka

**핵심 스펙**:
- **처리량**: 200K~2M msg/sec (클러스터)
- **레이턴시**: p99.9 <10ms
- **메시지 크기**: 1MB 기본, 10MB+ 설정 가능
- **보장**: At-Least-Once 기본, Exactly-Once 선택
- **보관**: 일~월 단위 (설정 가능)

**비용**:
- **Self-hosted**: $2,000~$10,000+/월 (3노드)
- **AWS MSK**: $0.21~$0.84/hour per vCPU, $3,000~$10,000/월
- **Confluent Cloud**: $5,000~$20,000/월 (eCKU 기반)

**장점**:
- ⚡ 초고속: 수백만 msg/sec
- 📈 무제한 확장: 파티션 추가로 선형 확장
- 💾 장기 보관: 이벤트 재생 가능
- 🔧 이벤트 소싱: 불변 로그 기반 아키텍처
- 🌐 풍부한 생태계: Kafka Connect, Kafka Streams

**단점**:
- 💰 높은 비용: RabbitMQ 대비 10배+
- 🧑‍💻 전문 인력: Kafka 전문가 필수
- ⏱️ 배포 시간: 1~4주 (self-hosted)
- 🔧 운영 복잡도: ZooKeeper, Replication 관리

**적합한 경우**:
- 초대규모 (초당 10만+ 메시지)
- 이벤트 소싱 아키텍처
- 장기 이벤트 재생 필요
- 대기업, 미션 크리티컬
- 예산 $5K+/월

**검증 사례**: LinkedIn, Netflix, Uber, Airbnb, Spotify

---

#### 옵션 3: AWS SQS

**핵심 스펙**:
- **처리량**: 3,000 msg/sec (Standard), 300 msg/sec (FIFO)
- **레이턴시**: 수십 ms
- **메시지 크기**: 256KB 최대
- **보장**: At-Least-Once (Standard), Exactly-Once (FIFO)
- **보관**: 최대 14일

**비용**:
- **Standard**: $0.40 per 1M requests
- **FIFO**: $0.50 per 1M requests
- **월 예상** (100만 msg): $40~$500

**장점**:
- 🤖 완전 관리형: 운영 부담 제로
- 💵 사용량 기반 과금: 예측 가능
- 🔗 AWS 통합: Lambda, EC2, ECS 쉬운 연동
- 📈 자동 확장: 무제한 처리량 (Standard)
- 🛡️ 높은 가용성: 99.9% SLA

**단점**:
- 🔒 AWS 종속: 멀티 클라우드 불가
- ⏱️ 제한적 처리량: FIFO 300 msg/sec
- 📊 단순 기능: Exchange, Routing 없음
- 💰 대규모 비용: 수억 메시지 시 급증

**적합한 경우**:
- AWS 중심 인프라
- 운영 간소화 최우선
- 중소 규모 (초당 3천 미만)
- 빠른 MVP 출시
- 예산 유연성

**검증 사례**: NASA JPL, Capital One, Change.org, BMW

---

#### 메시징 시스템 비교표

| 항목 | RabbitMQ | Kafka | AWS SQS |
|------|----------|-------|---------|
| **처리량** | 10K~50K/s | 200K~2M/s | 3K/s (Standard) |
| **레이턴시** | 1~10ms | <10ms | 수십 ms |
| **비용 (중규모)** | $50~$500/월 | $3K~$10K/월 | $40~$500/월 |
| **배포** | 1~3일 | 1~4주 | 즉시 |
| **운영** | ⚙️⚙️ 중간 | ⚙️⚙️⚙️ 높음 | ⚙️ 낮음 (관리형) |
| **메시지 보관** | 단기 | 일~월 | 최대 14일 |
| **확장성** | 제한적 | 무제한 | 자동 |
| **라우팅** | ⭐⭐⭐ 풍부 | Topic 기반 | 단순 |

**의사결정 가이드**:
```
처리량 > 10만/s? → Kafka
  └─ NO
     ↓
AWS 전용 OK? → SQS
  └─ NO → RabbitMQ
     ↓
운영 간소화 최우선? → SQS
  └─ NO
     ↓
복잡한 라우팅? → RabbitMQ
  └─ NO → SQS
```

---

## Part 2.5: 중요 DNA 시스템 기술 선택 🆕

이 섹션에서는 A-A-B 패밀리에서 **⭐⭐⭐ 매우 중요한 DNA 시스템 3가지**의 기술 옵션을 다룹니다.

### 2.5.1 Identity & Access (DNA #7) - 사용자 인증 및 권한 관리 ⭐⭐⭐

**패밀리 요구**:
- 사용자 인증 (OAuth2, OpenID Connect, SAML)
- RBAC (Role-Based Access Control) - 세밀한 권한 관리
- MFA (Multi-Factor Authentication) - 보안 강화
- 감사 로그 (Audit Trail) - 규제 준수
- 세션 관리 - 수초 응답 시간 유지

---

#### 옵션 1: Auth0

**핵심 스펙**:
- **처리량**: 100억+ 인증/월 (전역 처리)
- **레이턴시**: <50ms (글로벌 CDN)
- **가용성**: 99.99% SLA (Enterprise)
- **비용**: Free (25K MAU), Essentials $32/월 (500 MAU), Professional $220/월 (1K MAU), Enterprise $2,500/월

**장점**:
- 완전 관리형 (Managed SaaS), 운영 부담 제로
- 25K MAU까지 무료 (소규모 프로젝트 이상적)
- Universal Login, Passwordless, Social Login 즉시 사용
- 즉시 배포 가능 (5분 설정)
- 풍부한 SDK (React, Vue, Node.js, Python, Java 등)
- MFA, Bot Detection, Brute-Force Protection 내장
- 규제 준수 (GDPR, SOC2, ISO27001)

**단점**:
- MAU 제한으로 대규모 시 비용 급증 (10K MAU = $1,250~$1,595/월)
- 벤더 락인 (Okta 인수 후 가격 변동 우려)
- Enterprise 기능 (로그 내보내기, 고급 보안) 고가
- 커스터마이징 제한 (Rules/Actions로 일부 해결)

**적합한 경우**:
- 빠른 프로덕션 배포 (1주 이내)
- 운영 인력 부족 (DevOps 최소화)
- B2C 애플리케이션 (소셜 로그인 필수)
- 스타트업 (25K MAU 무료 활용)
- 규제 준수 필수 (HIPAA, PCI DSS)

**검증 사례**: Atlassian, Mozilla, Mazda, Schneider Electric

---

#### 옵션 2: AWS Cognito

**핵심 스펙**:
- **처리량**: 수백만 MAU 지원 (자동 스케일)
- **레이턴시**: <10ms (단일 리전)
- **가용성**: 99.9% SLA
- **비용**: Lite $0.0055/MAU (10K 무료), Essentials $0.015/MAU (10K 무료), Plus $0.02/MAU

**장점**:
- AWS 네이티브 통합 (Lambda, API Gateway, DynamoDB)
- 10K MAU 무료 (Lite, Essentials), 추가 비용 낮음
- 서버리스, 완전 관리형
- Cognito Identity Pools로 AWS 리소스 직접 접근
- IAM 통합 보안
- 예측 가능한 가격 (MAU 기반)

**단점**:
- AWS 벤더 락인 (멀티 클라우드 불가)
- UI/UX 제한적 (Hosted UI 커스터마이징 어려움)
- 문서 복잡함 (User Pools vs Identity Pools 혼란)
- Advanced Security Features 추가 비용 ($0.05/MAU)
- 크로스 리전 복제 미지원 (많은 사용자 요청 중)

**적합한 경우**:
- AWS 중심 인프라 (Lambda, API Gateway 사용)
- 서버리스 아키텍처
- 중간 규모 (10K~100K MAU)
- 예산 민감 (10K 무료 활용)
- 빠른 MVP 출시

**검증 사례**: 수많은 AWS 고객 (공개 사례 적음)

---

#### 옵션 3: Keycloak (Self-hosted / Managed)

**핵심 스펙**:
- **처리량**: 수만~수십만 MAU (클러스터 크기에 따라)
- **레이턴시**: <100ms (Self-hosted)
- **가용성**: 99.9%+ (HA 클러스터)
- **비용**: $0 (오픈소스) + 인프라 $510~$1,250/월 (Self-hosted), Managed $200~$1,000/월

**장점**:
- 완전한 커스터마이징 (소스 코드 접근)
- MAU 무제한 (인프라 비용만)
- 벤더 락인 없음 (온프레미스, 멀티 클라우드)
- 표준 프로토콜 (OIDC, OAuth2, SAML) 완벽 지원
- Active Directory, LDAP 통합
- Red Hat 상용 지원 가능 (Red Hat SSO)

**단점**:
- 높은 운영 부담 (HA 클러스터, DB, 모니터링)
- 배포 복잡도 (2~6개월 소요)
- 전문 인력 필요 (IAM 엔지니어 1~2명)
- 인프라 비용 (3×4 vCPU VM + 2×2 vCPU VM = $910/월)
- 유지보수 비용 (주 3시간 = $360/월)
- 러닝 커브 높음

**적합한 경우**:
- 대규모 사용자 (100K+ MAU, MAU 당 비용 회피)
- 온프레미스 필수 (금융, 정부, 의료)
- 완전한 제어 필요 (커스텀 인증 흐름)
- 장기 프로젝트 (5년+)
- 운영 역량 있는 팀

**검증 사례**: Red Hat, Cisco, CERN, 유럽 정부 기관

---

**의사결정 플로우차트**:
```
AWS 올인 환경?
├─ YES → 예산 < $500/월?
│   ├─ YES → AWS Cognito (옵션 2)
│   └─ NO → Auth0 (옵션 1)
└─ NO → MAU > 100K?
    ├─ YES → 운영 역량 있나?
    │   ├─ YES → Keycloak (옵션 3)
    │   └─ NO → Auth0 Enterprise (옵션 1)
    └─ NO → 빠른 배포 필요?
        ├─ YES → Auth0 (옵션 1)
        └─ NO → Keycloak Managed (옵션 3)
```

---

## Part 3: 도메인 선택 요소 (프로젝트별)

이 요소들은 **패밀리와 무관**하게 프로젝트 요구사항에 따라 선택합니다.

### 3.1 프론트엔드 프레임워크
- React, Vue, Angular, Svelte
- (패밀리 영향 없음, 팀 선호도 & 프로젝트 요구사항)

### 3.2 백엔드 언어/프레임워크
- Node.js (Express, NestJS), Python (FastAPI, Django), Java (Spring Boot), Go, C# (.NET)
- (패밀리 영향 적음, 팀 역량 & 성능 요구사항 우선)

### 3.3 인증/권한
- Auth0, AWS Cognito, Keycloak, Firebase Auth
- (패밀리 무관, 보안 요구사항 & 예산)

### 3.4 모니터링/로깅
- Prometheus + Grafana, ELK Stack, Datadog, New Relic, CloudWatch
- (패밀리 무관, 운영 선호도 & 예산)

### 3.5 ORM/쿼리 빌더
- TypeORM, Prisma, Sequelize (Node.js), SQLAlchemy (Python), JPA/Hibernate (Java)
- (DB 선택에 영향받음, 언어별 생태계)

---

## Part 4: Stage 2 통합

### 4.1 Layer 3 제약 반영 예시

**시나리오**: 전자상거래 주문 시스템

**Layer 3 제약 발견**:
- **팀 역량**: Python 팀 (Java 경험 부족)
- **인프라**: AWS 전용, 온프레미스 불가
- **예산**: 월 $500 이하
- **규정**: PCI DSS 준수 (결제 정보)

**기술 선택 영향**:
```
데이터베이스:
- CockroachDB (선호) → PostgreSQL RDS
- 이유: 예산 제약 ($360 vs $100), 다중 리전 불필요

캐시:
- Redis 유지
- 이유: 세션 관리 필수, PCI DSS 암호화 지원

메시징:
- Kafka (선호) → AWS SQS
- 이유: 예산 & 운영 간소화, AWS 전용 인프라
```

**재설계된 아키텍처**:
```
Frontend (React) → API Gateway
                      ↓
              Lambda (Python)
                      ↓
    PostgreSQL RDS + Redis ElastiCache + SQS
```

---

### 4.2 충돌 해결 예시

**NFR 목표 vs Layer 3 제약**:

**충돌 1**: 100% 정확성 A + 예산 $500/월
- **NFR**: Serializable 트랜잭션, 다중 리전
- **제약**: 예산 부족 (CockroachDB $360 최소)
- **해결**: PostgreSQL Serializable + 읽기 복제본 ($150/월)
  - 트레이드오프: 다중 리전 포기, 단일 리전 HA

**충돌 2**: 200ms 응답 A + Python 팀
- **NFR**: 캐싱, 읽기 복제본, 인덱싱
- **제약**: Python ORM 성능 (vs Java/Go)
- **해결**: Redis 적극 활용 + Async Python (FastAPI)
  - 읽기 90% 캐시 Hit, DB 부하 10%로 감소

**충돌 3**: 확장성 B + 메시징 경험 없음
- **NFR**: 비동기 처리, 서비스 분리
- **제약**: RabbitMQ/Kafka 학습 시간 부족
- **해결**: AWS SQS + Lambda (관리형)
  - 트레이드오프: AWS 종속, 처리량 제한 (3K/s)

---

### 4.3 ADR 작성 준비

**선택한 기술 스택 정리**:
```
Bootstrap 필수:
✅ DB: PostgreSQL RDS (db.t3.medium)
✅ 캐시: Redis ElastiCache (cache.t3.medium)
✅ 메시징: AWS SQS (Standard)

도메인 선택:
✅ 백엔드: Python 3.12 + FastAPI
✅ ORM: SQLAlchemy + Alembic
✅ 프론트엔드: React 18 + TypeScript
✅ 인증: AWS Cognito
✅ 모니터링: CloudWatch + Grafana
```

**ADR 작성 대상**:
1. **ADR-001**: PostgreSQL vs CockroachDB 선택 (예산 제약)
2. **ADR-002**: AWS SQS vs RabbitMQ 선택 (운영 간소화)
3. **ADR-003**: Redis 캐싱 전략 (Cache-Aside vs Write-Through)
4. **ADR-004**: Read Replicas 구성 (읽기 부하 분산)
5. **ADR-005**: Serializable 격리 수준 적용 범위 (성능 vs 정확성)

**각 ADR 포함 내용**:
- Context: 비즈니스 요구사항 & Layer 3 제약
- Decision: 선택한 기술 & 이유
- Consequences: 장단점, 트레이드오프
- Alternatives: 고려했던 다른 옵션

---

## 📚 참고 자료

### 벤치마크
- [PostgreSQL Performance Tuning](https://www.postgresql.org/docs/current/performance-tips.html)
- [MySQL Performance Documentation](https://dev.mysql.com/doc/refman/8.0/en/optimization.html)
- [Redis Benchmarks](https://redis.io/docs/latest/operate/oss_and_stack/management/optimization/benchmarks/)
- [RabbitMQ Performance Measurements](https://www.rabbitmq.com/blog/2012/04/25/rabbitmq-performance-measurements-part-2)

### 비용 계산기
- [AWS Pricing Calculator](https://calculator.aws.amazon.com/)
- [PlanetScale Pricing](https://planetscale.com/pricing)
- [Supabase Pricing](https://supabase.com/pricing)
- [Redis Cloud Pricing](https://redis.io/pricing/)

### 공식 문서
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [MySQL Documentation](https://dev.mysql.com/doc/)
- [CockroachDB Documentation](https://www.cockroachlabs.com/docs/)
- [Redis Documentation](https://redis.io/documentation)
- [RabbitMQ Documentation](https://www.rabbitmq.com/documentation.html)
- [Kafka Documentation](https://kafka.apache.org/documentation/)
- [AWS SQS Documentation](https://docs.aws.amazon.com/sqs/)

### 검증 사례
- Amazon: [Amazon's Architecture](https://aws.amazon.com/architecture/)
- Stripe: [Stripe Engineering Blog](https://stripe.com/blog/engineering)
- Booking.com: [Booking.com Tech Blog](https://blog.booking.com/)
- Instagram: [Instagram Engineering Blog](https://instagram-engineering.com/)

---

**마지막 업데이트**: 2024-11-12  
**다음 검토**: 2025-02-12 (기술 스택 업데이트 반영)


### 2.5.2 API Gateway (DNA #9) - 라우팅 및 Rate Limiting ⭐⭐⭐

**패밀리 요구**:
- Rate Limiting - DDoS 방지, 서비스 보호
- 인증/권한 통합 - Identity 시스템과 연동
- API 버전 관리 - 배포 중단 없는 업그레이드
- 로드 밸런싱 - 트래픽 분산
- 모니터링 & 로깅 - 성능 추적, 디버깅

---

#### 옵션 1: Kong API Gateway

**핵심 스펙**:
- **처리량**: 100,000+ RPS (단일 노드)
- **레이턴시**: p99 <10ms (프록시 오버헤드)
- **Rate Limiting**: 초당 요청, 분당, 시간당 제한 가능
- **플러그인**: 50+ 공식 플러그인, 커스텀 Lua 플러그인
- **가용성**: 99.99% (클러스터 모드)

**비용**:
- **Kong Gateway OSS**: $0 (오픈소스)
- **Kong Konnect Free**: $0 (10 서비스)
- **Kong Konnect Plus**: $249/월 (무제한 서비스)
- **Kong Konnect Enterprise**: $2,500+/월 (고급 보안, 지원)
- **Self-hosted 인프라**: $200~$600/월 (3노드 HA)

**장점**:
- 고성능 (Nginx 기반, LuaJIT)
- 풍부한 플러그인 생태계 (인증, Rate Limiting, Transformation)
- Kubernetes 네이티브 (Kong Ingress Controller)
- 활발한 커뮤니티, 15년+ 검증
- Declarative 설정 (YAML/JSON)
- 멀티 프로토콜 (HTTP, gRPC, WebSocket, TCP/UDP)
- DB-less 모드 지원 (설정 파일 기반)

**단점**:
- Lua 학습 필요 (커스텀 플러그인 시)
- Enterprise 기능 고가 (RBAC, 분석)
- 클러스터 설정 복잡도 (PostgreSQL/Cassandra 필요)
- 메모리 사용량 높음 (150~300MB per 인스턴스)

**적합한 경우**:
- Kubernetes 환경 (Ingress Controller)
- 고성능 필수 (100K+ RPS)
- 플러그인 확장성 필요
- 오픈소스 우선 (벤더 락인 회피)
- 장기 프로젝트 (5년+)

**검증 사례**: NASA, Cisco, Samsung, Yahoo, T-Mobile

---

#### 옵션 2: AWS API Gateway

**핵심 스펙**:
- **처리량**: 10,000 RPS (기본), Throttling 설정 가능
- **레이턴시**: <50ms (통합 지연 포함)
- **Rate Limiting**: 계정당, API당, 메서드당 설정
- **통합**: Lambda, EC2, HTTP 엔드포인트
- **가용성**: 99.95% SLA (REST API), 99.99% (HTTP API)

**비용**:
- **HTTP API**: $1.00 per 1M requests
- **REST API**: $3.50 per 1M requests
- **WebSocket API**: $1.00 per 1M messages
- **월 예상** (100만 요청): $1~$3.50
- **추가 비용**: 데이터 전송, CloudWatch 로그

**장점**:
- 완전 관리형 (운영 부담 제로)
- AWS 네이티브 통합 (Lambda, Cognito, IAM)
- 자동 스케일링 (무제한 트래픽)
- 빠른 배포 (5~10분 설정)
- 저렴한 비용 (HTTP API $1/1M 요청)
- API Keys, Usage Plans 내장
- OpenAPI 스펙 지원

**단점**:
- AWS 벤더 락인 (멀티 클라우드 불가)
- 10K RPS 초과 시 AWS 지원팀 요청 필요
- 고급 Rate Limiting 제한적 (IP 기반만)
- WebSocket 30분 연결 제한
- 복잡한 변환 로직 어려움
- Latency 증가 가능 (통합 오버헤드)

**적합한 경우**:
- AWS 중심 인프라
- 서버리스 아키텍처 (Lambda)
- 빠른 MVP 출시 (1주 이내)
- 운영 최소화 우선
- 중소 규모 (10K RPS 이하)

**검증 사례**: Expedia, Coca-Cola, Change.org (공식 사례 다수)

---

#### 옵션 3: Traefik

**핵심 스펙**:
- **처리량**: 50,000~80,000 RPS (단일 노드)
- **레이턴시**: p99 <5ms (매우 낮은 오버헤드)
- **Rate Limiting**: 평균 요청률, 버스트 제한
- **자동 발견**: Docker, Kubernetes, Consul 자동 감지
- **가용성**: 99.9%+ (HA 구성 시)

**비용**:
- **Traefik OSS**: $0 (오픈소스)
- **Traefik Enterprise**: $2,000~$10,000/년 (클러스터당)
- **Self-hosted 인프라**: $100~$400/월 (2~3노드)

**장점**:
- 클라우드 네이티브 (Kubernetes, Docker 자동 발견)
- 자동 HTTPS (Let's Encrypt)
- 실시간 설정 업데이트 (재시작 불필요)
- 매우 가벼움 (50MB 메모리)
- Go 기반 (단일 바이너리, 배포 간편)
- 직관적 웹 UI (Traefik Dashboard)
- 멀티 프로토콜 (HTTP, gRPC, TCP, UDP)

**단점**:
- 플러그인 생태계 작음 (Kong 대비)
- 문서 분산 (v1, v2, v3 차이)
- Enterprise 기능 제한적 (Rate Limiting은 Enterprise만)
- 커뮤니티 작음 (Kong 대비)
- 고급 Rate Limiting 부족 (Redis 기반 분산 X)

**적합한 경우**:
- Kubernetes/Docker 환경
- 마이크로서비스 아키텍처
- 가벼운 게이트웨이 선호
- 자동 발견 필수
- 예산 최소화 (<$500/월)

**검증 사례**: Zed, Containous, 수많은 K8s 프로젝트

---

#### API Gateway 비교표

| 항목 | Kong | AWS API Gateway | Traefik |
|------|------|-----------------|---------|
| **처리량** | 100K+ RPS | 10K RPS (기본) | 50K~80K RPS |
| **레이턴시** | <10ms | <50ms | <5ms |
| **비용 (중규모)** | $200~$600/월 | $100~$500/월 | $100~$400/월 |
| **Rate Limiting** | ⭐⭐⭐ 고급 | ⭐⭐ 기본 | ⭐⭐ 기본 |
| **플러그인** | ⭐⭐⭐ 풍부 | AWS 통합 | ⭐⭐ 제한적 |
| **K8s 통합** | ⭐⭐⭐ 네이티브 | 가능 | ⭐⭐⭐ 네이티브 |
| **운영** | ⚙️⚙️ 중간 | ⚙️ 낮음 (관리형) | ⚙️⚙️ 중간 |
| **벤더 락인** | ❌ 없음 | ⚠️ AWS | ❌ 없음 |

**의사결정 플로우차트**:
```
AWS 올인 환경?
├─ YES → 서버리스 (Lambda)?
│   ├─ YES → AWS API Gateway (옵션 2)
│   └─ NO → Kong (옵션 1)
└─ NO → Kubernetes 환경?
    ├─ YES → 예산 < $500/월?
    │   ├─ YES → Traefik (옵션 3)
    │   └─ NO → 처리량 > 80K RPS?
    │       ├─ YES → Kong (옵션 1)
    │       └─ NO → Traefik (옵션 3)
    └─ NO → 플러그인 필수?
        ├─ YES → Kong (옵션 1)
        └─ NO → Traefik (옵션 3)
```

---

### 2.5.3 Error Handling (DNA #5) - 트랜잭션 롤백 및 보상 ⭐⭐⭐

**패밀리 요구**:
- 트랜잭션 롤백 메커니즘 - 전체 작업 취소
- 보상 트랜잭션 (Compensating Transaction) - 분산 트랜잭션 실패 복구
- 3-Level 에러 전략 - Domain, Application, Infrastructure 구분
- Context 전파 - 에러 원인 추적
- 타입 안전성 - 컴파일 타임 검증 (선택적)

---

#### 옵션 1: Custom Error Types (언어 표준)

**핵심 스펙**:
- **타입 안전성**: TypeScript/Rust에서 완벽한 타입 체킹
- **성능**: 제로 오버헤드 (런타임 비용 없음)
- **유연성**: 프로젝트 요구사항에 정확히 맞춤
- **학습 곡선**: 중간 (타입 시스템 이해 필요)

**비용**:
- $0 (언어 표준 기능)

**장점**:
- 완전한 제어 (에러 구조, 메시지 형식)
- 타입 안전성 (컴파일 타임 검증)
- 도메인 특화 에러 (비즈니스 로직 반영)
- 제로 의존성 (외부 라이브러리 불필요)
- 성능 최적화 가능
- IDE 자동완성 지원
- 디버깅 용이 (명확한 에러 타입)

**단점**:
- 보일러플레이트 코드 많음
- 각 에러마다 타입 정의 필요
- 팀 컨벤션 통일 어려움
- 에러 변환 수동 구현
- Backtrace 수동 관리

**적합한 경우**:
- 복잡한 도메인 로직 (수십 개 에러 타입)
- 타입 안전성 최우선
- 외부 의존성 최소화
- 팀 역량 높음 (타입 시스템 숙달)
- 장기 프로젝트 (유지보수 고려)

**검증 사례**: 대부분의 TypeScript/Rust 엔터프라이즈 프로젝트

**예시 (TypeScript)**:
```typescript
// 도메인별 에러 정의
class OrderError extends Error {
  constructor(
    message: string,
    public code: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'OrderError';
  }
}

class PaymentError extends Error {
  constructor(
    message: string,
    public transactionId: string,
    public amount: number
  ) {
    super(message);
    this.name = 'PaymentError';
  }
}

// 사용 예시
async function createOrder(data: OrderData): Promise<Order> {
  if (!data.items.length) {
    throw new OrderError('Empty order', 'ORDER_EMPTY');
  }
  
  try {
    const payment = await processPayment(data);
    return await saveOrder(data, payment);
  } catch (e) {
    if (e instanceof PaymentError) {
      // 보상 트랜잭션: 재고 복구
      await restoreInventory(data.items);
      throw new OrderError(
        'Payment failed',
        'PAYMENT_FAILED',
        { transactionId: e.transactionId }
      );
    }
    throw e;
  }
}
```

---

#### 옵션 2: thiserror (Rust 전용)

**핵심 스펙**:
- **타입 안전성**: 완벽한 컴파일 타임 검증
- **성능**: Zero-cost abstraction
- **derive 매크로**: 자동 Error trait 구현
- **Backtrace**: 자동 캡처 (nightly)

**비용**:
- $0 (오픈소스)

**장점**:
- 간결한 코드 (#[derive(Error)] 한 줄)
- 자동 Display 구현 (포맷 문자열)
- 자동 From 구현 (#[from] 속성)
- Backtrace 자동 전파
- 타입 안전성 (Result<T, E>)
- 제로 런타임 오버헤드
- IDE 자동완성 우수

**단점**:
- Rust 전용 (다른 언어 불가)
- nightly 컴파일러 필요 (Backtrace 기능)
- derive 매크로 학습 필요
- 복잡한 에러 계층 시 코드 길어짐

**적합한 경우**:
- Rust 프로젝트
- 타입 안전성 최우선
- 보일러플레이트 최소화
- 고성능 필수 (금융, 실시간)
- 팀이 Rust 숙련

**검증 사례**: Tokio, Serde, Actix, rust-analyzer

**예시 (Rust)**:
```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum OrderError {
    #[error("order is empty")]
    EmptyOrder,
    
    #[error("payment failed: {transaction_id}")]
    PaymentFailed {
        transaction_id: String,
        #[from]
        source: PaymentError,
    },
    
    #[error("inventory insufficient for item {item_id}")]
    InsufficientInventory {
        item_id: String,
        required: u32,
        available: u32,
    },
}

#[derive(Error, Debug)]
#[error("payment error: {message}")]
pub struct PaymentError {
    message: String,
    amount: f64,
}

// 사용 예시
async fn create_order(data: OrderData) -> Result<Order, OrderError> {
    if data.items.is_empty() {
        return Err(OrderError::EmptyOrder);
    }
    
    let payment = process_payment(&data)
        .await?; // PaymentError 자동 변환 (From impl)
    
    save_order(data, payment).await
}
```

---

#### 옵션 3: anyhow (Rust 전용)

**핵심 스펙**:
- **유연성**: 모든 에러 타입 수용
- **Context**: 에러 체인, 메시지 추가
- **Backtrace**: 자동 캡처
- **간편함**: 빠른 프로토타이핑

**비용**:
- $0 (오픈소스)

**장점**:
- 극도로 간단 (anyhow::Result<T> 만으로 충분)
- Context 체이닝 (.context() 메서드)
- Downcast 지원 (특정 에러 타입 검사)
- Backtrace 자동 포함
- ? 연산자 편리 (모든 에러 자동 전파)
- 빠른 프로토타이핑
- 학습 곡선 낮음

**단점**:
- 타입 안전성 약함 (anyhow::Error는 trait object)
- 라이브러리에 부적합 (API 경계에서 타입 정보 손실)
- 에러 타입 구별 어려움 (Downcast 필요)
- 애플리케이션 전용 (라이브러리는 thiserror 권장)

**적합한 경우**:
- 빠른 프로토타이핑 (MVP, POC)
- 애플리케이션 코드 (라이브러리 아님)
- 간편함 최우선
- 에러 타입 구별 불필요
- 팀이 Rust 초보

**검증 사례**: 많은 Rust CLI 도구, 애플리케이션

**예시 (Rust)**:
```rust
use anyhow::{Context, Result, bail};

async fn create_order(data: OrderData) -> Result<Order> {
    if data.items.is_empty() {
        bail!("Order cannot be empty");
    }
    
    let payment = process_payment(&data)
        .await
        .context("Failed to process payment")?;
    
    save_order(data, payment)
        .await
        .with_context(|| {
            format!("Failed to save order for user {}", data.user_id)
        })
}

// 에러 핸들링
match create_order(data).await {
    Ok(order) => println!("Order created: {}", order.id),
    Err(e) => {
        eprintln!("Error: {:?}", e);
        // 에러 체인 출력
        for cause in e.chain() {
            eprintln!("  Caused by: {}", cause);
        }
    }
}
```

---

#### Error Handling 비교표

| 항목 | Custom Types | thiserror | anyhow |
|------|--------------|-----------|--------|
| **타입 안전성** | ⭐⭐⭐ 완벽 | ⭐⭐⭐ 완벽 | ⭐⭐ 약함 |
| **보일러플레이트** | ⚠️ 많음 | ⭐⭐⭐ 적음 | ⭐⭐⭐ 최소 |
| **학습 곡선** | 중간 | 중간 | ⭐⭐⭐ 낮음 |
| **성능** | ⭐⭐⭐ 최고 | ⭐⭐⭐ 최고 | ⭐⭐ 약간 오버헤드 |
| **Backtrace** | 수동 | ⭐⭐⭐ 자동 | ⭐⭐⭐ 자동 |
| **Context 전파** | 수동 | 수동 | ⭐⭐⭐ 자동 |
| **라이브러리 적합** | ⭐⭐⭐ 우수 | ⭐⭐⭐ 우수 | ❌ 부적합 |
| **언어 지원** | 모든 언어 | Rust만 | Rust만 |

**의사결정 플로우차트 (Rust 프로젝트)**:
```
라이브러리 개발?
├─ YES → thiserror (옵션 2)
└─ NO → 빠른 프로토타이핑?
    ├─ YES → anyhow (옵션 3)
    └─ NO → 복잡한 에러 계층?
        ├─ YES → 타입 안전성 필수?
        │   ├─ YES → thiserror (옵션 2)
        │   └─ NO → anyhow (옵션 3)
        └─ NO → 간편함 우선?
            ├─ YES → anyhow (옵션 3)
            └─ NO → thiserror (옵션 2)
```

**의사결정 플로우차트 (TypeScript/JavaScript)**:
```
Custom Error Types (옵션 1) 사용
- 표준 Error 클래스 확장
- 도메인별 에러 클래스 정의
- Result<T, E> 패턴 고려 (ts-results 라이브러리)
```

---



================================================================================

📄 FILE: 03_collaboration_sync_tech_options.md
--------------------------------------------------------------------------------

# 협업/동기화 패밀리 (B-A-A) - 기술 매트릭스

**작성일**: 2025-11-12  
**패밀리**: 협업/동기화 (B-A-A)  
**검증 사례**: Google Docs (OT), Figma (CRDT), Notion (블록 편집)

---

## Part 1: 패밀리가 요구하는 시스템 구조 ⭐⭐⭐

### 1.1 B-A-A 특성이 강제하는 것

#### B (점진적 실패) → 최종 일관성 필수

**특성**:
- 일부 사용자가 일시적으로 구형 데이터 표시 허용
- 낙관적 업데이트 (Optimistic UI)
- 충돌 자동 해결 또는 수동 병합
- Eventual Consistency

**강제되는 기술적 요구**:
```
✅ 충돌 해결 메커니즘 (CRDT, OT, Last-Write-Wins)
✅ 버전 관리 시스템
✅ 동기화 프로토콜
✅ 오프라인 편집 지원
```

**검증 사례**:
- Google Docs: Operational Transformation, 200ms 네트워크 지연 허용
- Notion: 블록 기반 최종 일관성, 낙관적 업데이트

---

#### A (구조화 데이터) → 스키마 기반 DB 필수

**특성**:
- 문서, 텍스트, 구조화된 블록
- 고정 스키마 또는 반구조화 JSON
- 트랜잭션 보장 (일부)
- 관계형 쿼리

**강제되는 기술적 요구**:
```
✅ RDBMS (PostgreSQL, MySQL)
✅ Document versioning
✅ Foreign key constraints
✅ ACID 트랜잭션 (선택적)
```

**검증 사례**:
- Notion: 블록 기반 구조, PostgreSQL 백엔드
- Figma: 파일 메타데이터 RDBMS 저장, 디자인 변경은 별도 처리

---

#### A (밀리초~초 응답) → 실시간 통신 필수

**특성**:
- 0~200ms 체감 지연 (사용자 느낌)
- 양방향 실시간 통신
- 다중 사용자 동시 작업
- 변경 사항 즉시 전파

**강제되는 기술적 요구**:
```
✅ WebSocket 또는 유사 기술
✅ Pub/Sub 메커니즘
✅ 사용자 프레즌스 추적
✅ 인메모리 캐시
```

**검증 사례**:
- Figma: WebSocket 기반, 문서당 별도 프로세스, 밀리초급 응답
- Linear: 실시간 이슈 업데이트, 다중 사용자 동시 편집

---

### 1.2 이 패밀리에 필요한 DNA 시스템 및 메인 서비스

#### DNA 11개 시스템 중 필요한 것

B-A-A 패밀리는 다음 DNA 시스템이 필요합니다:

| DNA 시스템 | 중요도 | 이유 |
|-----------|-------|------|
| 1. Testing | ✅ 필수 | CRDT/OT 로직 검증 |
| 2. Code Quality | ✅ 필수 | 비동기 코드 품질 유지 |
| 3. Architecture | ✅ 필수 | 동기화 모듈 분리 |
| 4. Type System | ✅ 필수 | 문서 구조 타입 안전성 |
| 5. Error Handling | ✅ 필수 | 연결 끊김, 충돌 처리 |
| 6. Configuration | ✅ 필수 | WebSocket 설정, 타임아웃 |
| 7. **Identity & Access** | **⭐⭐⭐ 매우 중요** | **실시간 프레즌스, 세션 공유, 권한 동기화** |
| 8. Observability | ✅ 필수 | 동시 편집자 수, 동기화 지연 모니터링 |
| 9. **API Gateway** | **⭐⭐⭐ 매우 중요** | **WebSocket 터널링, 양방향 통신, 백프레셔** |
| 10. Resilience | ✅ 필수 | 재연결, 충돌 복구 |
| 11. **Performance** | **⭐⭐⭐ 매우 중요** | **0ms 체감 레이턴시, 동시 편집자 벤치마크** |

**특별히 중요한 DNA 시스템 (⭐⭐⭐)**:
- **Identity & Access**: 다중 디바이스 세션 동기화, 사용자 프레즌스 추적 필수
- **API Gateway**: WebSocket 프록시, 연결 관리, 로드 밸런싱 필수
- **Performance**: Google Docs 수준 (200ms 네트워크 허용) 달성 위해 지속적 최적화

→ **Part 2.5에서 이 3가지 DNA 시스템의 기술 옵션을 다룹니다.**

#### 메인 서비스 필수 요소 (패밀리 강제)

B-A-A 패밀리는 다음 4가지 메인 서비스 기술을 **반드시** 포함해야 합니다:

#### 1. RDBMS (필수!)
**역할**: 권위 있는 상태 저장, 메타데이터 관리
**이유**: 구조화 데이터(A) + 트랜잭션 보장
**선택지**: PostgreSQL, MySQL, CockroachDB

#### 2. WebSocket/실시간 통신 (필수!)
**역할**: 양방향 실시간 데이터 전송
**이유**: 밀리초 응답(A) + 다중 사용자 동시 작업
**선택지**: Socket.io, Native WebSocket, Server-Sent Events

#### 3. 동기화 엔진 (필수!)
**역할**: 충돌 해결, 상태 병합
**이유**: 점진적 실패(B) + 최종 일관성
**선택지**: Yjs, Automerge, 자체 구현(OT/CRDT)

#### 4. 캐시 레이어 (필수!)
**역할**: 빠른 읽기, 사용자 프레즌스 추적
**이유**: 밀리초 응답(A)
**선택지**: Redis, Memcached

---

## Part 2: 메인 서비스 기술 선택 ⭐⭐⭐

### 2.1 RDBMS 선택

**패밀리 요구**:
- 권위 있는 상태 저장
- 버전 히스토리 관리
- 메타데이터 쿼리
- 트랜잭션 보장

---

#### 옵션 1: PostgreSQL

**핵심 스펙**:
- **처리량**: 초당 1만~10만 트랜잭션 (pgbench 기준)
- **레이턴시**: 평균 15ms (TPC-B 벤치마크)
- **동시 접속**: 100~1000 커넥션 (connection pooling)
- **스토리지**: TB급 문서, JSON 네이티브 지원

**비용**:
- **Self-hosted**: 월 $100~$1,000 (t3.medium~m5.xlarge)
- **AWS RDS**: 월 $70~$2,000 (db.t3.medium~db.r5.xlarge)
- **Azure Database**: 월 $60~$1,800

**장점**:
- 🔧 Full SQL 지원, 복잡한 쿼리 가능
- 📦 JSON/JSONB 네이티브, 반구조화 데이터 유연
- 🔒 ACID 트랜잭션, 데이터 무결성
- 🌐 풍부한 생태계, 검증된 안정성

**단점**:
- 📈 수직 확장 중심, 수평 확장 어려움
- 💰 관리형 서비스 비용 높음
- 🔧 세밀한 튜닝 필요 (인덱스, 쿼리 최적화)

**적합한 경우**:
- 중대형 프로젝트 (1,000+ 동시 사용자)
- 복잡한 쿼리 필요 (보고서, 분석)
- JSON 문서 + 관계형 혼합
- ACID 보장 필수

**검증 사례**: Notion, Linear, Dropbox Paper

---

#### 옵션 2: MySQL

**핵심 스펙**:
- **처리량**: 초당 5,000~50,000 트랜잭션
- **레이턴시**: 평균 10~20ms
- **동시 접속**: 100~500 커넥션 권장
- **스토리지**: TB급, InnoDB 엔진

**비용**:
- **Self-hosted**: 월 $50~$800
- **AWS RDS**: 월 $50~$1,500
- **Google Cloud SQL**: 월 $40~$1,200

**장점**:
- 💰 저렴한 비용, 널리 사용됨
- 🚀 빠른 읽기 성능 (InnoDB)
- 🔧 간단한 설정, 낮은 학습 곡선
- 📚 방대한 커뮤니티, 레퍼런스

**단점**:
- 📊 PostgreSQL 대비 부족한 기능 (JSON, Full-text)
- 🔒 트랜잭션 처리 제한적
- 📈 대규모 확장 어려움

**적합한 경우**:
- 소중형 프로젝트 (100~1,000 사용자)
- 예산 $500/월 이하
- 단순한 스키마
- 빠른 MVP 출시

**검증 사례**: Basecamp, GitHub (초기), WordPress 기반 협업 도구

---

#### 옵션 3: CockroachDB

**핵심 스펙**:
- **처리량**: 초당 10만+ 트랜잭션 (분산 환경)
- **레이턴시**: 평균 10~50ms (지역 간 100ms+)
- **확장**: 선형 수평 확장
- **가용성**: 99.99% (멀티 리전)

**비용**:
- **Serverless**: $1/GB 저장, $0.50/10M RU
- **Dedicated**: 월 $295~$5,000+
- **Self-hosted**: 월 $500~$3,000 (3노드 클러스터)

**장점**:
- 📈 무제한 수평 확장
- 🌍 멀티 리전, 지리적 분산
- 🔒 강한 일관성 + 고가용성
- 🔄 PostgreSQL 호환 (95%)

**단점**:
- 💰 높은 비용 (대규모 시)
- ⏱️ 지역 간 레이턴시 증가
- 🔧 복잡한 운영 (분산 시스템)
- 🆕 상대적 신생, 생태계 작음

**적합한 경우**:
- 글로벌 서비스 (멀티 리전 필수)
- 무제한 확장 필요
- 고가용성 99.99%+ 요구
- 예산 $5,000/월+ 가능

**검증 사례**: Figma (부분적), LaunchDarkly

---

#### RDBMS 비교표

| 항목 | PostgreSQL | MySQL | CockroachDB |
|------|-----------|-------|-------------|
| **처리량** | 10K~100K/s | 5K~50K/s | 100K+/s |
| **레이턴시** | 15ms | 10~20ms | 10~50ms |
| **확장** | 수직 | 수직 | 수평 |
| **비용** | $100~$2K/월 | $50~$1.5K/월 | $500~$5K/월 |
| **운영** | ⚙️⚙️ 중간 | ⚙️ 낮음 | ⚙️⚙️⚙️ 높음 |
| **JSON 지원** | JSONB (우수) | JSON (제한) | JSONB (우수) |

**의사결정 가이드**:
```
글로벌 멀티 리전? → CockroachDB
  └─ NO
     ↓
복잡한 쿼리/JSON 많음? → PostgreSQL
  └─ NO
     ↓
예산 <$500/월? → MySQL
  └─ NO → PostgreSQL
```

---

### 2.2 WebSocket/실시간 통신 선택

**패밀리 요구**:
- 양방향 실시간 통신
- 다중 사용자 지원
- 낮은 레이턴시 (<100ms)
- 자동 재연결

---

#### 옵션 1: Socket.io

**핵심 스펙**:
- **레이턴시**: 50~150ms (네트워크 포함)
- **동시 접속**: 1만~10만 (단일 서버)
- **fallback**: HTTP Long-polling 자동
- **처리량**: 초당 10만+ 메시지

**비용**:
- **Self-hosted**: 월 $100~$1,000 (t3.medium~m5.xlarge)
- **Heroku**: 월 $25~$500 (Dyno)
- **DigitalOcean**: 월 $12~$160

**장점**:
- 🚀 자동 재연결, Fallback 내장
- 🔧 Room, Namespace 기능 내장
- 📦 풍부한 에코시스템, 클라이언트 라이브러리
- 🔗 Broadcasting, Acknowledgements 간편

**단점**:
- 💰 메모리 사용 높음 (연결당 ~100KB)
- 📈 대규모는 Redis Adapter 필요
- ⚡ native WebSocket 대비 약간 느림
- 🔧 프로토콜 오버헤드

**적합한 경우**:
- 중소 규모 (1,000~10,000 동시 접속)
- 빠른 개발 우선
- Fallback 필수 (방화벽 환경)
- Room 기능 활용

**검증 사례**: Figma (초기), Slack (초기), 다수 스타트업

---

#### 옵션 2: Native WebSocket

**핵심 스펙**:
- **레이턴시**: 10~50ms (네트워크 포함)
- **동시 접속**: 5만~20만 (단일 서버)
- **처리량**: 초당 50만+ 메시지
- **메모리**: 연결당 ~10KB

**비용**:
- **Self-hosted**: 월 $50~$800 (경량)
- **AWS ELB**: 월 $20~$300 (트래픽 기반)
- **Nginx**: 월 $30~$500 (프록시)

**장점**:
- ⚡ 최고 성능, 최소 오버헤드
- 💰 낮은 메모리 사용
- 🔧 완전한 제어, 커스터마이징 가능
- 📡 표준 프로토콜, 브라우저 네이티브

**단점**:
- 🔨 Room, Broadcasting 직접 구현
- 🔄 재연결 로직 수동 구현
- 📦 생태계 작음, 보일러플레이트 많음
- 🚫 Fallback 없음

**적합한 경우**:
- 대규모 (10,000+ 동시 접속)
- 최고 성능 필수
- 커스텀 프로토콜 필요
- 직접 제어 선호

**검증 사례**: Google Docs (WebSocket + 자체 프로토콜), Figma (현재)

---

#### 옵션 3: Server-Sent Events (SSE)

**핵심 스펙**:
- **레이턴시**: 50~200ms
- **동시 접속**: 1만~5만 (단일 서버)
- **방향**: 서버 → 클라이언트 단방향
- **Fallback**: HTTP 기반, 방화벽 통과 용이

**비용**:
- **Self-hosted**: 월 $50~$500
- **Cloudflare Workers**: 월 $5~$50 (100K 요청)
- **Vercel**: 월 $20~$300

**장점**:
- 🔥 단순함, HTTP 기반
- 🔓 방화벽 통과 용이
- 🔄 자동 재연결 내장
- 💰 저렴한 비용

**단점**:
- 🚫 단방향 (서버 → 클라이언트만)
- 📈 제한된 확장성
- 🔧 클라이언트 → 서버는 HTTP POST
- ⏱️ 상대적 높은 레이턴시

**적합한 경우**:
- 단방향 업데이트만 (알림, 피드)
- 소규모 (100~1,000 사용자)
- 방화벽 제약 심함
- 단순한 아키텍처 선호

**검증 사례**: GitHub (알림), Linear (일부 업데이트)

---

#### WebSocket 비교표

| 항목 | Socket.io | Native WebSocket | SSE |
|------|----------|------------------|-----|
| **레이턴시** | 50~150ms | 10~50ms | 50~200ms |
| **동시 접속** | 10K~100K | 50K~200K | 10K~50K |
| **방향** | 양방향 | 양방향 | 단방향 |
| **비용** | $100~$1K/월 | $50~$800/월 | $50~$500/월 |
| **복잡도** | ⚙️ 낮음 | ⚙️⚙️⚙️ 높음 | ⚙️ 낮음 |

**의사결정 가이드**:
```
양방향 필수? 
  └─ NO → SSE
  └─ YES
     ↓
동시 접속 > 10,000? → Native WebSocket
  └─ NO
     ↓
빠른 개발 우선? → Socket.io
  └─ NO → Native WebSocket
```

---

### 2.3 동기화 엔진 선택

**패밀리 요구**:
- 충돌 자동 해결
- 오프라인 편집 지원
- 버전 관리
- 효율적 델타 동기화

---

#### 옵션 1: Yjs (CRDT)

**핵심 스펙**:
- **동기화 방식**: CRDT (Conflict-free Replicated Data Types)
- **레이턴시**: <10ms (로컬 병합)
- **네트워크**: Binary encoding, 효율적 델타
- **자료구조**: Text, Map, Array, XML

**비용**:
- **오픈소스**: 무료
- **Hocuspocus (서버)**: Self-hosted, 월 $50~$500
- **Y-Sweet (관리형)**: 월 $100~$2,000

**장점**:
- ⚡ 수학적으로 보장된 수렴
- 🔄 오프라인 편집 완벽 지원
- 📦 풍부한 자료구조, 확장 가능
- 🔧 Provider 다양 (WebSocket, WebRTC, IndexedDB)

**단점**:
- 📚 학습 곡선, CRDT 이해 필요
- 💾 메모리 사용 높음 (히스토리 보관)
- 🔧 복잡한 충돌 시나리오 예측 어려움
- 🚫 의미 보존 제한 (텍스트 편집 외)

**적합한 경우**:
- 텍스트 편집 중심 (문서, 코드)
- 오프라인 필수
- 자동 충돌 해결 우선
- 대규모 동시 편집

**검증 사례**: Notion (블록), CodeMirror, ProseMirror 통합

---

#### 옵션 2: Automerge (CRDT)

**핵심 스펙**:
- **동기화 방식**: CRDT (JSON-like)
- **레이턴시**: <20ms (로컬 병합)
- **네트워크**: Columnar encoding, 압축
- **자료구조**: JSON 호환 (Object, Array, Text)

**비용**:
- **오픈소스**: 무료
- **Automerge-Repo (서버)**: Self-hosted, 월 $50~$300

**장점**:
- 📄 JSON 친화적, 익숙한 API
- 🔒 강한 일관성, 수학적 보장
- 🔧 Time-travel, 버전 히스토리
- 🌐 P2P 동기화 지원

**단점**:
- ⏱️ 상대적 느림 (Yjs 대비)
- 💾 높은 메모리 사용 (전체 히스토리)
- 📦 생태계 작음, 커뮤니티 작음
- 🆕 상대적 신생, 프로덕션 사례 적음

**적합한 경우**:
- JSON 문서 중심 (설정, 메타데이터)
- Time-travel 필요
- P2P 아키텍처
- 강한 일관성 보장

**검증 사례**: Actual Budget, Pushpin, 일부 분산 앱

---

#### 옵션 3: 자체 구현 (OT/Last-Write-Wins)

**핵심 스펙**:
- **동기화 방식**: Operational Transformation 또는 LWW
- **레이턴시**: <5ms (로컬 적용)
- **네트워크**: 커스텀 프로토콜
- **복잡도**: 높음, 직접 구현

**비용**:
- **개발 비용**: 1~6개월 (엔지니어 투입)
- **운영 비용**: 월 $50~$500 (서버)

**장점**:
- 🎯 완전한 제어, 도메인 최적화
- ⚡ 최고 성능 가능 (최적화 시)
- 💰 라이선스 비용 없음
- 🔧 커스텀 충돌 전략

**단점**:
- 🔨 높은 개발 비용, 유지보수 부담
- 🐛 버그 위험, 엣지 케이스 많음
- 📚 전문 지식 필요 (OT, CRDT)
- ⏱️ 긴 개발 시간 (1~6개월)

**적합한 경우**:
- 특수 요구사항 (CRDT로 불가능)
- 장기 프로젝트, 전담 팀
- 레거시 시스템 통합
- 특정 도메인 로직

**검증 사례**: Google Docs (OT), Figma (LWW + 중앙 서버)

---

#### 동기화 엔진 비교표

| 항목 | Yjs | Automerge | 자체 구현 |
|------|-----|-----------|----------|
| **병합 속도** | <10ms | <20ms | <5ms (최적화 시) |
| **메모리** | 높음 | 매우 높음 | 낮음~중간 |
| **충돌 해결** | 자동 (CRDT) | 자동 (CRDT) | 수동/커스텀 |
| **개발 비용** | 낮음 | 낮음 | 매우 높음 |
| **생태계** | 풍부 | 작음 | 없음 |

**의사결정 가이드**:
```
텍스트 편집 중심? → Yjs
  └─ NO
     ↓
JSON 문서 + Time-travel? → Automerge
  └─ NO
     ↓
특수 요구사항 + 전담 팀? → 자체 구현
  └─ NO → Yjs (범용)
```

---

### 2.4 캐시 레이어 선택

**패밀리 요구**:
- 밀리초 미만 응답
- 사용자 프레즌스 추적
- 세션 관리
- Pub/Sub

---

#### 옵션 1: Redis

**핵심 스펙**:
- **레이턴시**: 0.15ms (GET)
- **처리량**: 초당 120만 트랜잭션
- **자료구조**: String, Hash, List, Set, Sorted Set (5가지)
- **기능**: Pub/Sub, 지속성 (AOF, RDB)

**비용**:
- **Self-hosted**: 월 $50~$500
- **AWS ElastiCache**: 월 $50~$1,000
- **Redis Cloud**: 월 $30~$2,000

**장점**:
- ⚡ 초고속, 다양한 자료구조
- 🔔 Pub/Sub 내장, Broadcasting 용이
- 💾 지속성 옵션, 데이터 손실 방지
- 📦 풍부한 클라이언트 라이브러리

**단점**:
- 💰 메모리 기반, 비용 높음
- 🔧 단일 스레드, CPU 1코어만 사용
- 📈 클러스터 설정 복잡 (대규모 시)

**적합한 경우**:
- 대부분의 협업 시스템
- Pub/Sub 필요
- 복잡한 캐시 로직
- 사용자 프레즌스 추적

**검증 사례**: GitHub, Figma, Linear

---

#### 옵션 2: Memcached

**핵심 스펙**:
- **레이턴시**: <0.1ms
- **처리량**: 초당 100만+ operations
- **자료구조**: Key-Value만
- **멀티 스레드**: CPU 멀티코어 활용

**비용**:
- **Self-hosted**: 월 $30~$300
- **AWS ElastiCache**: 월 $30~$500

**장점**:
- ⚡ 극도로 빠름, 단순함
- 💰 저렴한 비용
- 🔧 멀티 스레드, CPU 효율
- 📉 낮은 메모리 오버헤드

**단점**:
- 📊 단순한 자료구조 (Key-Value만)
- 🚫 Pub/Sub 없음
- 💾 지속성 없음, 재시작 시 데이터 손실

**적합한 경우**:
- 단순 캐싱만
- 최소 비용
- 초고속 필수
- Pub/Sub 불필요

---

#### 캐시 비교표

| 항목 | Redis | Memcached |
|------|-------|-----------|
| **레이턴시** | 0.15ms | <0.1ms |
| **자료구조** | 다양 | Key-Value |
| **Pub/Sub** | 있음 | 없음 |
| **비용** | 중간 | 낮음 |

**의사결정 가이드**:
```
Pub/Sub 필요? → Redis
  └─ NO
     ↓
복잡한 자료구조? → Redis
  └─ NO → Memcached
```

---

## Part 2.5: 특별히 중요한 DNA 시스템 기술 선택 ⭐⭐⭐

### 2.5.1 Identity & Access (DNA #7) - 실시간 세션 관리 ⭐⭐⭐

**패밀리 요구**:
- 다중 디바이스 세션 동기화
- 사용자 프레즌스 실시간 추적
- WebSocket 연결별 인증
- 권한 변경 즉시 반영

---

#### 옵션 1: Auth0

**핵심 스펙**:
- **인증 지연**: <100ms (토큰 검증)
- **동시 세션**: 무제한 (Enterprise)
- **기능**: OAuth2, SAML, MFA, 소셜 로그인
- **가용성**: 99.99% SLA (Enterprise)

**비용**:
- **Free**: 25,000 MAU
- **Essential**: $35/월 (500 MAU)
- **Professional**: $240/월 (1,000 MAU)
- **Enterprise**: 맞춤형 (무제한 MAU)

**장점**:
- 🚀 빠른 통합 (1~3일)
- 🔐 완벽한 OAuth2/OIDC 지원
- 📊 실시간 유저 프레즌스 API
- 🔧 Actions/Rules로 커스터마이징

**단점**:
- 💰 MAU 증가 시 비용 급증
- 🔒 벤더 종속
- ⏱️ 토큰 갱신 지연 (WebSocket 문제)

**적합한 경우**:
- 빠른 MVP 출시
- 10,000+ MAU 규모
- 소셜 로그인 필수
- 운영 리소스 최소화

**검증 사례**: Figma, Notion, Linear

---

#### 옵션 2: AWS Cognito

**핵심 스펙**:
- **인증 지연**: <50ms (토큰 검증)
- **동시 세션**: 10,000/user pool (조정 가능)
- **기능**: OAuth2, SAML, MFA, Lambda 트리거
- **가용성**: 99.9% SLA

**비용**:
- **Free**: 50,000 MAU
- **이후**: $0.0055/MAU (50K~100K)
- **예상** (10K MAU): 무료
- **예상** (100K MAU): ~$275/월

**장점**:
- 💰 저렴한 비용 (50K MAU 무료)
- 🔗 AWS 서비스 완벽 통합
- 🔧 Lambda 트리거로 커스터마이징
- 📈 무제한 확장

**단점**:
- 🔒 AWS 종속
- 🔧 UI 커스터마이징 제한
- 📚 복잡한 설정 (다른 솔루션 대비)

**적합한 경우**:
- AWS 중심 인프라
- 대규모 (100K+ MAU)
- 비용 민감
- Lambda 활용 가능 팀

**검증 사례**: Slack, Airbnb, Capital One

---

#### 옵션 3: Keycloak (Self-hosted)

**핵심 스펙**:
- **인증 지연**: <20ms (로컬)
- **동시 세션**: 무제한 (인프라 의존)
- **기능**: OAuth2, SAML, LDAP, 커스텀 프로바이더
- **라이선스**: 오픈소스 (Apache 2.0)

**비용**:
- **오픈소스**: 무료
- **인프라**: 월 $100~$500 (2~4 노드)
- **Red Hat SSO (상용)**: 맞춤형

**장점**:
- 💰 라이선스 무료
- 🔧 완전한 커스터마이징
- 🔐 온프레미스 가능 (규제 준수)
- 🌐 LDAP/AD 통합

**단점**:
- 🔧 높은 운영 부담
- 📚 학습 곡선 가파름
- ⏱️ 배포 시간 1~2주+

**적합한 경우**:
- 온프레미스 필수
- LDAP/AD 통합 필수
- 규제 산업 (금융, 의료)
- DevOps 팀 존재

**검증 사례**: Deutsche Bank, Bosch, 유럽 정부

---

#### Identity & Access 비교표

| 항목 | Auth0 | Cognito | Keycloak |
|------|-------|---------|----------|
| **비용 (10K MAU)** | $240+/월 | 무료 | $100~$500 |
| **배포 시간** | 1~3일 | 3~5일 | 1~2주 |
| **운영 부담** | ⚙️ 낮음 | ⚙️ 중간 | ⚙️⚙️⚙️ 높음 |
| **커스터마이징** | 중간 | 중간 | 높음 |

**의사결정 플로우차트**:
```
온프레미스 필수? → Keycloak
  └─ NO
     ↓
AWS 중심 + 비용 민감? → Cognito
  └─ NO
     ↓
빠른 통합 우선? → Auth0
```

---

### 2.5.2 API Gateway (DNA #9) - WebSocket 프록시 ⭐⭐⭐

**패밀리 요구**:
- WebSocket 연결 프록시
- 연결별 인증 토큰 검증
- 로드 밸런싱 (sticky session)
- 백프레셔 관리

---

#### 옵션 1: Kong Gateway

**핵심 스펙**:
- **처리량**: 초당 100K+ 요청
- **레이턴시**: <10ms 추가 (프록시)
- **WebSocket**: 네이티브 지원
- **플러그인**: 100+ (인증, Rate Limit)

**비용**:
- **오픈소스**: 무료
- **Enterprise**: $35K+/년
- **Konnect (Cloud)**: $300/월~

**장점**:
- ⚡ 최고 성능, Nginx 기반
- 🔧 풍부한 플러그인 생태계
- 🔗 WebSocket 네이티브 지원
- 📊 상세한 메트릭스

**단점**:
- 💰 Enterprise 고비용
- 🔧 운영 복잡도 중간
- 📚 플러그인 개발 Lua 필요

**적합한 경우**:
- 대규모 (10K+ 동시 접속)
- 복잡한 라우팅 필요
- 다양한 인증 방식 통합
- 온프레미스/클라우드 하이브리드

**검증 사례**: Figma, Nasdaq, Honeywell

---

#### 옵션 2: AWS API Gateway + ALB

**핵심 스펙**:
- **처리량**: 초당 10K 요청/리전 (기본)
- **레이턴시**: 20~50ms 추가
- **WebSocket**: API Gateway WebSocket API 지원
- **연결**: 2시간 idle 타임아웃

**비용**:
- **REST API**: $3.50/백만 요청
- **WebSocket**: $1.00/백만 메시지 + $0.25/백만 연결분
- **예상** (1M 연결/월): ~$300/월

**장점**:
- 🔗 AWS 서비스 완벽 통합
- 🚀 서버리스, 운영 부담 최소
- 📈 자동 확장
- 🔐 IAM, Cognito 통합

**단점**:
- 🔒 AWS 종속
- ⏱️ 2시간 연결 제한 (재연결 필요)
- 💰 대규모 시 비용 증가

**적합한 경우**:
- AWS 중심 인프라
- 서버리스 아키텍처
- 중규모 (1K~10K 동시 접속)
- Lambda 백엔드

**검증 사례**: Slack, Discord (부분적)

---

#### 옵션 3: Traefik

**핵심 스펙**:
- **처리량**: 초당 50K+ 요청
- **레이턴시**: <5ms 추가
- **WebSocket**: 네이티브 지원
- **라이선스**: 오픈소스 (MIT)

**비용**:
- **오픈소스**: 무료
- **Enterprise**: $500+/월
- **인프라**: 월 $50~$200

**장점**:
- 💰 오픈소스 무료
- 🔧 Kubernetes 네이티브
- ⚡ 빠른 성능
- 🔄 동적 설정 (Hot reload)

**단점**:
- 📦 Kong 대비 적은 플러그인
- 📊 모니터링 기능 제한적
- 🔧 고급 기능은 Enterprise

**적합한 경우**:
- Kubernetes 환경
- 비용 민감
- 단순한 라우팅
- 소중규모 (100~5K 동시 접속)

**검증 사례**: Slack (부분적), 다수 스타트업

---

#### API Gateway 비교표

| 항목 | Kong | AWS API GW | Traefik |
|------|------|------------|---------|
| **레이턴시** | <10ms | 20~50ms | <5ms |
| **비용** | $0~$35K+/년 | $300+/월 | $0~$500/월 |
| **WebSocket** | 네이티브 | 2시간 제한 | 네이티브 |
| **운영** | ⚙️⚙️ 중간 | ⚙️ 낮음 | ⚙️ 낮음 |

**의사결정 플로우차트**:
```
AWS 서버리스 선호? → AWS API Gateway
  └─ NO
     ↓
Kubernetes 환경 + 비용 민감? → Traefik
  └─ NO
     ↓
대규모 + 복잡한 라우팅? → Kong
```

---

### 2.5.3 Performance (DNA #11) - 동시 편집 벤치마킹 ⭐⭐⭐

**패밀리 요구**:
- 0ms 체감 레이턴시 검증
- 동시 편집자 수 벤치마크
- CRDT/OT 병합 성능 측정
- 메모리 사용량 프로파일링

---

#### 옵션 1: k6 (Load Testing)

**핵심 스펙**:
- **프로토콜**: HTTP, WebSocket, gRPC
- **확장**: 분산 테스트, Cloud 지원
- **스크립트**: JavaScript
- **메트릭**: p95, p99, 처리량, 에러율

**비용**:
- **오픈소스**: 무료
- **k6 Cloud**: $99~$999/월

**장점**:
- 🔌 WebSocket 네이티브 지원
- 📊 상세한 레이턴시 메트릭
- 🔧 JavaScript 스크립트 (친숙)
- ☁️ Cloud 분산 테스트

**단점**:
- 🔧 브라우저 테스트 제한적
- 📦 CRDT 로직 직접 구현 필요

**적합한 경우**:
- WebSocket 레이턴시 테스트
- CI/CD 통합 부하 테스트
- 동시 접속자 시뮬레이션

**검증 사례**: Grafana, GitLab, Notion

---

#### 옵션 2: Lighthouse + WebVitals

**핵심 스펙**:
- **측정**: LCP, FID, CLS, TTI
- **환경**: 브라우저 (Chrome)
- **통합**: CI/CD, Playwright
- **포맷**: JSON, HTML 리포트

**비용**:
- **오픈소스**: 무료
- **인프라**: 없음 (클라이언트 측)

**장점**:
- 💰 완전 무료
- 📊 사용자 체감 성능 측정
- 🔧 CI/CD 자동화 용이
- 🌐 Core Web Vitals 표준

**단점**:
- 🚫 WebSocket 직접 측정 불가
- 📊 서버 측 메트릭 없음
- 🔧 협업 시나리오 제한적

**적합한 경우**:
- 프론트엔드 성능 최적화
- SEO/Core Web Vitals
- 초기 로딩 시간 최적화

**검증 사례**: Google, Vercel

---

#### 옵션 3: Custom Profiling (Yjs Benchmarks)

**핵심 스펙**:
- **측정**: CRDT 병합 시간, 메모리, 네트워크
- **환경**: Node.js, Browser
- **Yjs 공식**: yjs-benchmarks 저장소
- **포맷**: JSON, Markdown

**비용**:
- **오픈소스**: 무료
- **개발 시간**: 1~3일

**장점**:
- 🎯 CRDT 특화 벤치마크
- 📊 병합 성능 정밀 측정
- 🔧 Yjs/Automerge 직접 비교
- 💾 메모리 프로파일링

**단점**:
- 🔨 직접 구현 필요
- 📚 CRDT 이해 필요
- 🔧 유지보수 부담

**적합한 경우**:
- CRDT 엔진 선택
- 동기화 알고리즘 최적화
- 메모리 사용량 최적화

**검증 사례**: Yjs, Automerge 공식 벤치마크

---

#### Performance 비교표

| 항목 | k6 | Lighthouse | Custom |
|------|-----|-----------|--------|
| **WebSocket** | ✅ 지원 | ❌ 미지원 | ✅ 지원 |
| **CRDT 측정** | ❌ 직접 구현 | ❌ 미지원 | ✅ 특화 |
| **비용** | $0~$999/월 | 무료 | 무료 |
| **난이도** | ⚙️ 낮음 | ⚙️ 낮음 | ⚙️⚙️ 중간 |

**의사결정 플로우차트**:
```
CRDT 병합 성능 측정? → Custom Profiling
  └─ NO
     ↓
프론트엔드 Core Web Vitals? → Lighthouse
  └─ NO
     ↓
WebSocket 부하 테스트? → k6
```

---

## Part 3: 도메인 선택 요소 (프로젝트별)

이 요소들은 **패밀리와 무관**하게 프로젝트 요구사항에 따라 선택합니다.

### 3.1 프론트엔드 프레임워크
- React, Vue, Svelte, Solid (패밀리 영향 없음, 프로젝트 선호도)

### 3.2 백엔드 언어/프레임워크
- Node.js (Express, NestJS, Fastify)
- Python (FastAPI, Django)
- Go (Gin, Echo)
(패밀리 영향 적음, 팀 역량 우선)

### 3.3 인증/권한
- Auth0, Clerk, Supabase Auth, Firebase Auth
(패밀리 무관, 보안 요구사항)

### 3.4 모니터링/로깅
- Prometheus + Grafana, Datadog, New Relic
(패밀리 무관, 운영 선호도)

---

## Part 4: Stage 2 통합

### 4.1 Layer 3 제약 반영 예시

**시나리오**: 디자인 협업 도구

**Layer 3 제약 발견**:
- 규제: GDPR, 유럽 데이터 저장 의무
- 팀: Node.js 경험, Python 없음
- 인프라: AWS 중심, 멀티 리전 불필요
- 비용: 초기 예산 $2,000/월

**기술 선택 영향**:
```
RDBMS:
- CockroachDB (선호) → PostgreSQL
- 이유: 멀티 리전 불필요, 비용 절감 ($5K → $2K/월)

동기화:
- 자체 구현 (선호) → Yjs
- 이유: 개발 기간 단축 (6개월 → 1주), 검증된 CRDT
```

---

### 4.2 충돌 해결 예시

**NFR 목표 vs Layer 3 제약**:

**충돌 1**: 글로벌 확장 A + 예산 제한
- NFR: 멀티 리전, 99.99% 가용성
- 제약: 예산 $2,000/월
- **해결**: PostgreSQL + Read Replica (리전별)
  - 트레이드오프: 단일 리전 쓰기, 99.9% SLA (99.99% 포기)

**충돌 2**: 오프라인 필수 A + 개발 기간
- NFR: 오프라인 편집, CRDT 자동 병합
- 제약: 3개월 출시
- **해결**: Yjs 도입 (자체 구현 포기)
  - 트레이드오프: 커스텀 충돌 전략 불가, 라이브러리 의존성

---

### 4.3 ADR 작성 준비

**선택한 기술 스택 정리**:
```
Bootstrap 필수:
✅ RDBMS: PostgreSQL (AWS RDS)
✅ WebSocket: Socket.io
✅ 동기화: Yjs
✅ 캐시: Redis (AWS ElastiCache)

도메인 선택:
✅ 백엔드: Node.js + NestJS
✅ 프론트엔드: React + TypeScript
✅ 인증: Clerk
✅ 모니터링: Datadog
```

**ADR 작성 대상**:

Bootstrap ADR:
1. PostgreSQL 선택 (MySQL, CockroachDB 대비)
2. Socket.io 선택 (Native WebSocket 대비)
3. Yjs 선택 (Automerge, 자체 구현 대비)
4. Redis 선택 (Memcached 대비)

도메인 ADR:
5. NestJS 선택 (Express 대비)
6. React 선택 (Vue, Svelte 대비)
7. Clerk 선택 (Auth0 대비)

---

## 📚 참고 자료

### 벤치마크
- [PostgreSQL pgbench 공식 문서](https://www.postgresql.org/docs/current/pgbench.html)
- [Socket.io Performance Tuning](https://socket.io/docs/v4/performance-tuning/)
- [Yjs Performance Benchmarks](https://github.com/yjs/yjs#benchmarks)

### 비용 계산기
- [AWS RDS Pricing](https://aws.amazon.com/rds/postgresql/pricing/)
- [CockroachDB Pricing](https://www.cockroachlabs.com/pricing/)
- [AWS ElastiCache Pricing](https://aws.amazon.com/elasticache/pricing/)

### 공식 문서
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [MySQL Documentation](https://dev.mysql.com/doc/)
- [CockroachDB Documentation](https://www.cockroachlabs.com/docs/)
- [Socket.io Documentation](https://socket.io/docs/)
- [Yjs Documentation](https://docs.yjs.dev/)
- [Automerge Documentation](https://automerge.org/docs/)
- [Redis Documentation](https://redis.io/documentation)

### 검증 사례
- Figma: [Rust + WebSocket 아키텍처](https://www.figma.com/blog/)
- Google Docs: [Operational Transformation](https://googledocs.blogspot.com/)
- Notion: [블록 기반 편집](https://www.notion.so/blog/)

---

**마지막 업데이트**: 2025-11-12  
**다음 검토**: 2026-02-12 (기술 스택 업데이트 반영)


================================================================================

📄 FILE: 04_search_recommendation_tech_options.md
--------------------------------------------------------------------------------

# 검색/추천 패밀리 (B-B-B) - 기술 매트릭스

**작성일**: 2025-11-12  
**패밀리**: 검색/추천 (B-B-B)  
**검증 사례**: Elasticsearch (Zillow), Vector DB (RAG 앱), 추천 엔진

---

## Part 1: 패밀리가 요구하는 시스템 구조 ⭐⭐⭐

### 1.1 B-B-B 특성이 강제하는 것

#### B (점진적 실패) → 점진적 품질 저하 허용

**특성**:
- 일부 결과 누락 허용 (전부 또는 전무가 아님)
- 관련성 점수 기반 순위
- 타임아웃 시 부분 결과 반환
- Eventual consistency

**강제되는 기술적 요구**:
```
✅ Circuit breaker, fallback 메커니즘
✅ 관련성 스코어링 (relevance scoring)
✅ 타임아웃 처리
✅ 캐시 레이어 (구형 결과 반환)
```

**검증 사례**:
- Elasticsearch: 검색 스레드 풀 거부 시 에러, 하지만 시스템 계속 작동
- Zillow 추천: 실시간 추천 실패 시 캐시된 추천 반환

---

#### B (반구조화 데이터) → 유연한 스키마 필수

**특성**:
- JSON 문서, 다양한 필드 구조
- 동적 필드 추가/제거
- 중첩 객체, 배열
- 스키마 진화

**강제되는 기술적 요구**:
```
✅ Document store (JSON 네이티브)
✅ 동적 매핑 (dynamic mapping)
✅ Sparse vectors (희소 벡터)
✅ 유연한 인덱싱
```

**검증 사례**:
- Elasticsearch: 상품 카탈로그, 각 상품마다 다른 속성 (전자제품 vs 의류)
- Vector DB: 다양한 길이의 텍스트 임베딩

---

#### B (수초 응답) → 빠른 검색 필수

**특성**:
- 50ms~10초 (단순→복잡 쿼리)
- 사용자 대기 가능 범위
- 관련성 우선, 속도 차선
- 병렬 쿼리 최적화

**강제되는 기술적 요구**:
```
✅ 역인덱스 (inverted index)
✅ 샤딩, 파티셔닝
✅ 쿼리 캐싱
✅ 인메모리 구조
```

**검증 사례**:
- Elasticsearch: 50-100ms 단순 쿼리, 100ms-10초 복잡 집계
- Zillow: 100ms 미만 실시간 추천, 11.5-25.6% 레이턴시 감소

---

### 1.2 이 패밀리에 필요한 DNA 시스템 및 메인 서비스

#### DNA 11개 시스템 중 필요한 것

B-B-B 패밀리는 다음 DNA 시스템이 필요합니다:

| DNA 시스템 | 중요도 | 이유 |
|-----------|-------|------|
| 1. Testing | ✅ 필수 | 검색 로직 검증 |
| 2. Code Quality | ✅ 필수 | 코드 품질 유지 |
| 3. Architecture | ✅ 필수 | 검색/추천 모듈 분리 |
| 4. Type System | ✅ 필수 | 쿼리 타입 안전성 |
| 5. Error Handling | ✅ 필수 | 타임아웃, 폴백 전략 |
| 6. Configuration | ✅ 필수 | 인덱스 설정, 쿼리 파라미터 |
| 7. Identity & Access | ✅ 필수 | 사용자별 검색 권한 |
| 8. Observability | ✅ 필수 | 쿼리 성능 모니터링 |
| 9. **API Gateway** | **⭐⭐⭐ 매우 중요** | **검색 쿼리 최적화, 페이지네이션, 필터링 핵심** |
| 10. Resilience | ✅ 필수 | Circuit breaker, 폴백 |
| 11. Performance | ✅ 필수 | 인덱싱, 쿼리 최적화 |

**특별히 중요한 DNA 시스템 (⭐⭐⭐)**:
- **API Gateway**: 복잡한 검색 쿼리 파싱, 페이지네이션, 필터링, 정렬 등 검색 UX의 핵심. GraphQL vs REST vs Elasticsearch DSL 직접 노출 여부가 시스템 복잡도를 좌우함.

→ **Part 2.5에서 이 DNA 시스템의 기술 옵션을 다룹니다.**

#### 메인 서비스 필수 요소 (패밀리 강제)

B-B-B 패밀리는 다음 3가지 메인 서비스 기술을 **반드시** 포함해야 합니다:

#### 1. 검색 엔진 (필수!)
**역할**: Full-text search, 관련성 스코어링
**이유**: 반구조화 데이터(B) + 빠른 검색(B)
**선택지**: Elasticsearch, Typesense, Meilisearch

#### 2. Vector DB (AI/RAG 시 필수, 아니면 불필요)
**역할**: 의미적 검색 (semantic search)
**이유**: 반구조화(B) + 의미 기반 관련성
**선택지**: Pinecone, Weaviate, pgvector
**주의**: Keyword 검색만 하면 불필요

#### 3. 캐시 레이어 (필수!)
**역할**: 핫 쿼리 결과 캐싱
**이유**: 수초 응답(B) + 점진적 실패(B)
**선택지**: Redis, Memcached

---

## Part 2: 메인 서비스 기술 선택 ⭐⭐⭐

### 2.1 검색 엔진 선택

**패밀리 요구**:
- Full-text search
- 관련성 스코어링
- 동적 필드 매핑
- 빠른 인덱싱

---

#### 옵션 1: Elasticsearch

**핵심 스펙**:
- **쿼리 속도**: 50-100ms (단순), 100ms-10초+ (복잡 집계)
- **인덱싱**: 초당 1만~10만 문서
- **처리량**: 초당 1만~10만 쿼리
- **확장**: 수평 확장 (샤딩)

**비용**:
- **Self-hosted**: 월 $25~$500 (소규모), $2,000~$7,000 (대규모)
- **Elastic Cloud**: 월 $95~$175 (Standard~Enterprise)
- **AWS OpenSearch**: 월 $500~$5,000

**장점**:
- 🔍 강력한 Full-text search, 다국어 지원
- 📊 복잡한 집계 (aggregations) 가능
- 🌐 풍부한 생태계, Kibana 시각화
- 🔧 유연한 쿼리 DSL, 필터링

**단점**:
- 💰 높은 비용 (대규모 시)
- 🔧 복잡한 설정, 튜닝 필요
- 💾 메모리 많이 사용
- 📈 클러스터 관리 부담

**적합한 경우**:
- 대기업, 복잡한 검색 요구
- 대용량 데이터 (TB급)
- 로그 분석, 모니터링
- 다국어, 지리 검색

**검증 사례**: Zillow (11.5-25.6% 레이턴시 감소), Uber, GitHub

---

#### 옵션 2: Typesense

**핵심 스펙**:
- **쿼리 속도**: <50ms (p99)
- **인덱싱**: 초당 1만~5만 문서
- **처리량**: 초당 5만~20만 쿼리
- **메모리**: Elasticsearch 대비 50% 절감

**비용**:
- **Self-hosted**: 월 $50~$300
- **Typesense Cloud**: 월 $29~$299 (사용량 기반)

**장점**:
- ⚡ 극도로 빠름, 메모리 효율
- 💰 저렴한 비용
- 🔧 간단한 설정, RESTful API
- 🔥 Typo tolerance (오타 허용)

**단점**:
- 📊 제한적 집계 (Elasticsearch 대비)
- 📦 작은 생태계, 커뮤니티
- 🔧 고급 기능 부족 (ML, 파이프라인)
- 📈 대규모 확장 제한

**적합한 경우**:
- 스타트업, MVP
- e-commerce 검색
- 예산 <$500/월
- 단순한 검색 요구

**검증 사례**: 여러 스타트업, e-commerce 사이트

---

#### 옵션 3: Meilisearch

**핵심 스펙**:
- **쿼리 속도**: <20ms (p99)
- **인덱싱**: 초당 5,000~20,000 문서
- **처리량**: 초당 1만~5만 쿼리
- **특징**: Search-as-you-type 최적화

**비용**:
- **Self-hosted**: 월 $30~$200
- **Meilisearch Cloud**: 월 $15~$500

**장점**:
- ⚡ 초고속, Instant search
- 🎯 Search-as-you-type 우수
- 🔧 간단한 API, 개발자 친화
- 💰 매우 저렴

**단점**:
- 📊 집계 없음
- 📈 대규모 데이터 제한 (GB급)
- 🔧 고급 쿼리 부족
- 🌐 작은 생태계

**적합한 경우**:
- 문서 검색, 웹사이트 검색
- 소규모 (GB급 데이터)
- Instant search UX 필수
- 최소 비용

**검증 사례**: 여러 문서 사이트, 소규모 앱

---

#### 검색 엔진 비교표

| 항목 | Elasticsearch | Typesense | Meilisearch |
|------|--------------|-----------|-------------|
| **쿼리 속도** | 50-100ms | <50ms | <20ms |
| **인덱싱** | 10K~100K/s | 10K~50K/s | 5K~20K/s |
| **비용** | $500~$7K/월 | $50~$300/월 | $30~$200/월 |
| **집계** | 강력 | 제한적 | 없음 |
| **확장성** | 무제한 | 중간 | 제한적 |
| **복잡도** | ⚙️⚙️⚙️ 높음 | ⚙️⚙️ 중간 | ⚙️ 낮음 |

**의사결정 가이드**:
```
데이터 > TB급? → Elasticsearch
  └─ NO
     ↓
복잡한 집계 필요? → Elasticsearch
  └─ NO
     ↓
Instant search 필수? → Meilisearch
  └─ NO
     ↓
예산 <$500/월? → Typesense
  └─ NO → Elasticsearch
```

---

### 2.2 Vector DB 선택 (AI/RAG 앱만 해당)

**패밀리 요구**:
- 의미적 검색 (semantic search)
- 고차원 벡터 저장 (768~1536 차원)
- K-NN 검색 (<100ms)
- 메타데이터 필터링

---

#### 옵션 1: Pinecone

**핵심 스펙**:
- **쿼리 속도**: p50 <10ms, p99 <50ms
- **처리량**: 초당 10만+ 쿼리
- **확장**: 억 단위 벡터 지원
- **인덱싱**: 초당 1만+ 벡터

**비용**:
- **Serverless**: 월 $50 최소 (pay-as-you-go)
- **Standard**: 월 $40~$200 (소중형)
- **Enterprise**: 월 $500~$2,000+

**장점**:
- ⚡ 극도로 빠름, 일관된 성능
- 🤖 완전 관리형, 자동 스케일링
- 🔧 간단한 API, SDK 풍부
- 🔒 SOC 2, HIPAA 인증

**단점**:
- 💰 높은 비용 (대규모 시)
- 🔒 벤더 종속
- 📊 제한적 쿼리 (K-NN 중심)
- 🔧 커스터마이징 제한

**적합한 경우**:
- 프로덕션 RAG 앱
- 빠른 배포, 운영 최소화
- 억 단위 벡터
- 예산 $200~$2,000/월

**검증 사례**: 다수 RAG 앱, LLM 기반 서비스

---

#### 옵션 2: Weaviate

**핵심 스펙**:
- **쿼리 속도**: p99 <50ms
- **처리량**: 초당 5만~10만 쿼리
- **확장**: 억 단위 벡터 지원
- **특징**: Hybrid search (Vector + BM25)

**비용**:
- **Self-hosted**: 무료 (오픈소스)
- **Serverless**: 월 $25~$153 (사용량 기반)
- **Classic**: $0.05/백만 차원

**장점**:
- 🔓 오픈소스, Self-host 가능
- 🔧 Hybrid search, GraphQL
- 🌐 Multi-modal (텍스트, 이미지)
- 💰 저렴한 비용

**단점**:
- ⏱️ Pinecone 대비 약간 느림
- 🔧 Self-host 시 운영 부담
- 📦 생태계 작음 (Pinecone 대비)
- 🔧 복잡한 설정 (고급 기능)

**적합한 경우**:
- Hybrid search 필요
- Self-host 선호
- Multi-modal 데이터
- 예산 <$200/월

**검증 사례**: 여러 RAG 앱, 지식 그래프

---

#### 옵션 3: pgvector (PostgreSQL 확장)

**핵심 스펙**:
- **쿼리 속도**: 10-100ms (데이터 규모 의존)
- **처리량**: 초당 1만~5만 쿼리
- **확장**: 백만 단위 벡터 권장
- **특징**: PostgreSQL 네이티브

**비용**:
- **Self-hosted**: 월 $50~$500 (PostgreSQL 비용)
- **Supabase**: 월 $25~$599
- **AWS RDS**: 월 $70~$2,000

**장점**:
- 🔧 PostgreSQL 통합, SQL 사용
- 💰 저렴한 비용
- 🔒 트랜잭션 보장 (ACID)
- 📦 기존 인프라 활용

**단점**:
- ⏱️ 전용 Vector DB 대비 느림
- 📈 대규모 확장 제한 (백만 단위)
- 🔧 튜닝 필요 (인덱스, 쿼리)
- 💾 메모리 사용 높음

**적합한 경우**:
- PostgreSQL 이미 사용 중
- 소중형 (백만 단위 벡터)
- SQL + Vector 통합
- 예산 <$500/월

**검증 사례**: 여러 스타트업, 프로토타입

---

#### Vector DB 비교표

| 항목 | Pinecone | Weaviate | pgvector |
|------|----------|----------|----------|
| **쿼리 속도** | <10ms (p50) | <50ms (p99) | 10-100ms |
| **처리량** | 100K+/s | 50K~100K/s | 10K~50K/s |
| **확장** | 억 단위 | 억 단위 | 백만 단위 |
| **비용** | $50~$2K/월 | $25~$153/월 | $50~$500/월 |
| **운영** | ⚙️ 낮음 | ⚙️⚙️ 중간 | ⚙️⚙️ 중간 |

**의사결정 가이드**:
```
벡터 > 1억? → Pinecone or Weaviate
  └─ NO
     ↓
PostgreSQL 사용 중? → pgvector
  └─ NO
     ↓
Hybrid search 필요? → Weaviate
  └─ NO
     ↓
완전 관리형 필요? → Pinecone
  └─ NO → Weaviate (self-host)
```

---

### 2.3 캐시 레이어 선택

**패밀리 요구**:
- 핫 쿼리 결과 캐싱
- 밀리초 미만 응답
- TTL 관리
- 높은 처리량

---

#### 옵션 1: Redis

**핵심 스펙**:
- **레이턴시**: 0.15ms (GET)
- **처리량**: 초당 120만 트랜잭션
- **자료구조**: String, Hash, Sorted Set
- **특징**: TTL, Pub/Sub

**비용**:
- **Self-hosted**: 월 $50~$500
- **AWS ElastiCache**: 월 $50~$1,000
- **Redis Cloud**: 월 $30~$2,000

**장점**:
- ⚡ 초고속, 다양한 자료구조
- 🔧 TTL 자동 만료
- 🔔 Pub/Sub (캐시 무효화)
- 📦 풍부한 클라이언트

**단점**:
- 💰 메모리 기반, 비용 높음
- 🔧 단일 스레드
- 📈 클러스터 설정 복잡

**적합한 경우**:
- 대부분의 검색 시스템
- 복잡한 캐시 로직
- Pub/Sub 필요
- 쿼리 결과 캐싱

**검증 사례**: Zillow, GitHub, Uber

---

#### 옵션 2: Memcached

**핵심 스펙**:
- **레이턴시**: <0.1ms
- **처리량**: 초당 100만+ operations
- **자료구조**: Key-Value만
- **특징**: 멀티 스레드

**비용**:
- **Self-hosted**: 월 $30~$300
- **AWS ElastiCache**: 월 $30~$500

**장점**:
- ⚡ 극도로 빠름
- 💰 저렴한 비용
- 🔧 멀티 스레드, CPU 효율
- 📉 낮은 메모리 오버헤드

**단점**:
- 📊 단순한 자료구조
- 🚫 TTL 정밀도 낮음
- 💾 지속성 없음

**적합한 경우**:
- 단순 캐싱만
- 최소 비용
- 초고속 필수
- 복잡한 자료구조 불필요

---

#### 캐시 비교표

| 항목 | Redis | Memcached |
|------|-------|-----------|
| **레이턴시** | 0.15ms | <0.1ms |
| **자료구조** | 다양 | Key-Value |
| **TTL** | 정밀 | 제한적 |
| **비용** | 중간 | 낮음 |

**의사결정 가이드**:
```
복잡한 자료구조? → Redis
  └─ NO
     ↓
정밀한 TTL? → Redis
  └─ NO → Memcached
```

---

## Part 2.5: DNA 시스템 기술 선택 ⭐⭐⭐

### 2.5.1 API Gateway (DNA #9) - 검색 쿼리 최적화 ⭐⭐⭐

**패밀리 요구**:
- 복잡한 검색 쿼리 파싱 (필터, 정렬, 페이지네이션)
- 타입 안전한 쿼리 파라미터
- 쿼리 복잡도 제한 (DoS 방지)
- 캐싱 전략 통합
- Rate limiting, 인증 미들웨어

B-B-B 패밀리에서 API Gateway는 검색 UX의 핵심입니다. 사용자의 복잡한 검색 요구사항(필터링, 정렬, 패싯, 하이라이팅)을 어떻게 API로 노출할지가 개발 복잡도와 프론트엔드 개발 속도를 좌우합니다.

---

#### 옵션 1: GraphQL

**핵심 스펙**:
- **쿼리 유연성**: 클라이언트가 필요한 필드만 선택
- **타입 안전성**: 스키마 기반 타입 체크 (컴파일 타임)
- **페이지네이션**: Cursor-based (Relay), Offset-based 모두 지원
- **복잡도 제한**: Query complexity analysis, depth limiting

**비용**:
- **Self-hosted**: 추가 비용 없음 (오픈소스)
- **Apollo Server/Hasura**: 무료~월 $99~$499 (Managed 시)
- **개발 시간**: 초기 스키마 설계 1~2주

**장점**:
- 🎯 **극도로 유연한 쿼리**: 클라이언트가 필요한 것만 요청 (over-fetching 방지)
- 🛡️ **강력한 타입 안전성**: 스키마 기반, 컴파일 타임 에러 감지
- 📊 **복잡한 필터링 지원**: nested filters, AND/OR/NOT 조합
- 🔧 **자동 문서 생성**: GraphQL Playground/GraphiQL
- 🚀 **프론트엔드 개발 속도**: 백엔드 수정 없이 새로운 쿼리 작성 가능

**단점**:
- 🔧 **초기 학습 곡선**: GraphQL 스키마 설계, Resolver 작성
- 💰 **오버헤드**: 단순 검색에도 Resolver 레이어 필요
- 🐌 **N+1 문제**: DataLoader 없으면 성능 저하
- 🔒 **복잡도 관리**: 악의적 쿼리 (깊은 중첩) 방지 필요

**적합한 경우**:
- 복잡한 검색 UI (다중 필터, 동적 필드)
- 프론트엔드 개발 속도 > 백엔드 단순성
- 타입 안전성 중시 (TypeScript 팀)
- 다중 클라이언트 (웹, 모바일) 지원

**검증 사례**: GitHub Search (GraphQL API), Shopify (Product search), Airbnb

---

#### 옵션 2: REST API with Query Builder

**핵심 스펙**:
- **쿼리 방식**: URL 쿼리 파라미터 + POST body
- **필터링**: `?filter[category]=books&filter[price][gte]=10`
- **정렬**: `?sort=-relevance,price`
- **페이지네이션**: Offset-based (`?page=2&limit=20`)

**비용**:
- **Self-hosted**: 무료 (Express.js + Query Builder 라이브러리)
- **개발 시간**: 1주 (쿼리 파서, 검증 로직)

**장점**:
- 🔧 **단순한 구현**: Express.js + 쿼리 빌더 라이브러리로 빠른 구현
- 📚 **익숙한 패턴**: 대부분 개발자가 REST 경험 보유
- 🚀 **빠른 프로토타입**: API 엔드포인트별로 점진적 추가 가능
- 💰 **낮은 학습 곡선**: 추가 개념 학습 불필요

**단점**:
- 📝 **수동 문서화**: OpenAPI/Swagger 수동 작성 필요
- 🔄 **Over-fetching**: 클라이언트가 불필요한 필드도 받음
- 🔧 **쿼리 파라미터 복잡**: 복잡한 필터는 URL이 길어짐
- 🚫 **타입 안전성 약함**: 런타임 검증만 가능

**적합한 경우**:
- 단순~중간 복잡도 검색
- REST API 경험 팀
- 빠른 MVP 출시
- 쿼리 복잡도 제한적 (1~2 depth 필터)

**검증 사례**: Stripe API (검색 엔드포인트), Twilio, SendGrid

---

#### 옵션 3: Elasticsearch DSL 직접 노출

**핵심 스펙**:
- **쿼리 방식**: 프론트엔드가 Elasticsearch Query DSL 직접 전송
- **필터링**: JSON 쿼리 본문 (Elasticsearch DSL 그대로)
- **복잡도**: 무제한 (클라이언트 책임)
- **타입 안전성**: 없음 (JSON)

**비용**:
- **Self-hosted**: 무료 (Thin proxy만 필요)
- **개발 시간**: 2~3일 (인증, rate limiting 미들웨어만)

**장점**:
- ⚡ **최소 레이턴시**: 백엔드 변환 레이어 없음
- 🔧 **개발 최소화**: 거의 proxy만 구현
- 🎯 **완전한 Elasticsearch 기능**: Aggregation, Script, Geo 등 모두 사용 가능
- 💰 **최저 비용**: 백엔드 로직 거의 없음

**단점**:
- 🚨 **보안 위험**: 악의적 쿼리 (DoS, 민감 인덱스 접근) 방지 어려움
- 🔒 **권한 관리 복잡**: 문서 레벨 권한을 쿼리에 강제 삽입 필요
- 📝 **프론트엔드 복잡도**: Elasticsearch DSL 학습 필수
- 🐛 **디버깅 어려움**: 프론트엔드 쿼리 오류 추적 어려움

**적합한 경우**:
- 내부 도구, 관리자 대시보드 (신뢰된 사용자만)
- 매우 복잡한 검색 요구 (Elasticsearch 전체 기능 필요)
- 개발 리소스 극히 제한
- 프론트엔드 팀이 Elasticsearch 전문가

**검증 사례**: Kibana (내부 도구), 일부 관리자 대시보드

---

#### API Gateway 비교표

| 항목 | GraphQL | REST + Query Builder | Elasticsearch DSL 노출 |
|------|---------|---------------------|---------------------|
| **쿼리 유연성** | ⭐⭐⭐ 최고 | ⭐⭐ 중간 | ⭐⭐⭐ 최고 |
| **타입 안전성** | ⭐⭐⭐ 강함 | ⭐ 약함 | ❌ 없음 |
| **개발 시간** | 1~2주 | 1주 | 2~3일 |
| **학습 곡선** | ⭐⭐⭐ 높음 | ⭐ 낮음 | ⭐⭐ 중간 |
| **보안** | ⭐⭐⭐ 높음 | ⭐⭐ 중간 | ⚠️ 위험 |
| **비용** | 중간 | 낮음 | 최저 |
| **복잡도** | ⚙️⚙️⚙️ 높음 | ⚙️⚙️ 중간 | ⚙️ 낮음 |

**의사결정 플로우차트**:
```
내부 도구 (신뢰된 사용자만)? 
├─ YES → Elasticsearch DSL 직접 노출
│         (최저 비용, 최대 유연성)
└─ NO
   ↓
복잡한 검색 UI (다중 필터, 동적 필드)?
├─ YES → 프론트엔드 팀이 GraphQL 경험?
│        ├─ YES → GraphQL
│        │         (타입 안전성 + 유연성)
│        └─ NO → REST + Query Builder
│                  (빠른 개발, 익숙한 패턴)
└─ NO → REST + Query Builder
         (단순한 검색에 충분)
```

---

## Part 3: 도메인 선택 요소 (프로젝트별)

이 요소들은 **패밀리와 무관**하게 프로젝트 요구사항에 따라 선택합니다.

### 3.1 프론트엔드 프레임워크
- **선택 기준**: 팀 역량, 생태계, 프로젝트 규모
- **옵션**: React (대형, 풍부한 생태계), Vue (중소형, 학습 곡선 낮음), Svelte (경량, 빠른 성능)
- **패밀리 무관**: C-B-B는 프론트엔드 선택에 영향 없음

### 3.2 백엔드 언어/프레임워크
- **선택 기준**: 팀 역량, 검색 엔진 클라이언트 지원
- **옵션**: Node.js (Elasticsearch 클라이언트 우수), Python (ML/AI 통합), Go (성능 중시)
- **고려사항**: 검색 엔진 SDK 품질 확인 필요

### 3.3 인증/권한
- **선택 기준**: 보안 요구사항, 규제 준수
- **옵션**: Auth0 (엔터프라이즈), Clerk (개발자 친화), Firebase Auth (간편)
- **검색 연동**: 사용자별 검색 결과 필터링 고려

### 3.4 Embedding 모델 (AI/RAG 시)
- **선택 기준**: 정확도, 비용, 레이턴시
- **옵션**: OpenAI Ada-002 (높은 품질, $0.0001/1K tokens), Cohere (다국어), Sentence Transformers (무료, self-host)
- **Vector DB 연동**: 차원 수 호환성 확인 (768, 1536 등)

---

## Part 4: Stage 2 통합

### 4.1 Layer 3 제약 반영 예시

**시나리오**: e-commerce 검색 플랫폼

**Layer 3 제약 발견**:
- 규제: GDPR, 유럽 데이터 저장
- 팀: Python 경험, Go 없음
- 인프라: AWS 중심
- 비용: 초기 예산 $1,000/월

**기술 선택 영향**:
```
검색 엔진:
- Elasticsearch (선호) → Typesense
- 이유: 비용 절감 ($7K → $300/월)

Vector DB:
- Pinecone (선호) → Weaviate (self-host)
- 이유: GDPR 준수, 유럽 서버 필요

캐시:
- Redis 유지
- 이유: TTL, 쿼리 결과 캐싱 필수
```

---

### 4.2 충돌 해결 예시

**NFR 목표 vs Layer 3 제약**:

**충돌 1**: 속도 A + 예산 제한
- NFR: <50ms 검색
- 제약: 예산 $1,000/월
- **해결**: Typesense ($300) + 적극적 캐싱
  - **트레이드오프**: 복잡한 집계 불가 (Elasticsearch 대비), 대규모 확장 제한

**충돌 2**: 관련성 A + 개발 기간
- NFR: AI 의미적 검색
- 제약: 3개월 출시
- **해결**: Pinecone (관리형) 대신 pgvector (간단)
  - **트레이드오프**: 성능 낮음 (<10ms → 10-100ms), 백만 단위 벡터로 제한

---

### 4.3 ADR 작성 준비

**선택한 기술 스택 정리**:
```
Bootstrap 필수:
✅ 검색: Typesense (AWS EC2)
✅ Vector DB: pgvector (AWS RDS PostgreSQL)
✅ 캐시: Redis (AWS ElastiCache)

도메인 선택:
✅ 백엔드: Python + FastAPI
✅ 프론트엔드: React
✅ 인증: Auth0
✅ Embedding: OpenAI Ada-002
```

**ADR 작성 대상**:

Bootstrap ADR:
1. Typesense 선택 (Elasticsearch, Meilisearch 대비)
2. pgvector 선택 (Pinecone, Weaviate 대비)
3. Redis 선택 (Memcached 대비)

도메인 ADR:
4. FastAPI 선택 (Django 대비)
5. React 선택 (Vue 대비)
6. OpenAI Ada-002 선택 (Cohere 대비)

---

## 📚 참고 자료

### 벤치마크
- [Elasticsearch Performance Tuning](https://www.elastic.co/guide/en/elasticsearch/reference/current/tune-for-search-speed.html)
- [Typesense vs Elasticsearch Benchmark](https://typesense.org/docs/guide/performance.html)
- [Pinecone Performance Benchmarks](https://www.pinecone.io/learn/series/performance/)

### 비용 계산기
- [Elasticsearch Pricing](https://www.elastic.co/pricing/)
- [Typesense Cloud Pricing](https://cloud.typesense.org/pricing)
- [Pinecone Pricing Calculator](https://www.pinecone.io/pricing/)
- [Weaviate Pricing](https://weaviate.io/pricing)

### 공식 문서
- [Elasticsearch Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)
- [Typesense Documentation](https://typesense.org/docs/)
- [Meilisearch Documentation](https://www.meilisearch.com/docs)
- [Pinecone Documentation](https://docs.pinecone.io/)
- [Weaviate Documentation](https://weaviate.io/developers/weaviate)
- [pgvector Documentation](https://github.com/pgvector/pgvector)

### 검증 사례
- Zillow: [Elasticsearch 레이턴시 개선](https://www.elastic.co/customers/zillow)
- RAG Apps: [Vector DB 벤치마크](https://www.pinecone.io/learn/vector-database-benchmark/)
- e-commerce: [Typesense 사례](https://typesense.org/showcase/)

---

**마지막 업데이트**: 2025-11-12  
**다음 검토**: 2026-02-12 (기술 스택 업데이트 반영)


================================================================================

📄 FILE: 05_real_time_streaming_tech_options.md
--------------------------------------------------------------------------------

# 실시간 스트리밍 패밀리 (B-C-A) - 기술 매트릭스

**작성일**: 2024-11-12  
**패밀리**: 실시간 스트리밍 (B-C-A)  
**검증 사례**: Netflix RDG (100만 msg/s), Uber GPS, Twitter 타임라인

---

## Part 1: 패밀리가 요구하는 시스템 구조 ⭐⭐⭐

### 1.1 B-C-A 특성이 강제하는 것

#### B (점진적 실패) → 이벤트 스트리밍 필수

**특성**:
- 일부 메시지 손실 허용
- 버퍼링 및 재시도 메커니즘
- 최종 일관성 (Eventual Consistency)
- At-least-once 전달 보장

**강제되는 기술적 요구**:
```
✅ 메시지 큐/스트림 플랫폼 필수
✅ 이벤트 재생(replay) 기능
✅ Dead Letter Queue (DLQ)
✅ 체크포인트/오프셋 관리
```

**검증 사례**:
- Netflix: Kafka at-least-once, 메시지 재생으로 장애 복구
- Uber: GPS 데이터 일시 손실 허용, 보간(interpolation)으로 복구

---

#### C (비구조화 데이터) → 유연한 스키마 필수

**특성**:
- 이벤트 스트림, 시계열 데이터
- JSON, Protobuf 같은 유연한 포맷
- 스키마 진화 (Schema Evolution)
- 가변 필드 구조

**강제되는 기술적 요구**:
```
✅ NoSQL 또는 시계열 DB
✅ Schema Registry (선택)
✅ JSON/Protobuf 직렬화
✅ 동적 필드 처리
```

**검증 사례**:
- Twitter: 트윗 이벤트의 가변 메타데이터 (리트윗, 인용, 미디어)
- IoT: 센서별 다른 데이터 구조 (온도, 습도, 진동 등)

---

#### A (밀리초~수초 응답) → 저지연 아키텍처 필수

**특성**:
- p99 < 5초 목표
- 실시간 느낌 제공
- 고처리량 요구
- 수평 확장 가능

**강제되는 기술적 요구**:
```
✅ 파티셔닝 (병렬 처리)
✅ 인메모리 캐시
✅ 비동기 처리
✅ 수평 확장 아키텍처
```

**검증 사례**:
- Uber GPS: 2-5초 위치 업데이트, 초당 100만 쿼리
- Netflix: 5초 미만 추천 업데이트

---

### 1.2 이 패밀리에 필요한 DNA 시스템 및 메인 서비스

#### DNA 11개 시스템 중 필요한 것

B-C-A 패밀리는 다음 DNA 시스템이 필요합니다:

| DNA 시스템 | 중요도 | 이유 |
|-----------|-------|------|
| 1. Testing | ✅ 필수 | 이벤트 처리 로직 검증 |
| 2. Code Quality | ✅ 필수 | 비동기 코드 품질 유지 |
| 3. Architecture | ✅ 필수 | 스트림 처리 모듈 분리 |
| 4. Type System | ✅ 필수 | 이벤트 타입 안전성 |
| 5. Error Handling | ✅ 필수 | DLQ, 재시도 전략 |
| 6. Configuration | ✅ 필수 | 파티션 수, 버퍼 크기 등 |
| 7. Identity & Access | ✅ 필수 | Producer/Consumer 인증 |
| 8. **Observability** | **⭐⭐⭐ 매우 중요** | **메시지 lag, 처리량, 백프레셔 모니터링 필수** |
| 9. API Gateway | ✅ 필수 | 스트림 데이터 API 노출 |
| 10. **Resilience** | **⭐⭐⭐ 매우 중요** | **체크포인트, 재생, 장애 복구** |
| 11. **Performance** | **⭐⭐⭐ 매우 중요** | **처리량, 레이턴시 최적화** |

**특별히 중요한 DNA 시스템 (⭐⭐⭐)**:
- **Observability**: 메시지 lag, 처리량, 워터마크 추적 없이는 장애 감지 불가
- **Resilience**: 체크포인트 없으면 장애 시 데이터 손실
- **Performance**: 초당 100만 메시지 처리 위해 지속적 프로파일링 필수

→ **Part 2.5에서 이 3가지 DNA 시스템의 기술 옵션을 다룹니다.**

#### 메인 서비스 필수 요소 (패밀리 강제)

B-C-A 패밀리는 다음 3가지 메인 서비스 기술을 **반드시** 포함해야 합니다:

#### 1. 스트리밍 플랫폼 (필수!)
**역할**: 이벤트 수집, 파티셔닝, 전달
**이유**: 점진적 실패(B) + 연속 스트림(C)
**선택지**: Kafka, Kinesis, RabbitMQ

#### 2. 시계열 DB (필수!)
**역할**: 이벤트 저장, 시간 순 조회
**이유**: 비구조화 데이터(C) + 빠른 쓰기(A)
**선택지**: Cassandra, DynamoDB, TimescaleDB

#### 3. 캐시 레이어 (필수!)
**역할**: 핫 데이터 빠른 조회
**이유**: 밀리초 응답(A)
**선택지**: Redis, Memcached

---

## Part 2: 메인 서비스 기술 선택 ⭐⭐⭐

### 2.1 스트리밍 플랫폼 선택

**패밀리 요구**:
- 연속 이벤트 처리
- 파티션 기반 병렬 처리
- At-least-once 전달
- 이벤트 재생 가능

---

#### 옵션 1: Apache Kafka + Flink

**핵심 스펙**:
- **처리량**: 초당 200K~2M 메시지
- **레이턴시**: p99.9 <10ms
- **Peak throughput**: 605 MB/sec (managed cloud)
- **보장**: At-least-once 기본, exactly-once 선택 가능

**아키텍처**:
```
Producer → Kafka (Partitioned Topics)
           ↓
        Flink (Stream Processing)
           ↓
    Cassandra/ScyllaDB + Redis
```

**비용**:
- **Self-hosted**: 월 $2,000~$10,000+ (3노드 클러스터)
- **AWS MSK**: $0.21~$0.84/hour per vCPU, 예상 $3,000~$10,000/월
- **Confluent Cloud**: eCKU 기반, 예상 $5,000~$20,000/월

**배포 & 운영**:
- 배포 시간: 1~4주 (self-hosted), 1~3일 (MSK)
- 운영 복잡도: ⚙️⚙️⚙️ 높음
- 필요 역량: Kafka 전문가, Java/Scala, ZooKeeper

**장점**:
- ⚡ 최고 성능: 처리량 & 레이턴시
- 🔧 완벽한 제어: 세밀한 튜닝
- 🌐 풍부한 생태계: 검증된 커넥터
- 📈 무제한 확장

**단점**:
- 💰 높은 총비용
- 🧑‍💻 전문 인력 필수
- ⏱️ 긴 배포 시간
- 🔧 복잡한 운영

**적합한 경우**:
- 대기업, 미션 크리티컬
- 초당 100만+ 메시지
- 전담 DevOps 팀
- 멀티 클라우드/온프레미스

**검증 사례**: Netflix RDG (100만 msg/s), LinkedIn, Uber

---

#### 옵션 2: AWS Kinesis + Lambda

**핵심 스펙**:
- **처리량**: 1 MB/sec per shard (input), 2 MB/sec (output)
- **레이턴시**: p99 <1초
- **Capacity**: 1,000 PUT records/sec per shard
- **확장**: Shard 추가로 수평 확장

**아키텍처**:
```
Producer → Kinesis Data Streams (Shards)
           ↓
        Lambda (Serverless Processing)
           ↓
    DynamoDB + DAX Cache
```

**비용**:
- **Provisioned**: $0.015/shard/hour (~$11/shard/월)
- **On-Demand**: $0.0134/GB + $0.015/shard-hour
- **예상** (10 shards): 월 $500~$2,000

**배포 & 운영**:
- 배포 시간: 수 시간~1일
- 운영 복잡도: ⚙️ 낮음
- 필요 역량: AWS 기본, Lambda 경험

**장점**:
- 🚀 빠른 배포: 몇 시간 내 production
- 🤖 완전 관리형: 자동 스케일링
- 💵 예측 가능한 비용
- 🔗 AWS 통합: Lambda, S3, DynamoDB

**단점**:
- 🔒 AWS 종속
- ⚡ 성능 제한: Kafka 대비 낮음
- 🔧 튜닝 제한
- 📊 대규모는 비용 급증

**적합한 경우**:
- AWS 중심 조직
- 초당 1만~50만 메시지
- 제한된 DevOps 리소스
- 빠른 MVP/출시

**검증 사례**: Amazon 내부, Sonos, 중소기업

---

#### 옵션 3: RabbitMQ + 자체 처리

**핵심 스펙**:
- **처리량**: 초당 ~3만 메시지
- **레이턴시**: 30K msg/s까지 낮음, 초과 시 급증
- **메모리**: 메시지 큐잉, 지속 스토리지 아님

**아키텍처**:
```
Producer → RabbitMQ (Queues/Exchanges)
           ↓
    Custom Workers (Node.js/Python)
           ↓
    PostgreSQL + Redis
```

**비용**:
- **Self-hosted**: 월 $100~$500 (t3.medium~m5.large)
- **Amazon MQ**: ~$703/월 (3-node mq.m5.large)

**배포 & 운영**:
- 배포 시간: 1~3일
- 운영 복잡도: ⚙️⚙️ 중간
- 필요 역량: AMQP 이해, 기본 DevOps

**장점**:
- 💰 저렴한 비용
- 📚 성숙한 기술
- 🛠️ 간단한 운영
- 🔌 다양한 프로토콜 지원

**단점**:
- 📉 낮은 처리량
- ⏱️ 부하 시 레이턴시 증가
- 💾 단기 보관
- 🚫 확장 어려움

**적합한 경우**:
- 스타트업, MVP
- 초당 1만 미만 메시지
- 예산 $1,000/month 이하
- 전통적 메시징 패턴

---

#### 스트리밍 플랫폼 비교표

| 항목 | Kafka + Flink | Kinesis + Lambda | RabbitMQ |
|------|--------------|------------------|----------|
| **처리량** | 200K~2M/s | 50K~500K/s | ~30K/s |
| **레이턴시** | p99.9 <10ms | p99 <1s | 낮음 (저부하) |
| **비용 (중규모)** | $5K~$20K/월 | $500~$2K/월 | $200~$1.5K/월 |
| **배포** | 1~4주 | 수시간~1일 | 1~3일 |
| **운영** | ⚙️⚙️⚙️ 높음 | ⚙️ 낮음 | ⚙️⚙️ 중간 |
| **확장성** | 무제한 | Shard 제한 | 제한적 |
| **클라우드** | 멀티/온프렘 | AWS 전용 | 자유 |

**의사결정 가이드**:
```
처리량 > 100만/s? → Kafka
  └─ NO
     ↓
AWS 전용 OK? → Kinesis
  └─ NO → Kafka (self-hosted)
     ↓
처리량 > 5만/s? → Kinesis
  └─ NO
     ↓
예산 < $1K/월? → RabbitMQ
  └─ NO → Kinesis
```

---

### 2.2 시계열 DB 선택

**패밀리 요구**:
- 빠른 쓰기 성능 (초당 수만~수십만 건)
- 시간 순 조회 최적화
- 파티션/샤딩 지원
- 유연한 스키마 (JSON, Key-Value)

---

#### 옵션 1: Apache Cassandra / ScyllaDB

**핵심 스펙**:
- **쓰기 처리량**: 초당 100만+ 쓰기
- **레이턴시**: p99 <10ms (쓰기)
- **확장**: 선형 수평 확장
- **일관성**: Tunable (Quorum 권장)

**아키텍처**:
- Masterless, Peer-to-Peer
- 파티션 키 기반 분산
- Compaction 전략 (Time-Window)

**비용**:
- **Self-hosted**: 월 $1,000~$5,000 (3노드)
- **ScyllaDB Cloud**: 월 $500~$3,000
- **AWS Keyspaces**: 사용량 기반

**장점**:
- ⚡ 초고속 쓰기
- 📈 선형 확장
- 🌐 멀티 데이터센터 복제
- 💪 고가용성 (P2P)

**단점**:
- 🔧 복잡한 데이터 모델링
- 📊 제한적 쿼리 (No JOIN)
- 🧑‍💻 전문 지식 필요
- 💰 높은 리소스 사용

**적합한 경우**:
- 초고속 쓰기 (100만+ writes/sec)
- 시계열 데이터 (센서, 로그)
- 멀티 리전 배포
- Netflix, Uber 규모

**검증 사례**: Netflix (5M+ writes/sec), Uber, Discord

---

#### 옵션 2: AWS DynamoDB

**핵심 스펙**:
- **쓰기 처리량**: RCU/WCU 기반 확장
- **레이턴시**: p99 <10ms (single-digit ms)
- **확장**: 자동 스케일링
- **일관성**: Eventually consistent 기본

**아키텍처**:
- Managed NoSQL
- 파티션 키 + 정렬 키
- DynamoDB Streams (CDC)

**비용**:
- **On-Demand**: $1.25/million writes
- **Provisioned**: $0.00065/WCU/hour
- **예상**: 월 $500~$5,000

**장점**:
- 🤖 완전 관리형
- 🚀 빠른 배포
- 🔗 AWS 통합 (Lambda, Kinesis)
- 💵 사용량 기반 과금

**단점**:
- 🔒 AWS 종속
- 💰 대규모 시 비싸짐
- 📊 제한적 쿼리
- 🔧 핫 파티션 주의

**적합한 경우**:
- AWS 중심
- 중간 규모 (초당 1만~10만)
- 빠른 프로토타이핑
- 운영 부담 최소화

---

#### 옵션 3: TimescaleDB (PostgreSQL 확장)

**핵심 스펙**:
- **쓰기 처리량**: 초당 10만 건
- **레이턴시**: <10ms (쓰기)
- **확장**: Hypertable 파티셔닝
- **쿼리**: Full SQL 지원

**아키텍처**:
- PostgreSQL 기반
- 자동 시간 기반 파티셔닝
- 압축 (10:1 비율)

**비용**:
- **Self-hosted**: 월 $200~$2,000
- **Timescale Cloud**: 사용량 기반

**장점**:
- 🔍 Full SQL 지원
- 📊 복잡한 쿼리 가능
- 🛠️ 익숙한 PostgreSQL
- 💰 상대적 저렴

**단점**:
- ⚡ 쓰기 성능 한계 (vs Cassandra)
- 📈 확장 제한
- 🔧 Cassandra보다 운영 쉬움

**적합한 경우**:
- SQL 필수
- 중소 규모 (초당 ~10만)
- 복잡한 분석 쿼리
- PostgreSQL 팀 역량

---

#### 시계열 DB 비교표

| 항목 | Cassandra/ScyllaDB | DynamoDB | TimescaleDB |
|------|-------------------|----------|-------------|
| **쓰기 처리량** | 1M+/s | 100K~500K/s | ~100K/s |
| **쿼리 기능** | 제한적 | 제한적 | Full SQL |
| **확장성** | 선형 | 자동 | 제한적 |
| **비용** | $1K~$5K/월 | $500~$5K/월 | $200~$2K/월 |
| **운영** | ⚙️⚙️⚙️ 높음 | ⚙️ 낮음 | ⚙️⚙️ 중간 |

**의사결정 가이드**:
```
쓰기 > 100만/s? → Cassandra
  └─ NO
     ↓
AWS 전용 + 관리형? → DynamoDB
  └─ NO
     ↓
복잡한 SQL 필요? → TimescaleDB
  └─ NO → DynamoDB
```

---

### 2.3 캐시 레이어 선택

**패밀리 요구**:
- 밀리초 미만 응답
- 핫 데이터 빠른 조회
- 높은 처리량

---

#### 옵션 1: Redis

**핵심 스펙**:
- **레이턴시**: 0.15ms (GET)
- **처리량**: 초당 120만 트랜잭션
- **자료구조**: String, Hash, List, Set, Sorted Set, Stream

**비용**:
- **Self-hosted**: 월 $100~$500
- **AWS ElastiCache**: 월 $50~$1,000

**장점**:
- ⚡ 초고속
- 🔧 다양한 자료구조
- 📡 Pub/Sub 지원
- 💾 지속성 옵션 (AOF, RDB)

**단점**:
- 💰 메모리 기반 (비쌈)
- 🔧 단일 스레드

**적합한 경우**:
- 대부분의 스트리밍 시스템
- 복잡한 캐시 로직
- Pub/Sub 필요

---

#### 옵션 2: Memcached

**핵심 스펙**:
- **레이턴시**: 마이크로초
- **처리량**: 초당 100만+ operations
- **자료구조**: Key-Value만

**비용**:
- **Self-hosted**: 월 $50~$300
- **AWS ElastiCache**: 월 $30~$500

**장점**:
- ⚡ 극도로 빠름
- 💰 더 저렴
- 🔧 단순함

**단점**:
- 📊 단순한 자료구조
- 💾 지속성 없음

**적합한 경우**:
- 단순 캐싱만
- 최소 비용
- 초고속 필수

---

#### 캐시 비교표

| 항목 | Redis | Memcached |
|------|-------|-----------|
| **레이턴시** | 0.15ms | <0.1ms |
| **자료구조** | 다양 | Key-Value |
| **지속성** | 옵션 있음 | 없음 |
| **비용** | 중간 | 낮음 |

**의사결정 가이드**:
```
복잡한 자료구조 필요? → Redis
  └─ NO
     ↓
Pub/Sub 필요? → Redis
  └─ NO → Memcached
```

---

## Part 2.5: 중요 DNA 시스템 기술 선택 🆕

이 섹션에서는 B-C-A 패밀리에서 **⭐⭐⭐ 매우 중요한 DNA 시스템 3가지**의 기술 옵션을 다룹니다.

### 2.5.1 Observability (DNA #8) - 스트리밍 모니터링 ⭐⭐⭐

**패밀리 요구**:
- 메시지 lag 실시간 추적
- 처리량 (throughput) 모니터링
- 백프레셔 (backpressure) 감지
- 워터마크 (watermark) 추적

---

#### 옵션 1: Prometheus + Grafana + Jaeger

**핵심 스펙**:
- **메트릭 수집**: Prometheus (pull 방식)
- **시각화**: Grafana 대시보드
- **분산 추적**: Jaeger (OpenTelemetry)
- **비용**: 오픈소스 (인프라 비용만)

**장점**:
- 오픈소스, 커뮤니티 활성화
- Kafka Exporter로 lag, offset 자동 추적
- 무제한 메트릭, 무제한 대시보드
- Kubernetes 네이티브 통합

**단점**:
- 직접 운영 필요 (설치, 스케일링, 백업)
- 고가용성 구성 복잡 (Thanos, Cortex 추가)
- 알림 규칙 수동 작성
- 팀 러닝 커브

**적합한 경우**:
- 인프라 운영 역량 있는 팀
- 비용 민감한 프로젝트
- 커스터마이징 요구사항 많음
- 멀티 클라우드 환경

**검증 사례**: Uber, Twitter, Netflix (일부)

---

#### 옵션 2: DataDog

**핵심 스펙**:
- **메트릭 + 로그 + APM**: 통합 플랫폼
- **자동 Kafka 통합**: Agent 설치만으로 lag 추적
- **비용**: $15~$31/호스트/월 (Pro~Enterprise)

**장점**:
- 완전 관리형, 설치 5분
- Kafka, Flink 자동 통합
- AI 기반 이상 탐지
- 300+ 통합 (Slack, PagerDuty 등)
- 머신러닝 기반 알림

**단점**:
- 고비용 (호스트당 $15~$31/월)
- 메트릭 제한 (커스텀 메트릭 추가 비용)
- 벤더 락인
- 데이터 보존 기간 짧음 (기본 15일)

**적합한 경우**:
- 빠른 프로덕션 배포 필요
- 운영 인력 부족
- 통합 모니터링 선호
- 예산 여유

**검증 사례**: Airbnb, Spotify

---

#### 옵션 3: AWS CloudWatch + X-Ray

**핵심 스펙**:
- **메트릭**: CloudWatch (Kinesis 네이티브)
- **분산 추적**: X-Ray
- **비용**: $0.30/메트릭/월 + 데이터 전송

**장점**:
- AWS 서비스 네이티브 통합 (Kinesis, MSK)
- 서버리스, 관리 불필요
- IAM 통합 보안
- CloudWatch Insights (쿼리 언어)

**단점**:
- AWS 락인
- 대시보드 기능 제한적
- 커스텀 메트릭 비쌈 ($0.30/월 × 메트릭 수)
- 고급 기능 부족 (알림, 상관관계)

**적합한 경우**:
- AWS 올인 환경
- Kinesis/MSK 사용
- 서버리스 우선
- 최소 운영 부담

**검증 사례**: AWS 고객 다수

**의사결정 플로우차트**:
```
운영 역량 있나요?
├─ YES → 비용 민감?
│   ├─ YES → Prometheus + Grafana (옵션 1)
│   └─ NO → DataDog (옵션 2)
└─ NO → AWS 올인?
    ├─ YES → CloudWatch (옵션 3)
    └─ NO → DataDog (옵션 2)
```

---

### 2.5.2 Resilience (DNA #10) - 장애 복구 ⭐⭐⭐

**패밀리 요구**:
- 체크포인트 자동 저장
- 이벤트 재생 (replay)
- Dead Letter Queue
- Circuit Breaker

---

#### 옵션 1: Apache Flink State

**핵심 스펙**:
- **체크포인트**: 자동, RocksDB 백엔드
- **Exactly-once**: 2PC 지원
- **복구 시간**: 초~분 (상태 크기 의존)

**장점**:
- Kafka 네이티브 통합
- Exactly-once 보장
- 대규모 상태 처리 (TB급)
- Savepoint로 업그레이드 무중단

**단점**:
- Flink 전용 (Kafka Streams 불가)
- 운영 복잡도 높음
- 체크포인트 오버헤드 (5~10%)
- 러닝 커브 높음

**적합한 경우**:
- Exactly-once 필수
- 대규모 상태 처리
- 복잡한 스트림 처리
- Flink 채택 확정

**검증 사례**: Uber, Alibaba

---

#### 옵션 2: Resilience4j

**핵심 스펙**:
- **Circuit Breaker**: 5가지 상태
- **Retry**: Exponential backoff
- **Rate Limiter**: Token bucket
- **비용**: 오픈소스

**장점**:
- 경량 (Zero dependency)
- Java 8+ 함수형 스타일
- Spring Boot 통합
- Micrometer 메트릭 자동

**단점**:
- Java/Kotlin 전용
- 체크포인트 미지원 (별도 구현)
- Kafka 재생 수동 구현
- 분산 상태 관리 없음

**적합한 경우**:
- Java/Spring 환경
- 마이크로서비스 패턴
- 경량 솔루션 선호
- 애플리케이션 레벨 복원력

**검증 사례**: Spring Cloud 사용자 다수

---

#### 옵션 3: AWS Kinesis + Lambda DLQ

**핵심 스펙**:
- **체크포인트**: 자동 (Kinesis 관리)
- **DLQ**: SQS/Lambda 통합
- **재시도**: Lambda 최대 2회

**장점**:
- 완전 관리형
- 자동 체크포인트
- SQS DLQ 통합
- 서버리스

**단점**:
- Kinesis 제약 (샤드당 1MB/s)
- Exactly-once 미지원
- 복잡한 재생 로직 불가
- AWS 락인

**적합한 경우**:
- AWS 서버리스 환경
- 간단한 스트림 처리
- 운영 최소화
- At-least-once 충분

**검증 사례**: AWS 서버리스 사용자

**의사결정 플로우차트**:
```
Exactly-once 필요?
├─ YES → Flink 사용?
│   ├─ YES → Flink State (옵션 1)
│   └─ NO → 다른 스트리밍 고려
└─ NO → AWS 환경?
    ├─ YES → Kinesis + Lambda (옵션 3)
    └─ NO → Resilience4j (옵션 2)
```

---

### 2.5.3 Performance (DNA #11) - 벤치마크 및 프로파일링 ⭐⭐⭐

**패밀리 요구**:
- 처리량 측정 (메시지/초)
- 레이턴시 분포 (p50, p99, p999)
- 메모리 프로파일링
- 패턴별 성능 (sequential, random, burst)

---

#### 옵션 1: Criterion (Rust) / Criterion.rs

**핵심 스펙**:
- **통계**: 정규분포, 아웃라이어 검출
- **회귀 탐지**: 자동 (5% 임계값)
- **시각화**: HTML 리포트 자동 생성
- **비용**: 오픈소스

**장점**:
- 통계적으로 정확 (Welch's t-test)
- 회귀 자동 탐지
- 웜업 자동 처리
- 그래프 자동 생성 (Gnuplot)

**단점**:
- Rust 전용
- 마이크로벤치마크 위주
- 분산 벤치마크 미지원
- 대규모 통합 테스트 부적합

**적합한 경우**:
- Rust 프로젝트
- 마이크로 최적화
- CI/CD 성능 회귀 방지
- 통계적 정확성 필요

**검증 사례**: Rust 생태계 표준

---

#### 옵션 2: JMH (Java Microbenchmark Harness)

**핵심 스펙**:
- **JVM 워밍업**: JIT 최적화 고려
- **멀티스레드**: 동시성 벤치마크
- **프로파일러 통합**: perf, async-profiler
- **비용**: 오픈소스

**장점**:
- JVM 특화 (JIT, GC 고려)
- 멀티스레드 벤치마크
- Black hole (최적화 방지)
- Spring 통합 가능

**단점**:
- Java/Kotlin 전용
- 설정 복잡 (어노테이션 다수)
- 결과 해석 어려움
- 러닝 커브 높음

**적합한 경우**:
- Java/Kotlin 프로젝트
- Kafka Streams, Flink 최적화
- 멀티스레드 성능 측정
- JVM 전문가 팀

**검증 사례**: Netflix, Uber (JVM 프로젝트)

---

#### 옵션 3: pytest-benchmark (Python)

**핵심 스펙**:
- **통계**: min, max, mean, stddev
- **히스토그램**: 자동 생성
- **비교**: --benchmark-compare
- **비용**: 오픈소스

**장점**:
- pytest 네이티브 통합
- 간단한 사용법 (@pytest.mark.benchmark)
- CI 통합 쉬움
- JSON 결과 저장

**단점**:
- Python 전용 (GIL 제약)
- 통계 기능 제한적
- 회귀 탐지 수동
- 대규모 벤치마크 느림

**적합한 경우**:
- Python 프로젝트
- pytest 기반 테스트
- 간단한 성능 추적
- 빠른 프로토타입

**검증 사례**: Python 오픈소스 프로젝트

**의사결정 플로우차트**:
```
언어 스택?
├─ Rust → Criterion (옵션 1)
├─ Java/Kotlin → JMH (옵션 2)
└─ Python → pytest-benchmark (옵션 3)
```

---

## Part 3: 도메인 선택 요소 도메인 선택 요소 (프로젝트별)

이 요소들은 **패밀리와 무관**하게 프로젝트 요구사항에 따라 선택합니다.

### 3.1 프론트엔드 프레임워크
- React, Vue, Angular, Svelte
- (패밀리 영향 없음, 프로젝트 선호도)

### 3.2 백엔드 언어/프레임워크
- Node.js (Express, NestJS)
- Python (FastAPI, Django)
- Java (Spring Boot)
- Go
- (패밀리 영향 적음, 팀 역량 우선)

### 3.3 인증/권한
- Auth0, Cognito, Keycloak
- (패밀리 무관, 보안 요구사항)

### 3.4 모니터링/로깅
- Prometheus + Grafana
- ELK Stack
- Datadog, New Relic
- (패밀리 무관, 운영 선호도)

---

## Part 4: Stage 2 통합

### 4.1 Layer 3 제약 반영 예시

**시나리오**: 주식 거래 플랫폼

**Layer 3 제약 발견**:
- 증권사 API: 초당 20건 제한
- OS: Windows 전용 (일부 증권사)
- 비용: API 호출당 과금

**기술 선택 영향**:
```
스트리밍 플랫폼:
- Kafka (선호) → RabbitMQ (Windows 호환성)
- 이유: 일부 증권사 Windows DLL 제약

시계열 DB:
- Cassandra (선호) → PostgreSQL + TimescaleDB
- 이유: API 호출 제한으로 대용량 불필요

캐시:
- Redis 유지
- 이유: API 호출 최소화 필수
```

---

### 4.2 충돌 해결 예시

**NFR 목표 vs Layer 3 제약**:

**충돌 1**: 정확성 A + API 20건/초
- NFR: 100% 정확, 즉시 감지
- 제약: API 호출 제한
- **해결**: 우선순위 종목 + 폴링 주기 조정

**충돌 2**: 즉시성 A + API 지연
- NFR: 밀리초 응답
- 제약: API 응답 100ms
- **해결**: 적극적 캐싱 + WebSocket 활용

---

### 4.3 ADR 작성 준비

**선택한 기술 스택 정리**:
```
Bootstrap 필수:
✅ 스트리밍: RabbitMQ (Layer 3 제약)
✅ DB: PostgreSQL + TimescaleDB
✅ 캐시: Redis

도메인 선택:
✅ 백엔드: Node.js + TypeScript
✅ 프론트엔드: React
✅ 인증: JWT (자체 구현)
```

**ADR 작성 대상**:
1. 스트리밍 플랫폼 선택 (Kafka vs RabbitMQ)
2. DB 선택 (Cassandra vs TimescaleDB)
3. 캐시 전략
4. 증권사 API 통합 방식

---

## 📚 참고 자료

### 벤치마크
- [Confluent: Kafka vs Pulsar vs RabbitMQ (2020)](https://www.confluent.io/blog/kafka-fastest-messaging-system/)
- [OpenMessaging Benchmark Framework](https://openmessaging.cloud/docs/benchmarks/)
- Netflix Tech Blog: RDG 아키텍처

### 비용 계산기
- [AWS Kinesis Pricing](https://aws.amazon.com/kinesis/data-streams/pricing/)
- [AWS MSK Pricing](https://aws.amazon.com/msk/pricing/)
- [Confluent Cloud Pricing](https://www.confluent.io/confluent-cloud/pricing/)

### 공식 문서
- [Apache Kafka](https://kafka.apache.org/documentation/)
- [AWS Kinesis Developer Guide](https://docs.aws.amazon.com/kinesis/)
- [RabbitMQ Documentation](https://www.rabbitmq.com/documentation.html)
- [Cassandra Documentation](https://cassandra.apache.org/doc/)
- [DynamoDB Developer Guide](https://docs.aws.amazon.com/dynamodb/)
- [TimescaleDB Documentation](https://docs.timescale.com/)
- [Redis Documentation](https://redis.io/documentation)

### 검증 사례
- Netflix: [Building Netflix's Distributed Tracing Infrastructure](https://netflixtechblog.com/)
- Uber: [Real-Time Data Infrastructure at Uber](https://eng.uber.com/)
- Twitter: [The Infrastructure Behind Twitter](https://blog.twitter.com/engineering/)

---

**마지막 업데이트**: 2024-11-12  
**다음 검토**: 2025-02-12 (기술 스택 업데이트 반영)


================================================================================

📄 FILE: 06_analytics_batch_tech_options.md
--------------------------------------------------------------------------------

# 분석/배치 패밀리 (B-A-C) - 기술 매트릭스

**작성일**: 2025-11-12  
**패밀리**: 분석/배치 (B-A-C)  
**검증 사례**: Snowflake (8초 쿼리), Redshift, BigQuery, dbt

---

## Part 1: 패밀리가 요구하는 시스템 구조 ⭐⭐⭐

### 1.1 B-A-C 특성이 강제하는 것

#### B (점진적 실패) → 배치 재시도 필수

**특성**:
- 작업 실패 시 재시도
- 체크포인트 기반 복구
- 부분 성공 허용
- Idempotent 처리

**강제되는 기술적 요구**:
```
✅ 배치 스케줄러 (Airflow, dbt)
✅ 작업 재시도 메커니즘
✅ 데이터 리니지 추적
✅ 점진적 로드 (Incremental)
```

**검증 사례**:
- Snowflake: 작업 실패 시 자동 재시도, 체크포인트 복구
- dbt: Incremental 모델, 실패한 노드만 재실행

---

#### A (구조화 데이터) → 고정 스키마 필수

**특성**:
- 테이블 기반 구조
- 고정된 컬럼 정의
- SQL 쿼리 최적화
- ACID 트랜잭션 (배치 완료 시)

**강제되는 기술적 요구**:
```
✅ 관계형 스키마
✅ SQL 기반 변환
✅ 스키마 마이그레이션 도구
✅ 데이터 타입 검증
```

**검증 사례**:
- Snowflake: Zero-Copy Cloning, Time Travel (90일)
- Redshift: Columnar storage, Sort/Dist keys
- BigQuery: Nested/Repeated fields (STRUCT/ARRAY)

---

#### C (배치 처리) → ETL/ELT 파이프라인 필수

**특성**:
- 시간/일 단위 스케줄
- 대용량 데이터 처리
- 집계 및 변환
- 비실시간 (분~시간)

**강제되는 기술적 요구**:
```
✅ 배치 스케줄러
✅ 대용량 데이터 로더
✅ Materialized Views
✅ Query Result Caching
```

**검증 사례**:
- Snowflake: 8-12초 TPC-DS 쿼리 (벤치마크)
- Redshift: 8.24초 평균 쿼리, 82% 유휴 시간
- BigQuery: 11.18초 평균, 서버리스

---

### 1.2 이 패밀리에 필요한 DNA 시스템 및 메인 서비스

#### DNA 11개 시스템 중 필요한 것

B-A-C 패밀리는 다음 DNA 시스템이 필요합니다:

| DNA 시스템 | 중요도 | 이유 |
|-----------|-------|------|
| 1. Testing | ✅ 필수 | 배치 변환 로직 검증 |
| 2. Code Quality | ✅ 필수 | SQL/Python 품질 유지 |
| 3. Architecture | ✅ 필수 | ETL 파이프라인 모듈 분리 |
| 4. Type System | ✅ 필수 | 스키마 타입 안전성 |
| 5. Error Handling | ✅ 필수 | 배치 실패 재시도 전략 |
| 6. Configuration | ✅ 필수 | 배치 스케줄, DW 설정 |
| 7. Identity & Access | ✅ 필수 | DW 접근 권한, RLS |
| 8. Observability | ✅ 필수 | 배치 작업 상태 모니터링 |
| 9. API Gateway | ⚠️ 조건부 | BI 임베딩 시 필요 |
| 10. Resilience | ✅ 필수 | 체크포인트, 재시도 |
| 11. Performance | ✅ 필수 | 쿼리 최적화, 파티셔닝 |

**특별히 중요한 DNA 시스템 (⭐⭐⭐)**: 없음

B-A-C 패밀리는 모든 DNA 시스템이 **기본 수준**으로 필요합니다. 특별히 매우 중요한 시스템은 없습니다. 이유는:

- **배치 처리(C)**: 실시간이 아니라 디버깅 시간 충분
- **점진적 실패(B)**: 작업 재시도로 복구 가능
- **구조화 데이터(A)**: 스키마가 고정되어 예측 가능

→ **Part 2.5는 생략**합니다. 모든 DNA 시스템은 각 기술의 기본 가이드를 따르면 됩니다.

#### 메인 서비스 필수 요소 (패밀리 강제)

B-A-C 패밀리는 다음 3가지 메인 서비스 기술을 **반드시** 포함해야 합니다:

#### 1. 데이터 웨어하우스 (필수!)
**역할**: 대용량 분석 쿼리, 집계, 저장
**이유**: 구조화 데이터(A) + 배치 처리(C)
**선택지**: Snowflake, Redshift, BigQuery

#### 2. ETL/ELT 도구 (필수!)
**역할**: 데이터 추출, 변환, 로드
**이유**: 배치 파이프라인(C) + 스케줄링
**선택지**: dbt, Airflow, Fivetran

#### 3. BI/시각화 (필수!)
**역할**: 대시보드, 리포트 생성
**이유**: 분석 결과 시각화
**선택지**: Tableau, Looker, Power BI

---

## Part 2: 메인 서비스 기술 선택 ⭐⭐⭐

### 2.1 데이터 웨어하우스 선택

**패밀리 요구**:
- 대용량 SQL 쿼리 (수백 GB~PB)
- Columnar Storage (읽기 최적화)
- MPP (Massively Parallel Processing)
- 시간별/일별 배치 로드

---

#### 옵션 1: Snowflake

**핵심 스펙**:
- **쿼리 성능**: 8-12초 (TPC-DS 벤치마크)
- **처리량**: 수십 TB/일, PB급 스토리지
- **동시성**: 무제한 가상 웨어하우스
- **아키텍처**: Storage-Compute 분리, 3-Layer

**비용**:
- **Compute**: $2~$4/credit (웨어하우스 크기별)
- **Storage**: $23~$40/TB/월 (압축 후)
- **예상** (중규모): 월 $2,000~$10,000
- **대규모**: 월 $20,000~$100,000+

**장점**:
- ⚡ 최고 성능: 8초 TPC-DS
- 🔧 Zero-Copy Cloning: 개발/테스트 환경
- 📈 무제한 확장: 가상 웨어하우스 독립
- ⏱️ Time Travel: 90일 (Enterprise)
- 🌐 멀티 클라우드: AWS, Azure, GCP

**단점**:
- 💰 높은 비용: 크레딧 기반 과금
- 📊 러닝 커브: 최적화 복잡
- 🔒 클라우드 종속 (하지만 멀티)

**적합한 경우**:
- 대기업, 복잡한 분석
- 수십 TB~PB 데이터
- 멀티 팀 동시 작업
- 개발/스테이징 환경 필수

**검증 사례**: Instacart, Capital One, DoorDash

---

#### 옵션 2: AWS Redshift

**핵심 스펙**:
- **쿼리 성능**: 8.24초 평균 (벤치마크)
- **처리량**: 수 TB/일, PB급 확장
- **동시성**: WLM (Workload Management)
- **아키텍처**: MPP, Columnar, Sort/Dist Keys

**비용**:
- **RA3 (Storage-Compute 분리)**: $1.086~$13.04/node/hour
- **DC2 (Compute 최적화)**: $0.25~$4.80/node/hour
- **예상** (RA3.4xl, 2노드): 월 $1,600~$5,000
- **대규모** (10+ 노드): 월 $15,000~$50,000+

**장점**:
- 🔗 AWS 통합: S3, Lambda, Kinesis
- 💵 상대적 저렴: DC2 $0.25/시간부터
- 📊 성숙한 생태계: 다양한 커넥터
- ⚙️ WLM: 쿼리 우선순위 제어

**단점**:
- 🔒 AWS 종속
- 🔧 운영 복잡: 수동 튜닝 필요
- ⏱️ 동시성 제약: WLM 큐 관리
- 📉 유휴 비용: 82% 유휴 시간 (평균)

**적합한 경우**:
- AWS 중심 조직
- 수 TB~수십 TB 데이터
- 예측 가능한 워크로드
- SQL 최적화 역량 있음

**검증 사례**: Netflix, Lyft, McDonald's

---

#### 옵션 3: Google BigQuery

**핵심 스펙**:
- **쿼리 성능**: 11.18초 평균 (벤치마크)
- **처리량**: 수십 TB/일, PB급 스토리지
- **동시성**: 서버리스, 자동 확장
- **아키텍처**: Dremel, Columnar, Capacitor

**비용**:
- **On-Demand**: $6.25/TB (스캔된 데이터)
- **Flat-Rate**: $2,000~$10,000+/월 (slot 예약)
- **Storage**: $0.02/GB/월 (Active), $0.01 (Long-term)
- **예상** (On-Demand, 1TB/일): 월 $187

**장점**:
- 🚀 서버리스: 인프라 관리 불필요
- 💵 On-Demand: 사용한 만큼만
- 🔗 GCP 통합: Cloud Storage, Dataflow
- 📈 무제한 확장: 자동 슬롯 할당

**단점**:
- 🔒 GCP 종속
- 💰 대규모 시 비쌈: 쿼리 스캔량 기반
- 🔧 튜닝 제한: 서버리스라 제어 적음
- ⏱️ 스캔량 최적화 필요

**적합한 경우**:
- GCP 중심 조직
- 중소 규모, 비정기 쿼리
- 빠른 프로토타이핑
- 운영 부담 최소화

**검증 사례**: Spotify, Twitter, The New York Times

---

#### 데이터 웨어하우스 비교표

| 항목 | Snowflake | Redshift | BigQuery |
|------|-----------|----------|----------|
| **쿼리 성능** | 8-12초 | 8.24초 | 11.18초 |
| **처리량** | PB급 | PB급 | PB급 |
| **비용 (중규모)** | $2K~$10K/월 | $1.6K~$5K/월 | $187~$2K/월 |
| **운영** | ⚙️⚙️ 중간 | ⚙️⚙️⚙️ 높음 | ⚙️ 낮음 |
| **확장성** | 무제한 | 노드 추가 | 무제한 (서버리스) |
| **클라우드** | 멀티 | AWS | GCP |

**의사결정 가이드**:
```
데이터 > 100TB? → Snowflake
  └─ NO
     ↓
AWS 전용 OK? → Redshift
  └─ NO
     ↓
GCP 전용 OK? → BigQuery
  └─ NO → Snowflake (멀티 클라우드)
     ↓
운영 리소스 < 1명? → BigQuery
  └─ NO → Redshift or Snowflake
```

---

### 2.2 ETL/ELT 도구 선택

**패밀리 요구**:
- 배치 스케줄링 (cron, 이벤트 기반)
- 데이터 변환 (SQL, Python)
- 의존성 관리 (DAG)
- 재시도 및 모니터링

---

#### 옵션 1: dbt (Data Build Tool)

**핵심 스펙**:
- **변환 방식**: ELT (DW 내 SQL 변환)
- **배포**: Cloud ($50~$400+/월) or Core (오픈소스)
- **언어**: SQL + Jinja2
- **의존성**: DAG 자동 생성

**비용**:
- **dbt Core**: 무료 (오픈소스)
- **dbt Cloud Developer**: $50/seat/월
- **dbt Cloud Team**: $100+/seat/월
- **예상** (5명): 월 $250~$500

**장점**:
- 📊 SQL 중심: 데이터 분석가 친화적
- 🔧 Incremental 모델: 효율적 배치
- 📚 데이터 문서화: 자동 docs 생성
- 🧪 테스트: SQL 기반 데이터 품질 검증

**단점**:
- 🔧 오케스트레이션 제한: Airflow 필요 (대규모)
- 🐍 Python 제약: SQL 외 복잡 로직 어려움
- 📈 대규모 확장: 수천 모델 시 느림

**적합한 경우**:
- SQL 중심 팀
- 중소 규모 (수백 모델)
- Snowflake/Redshift/BigQuery 사용
- 데이터 분석가 주도 변환

**검증 사례**: GitLab, Zapier, JetBlue

---

#### 옵션 2: Apache Airflow

**핵심 스펙**:
- **변환 방식**: ETL/ELT 모두 지원
- **배포**: Self-hosted or Managed (MWAA)
- **언어**: Python (DAG 정의)
- **의존성**: 복잡한 DAG 지원

**비용**:
- **Self-hosted**: 월 $500~$2,000 (인프라)
- **AWS MWAA**: $0.49/hour (Environment) + $0.24/vCPU/hour
- **예상** (MWAA, 2 vCPU): 월 $700~$1,500
- **Google Cloud Composer**: 유사

**장점**:
- 🐍 Python 기반: 복잡한 로직 구현
- 🔧 유연성: 모든 데이터 소스 통합
- 📈 대규모 확장: 수천 작업 지원
- 📊 모니터링: UI + 알림

**단점**:
- 🧑‍💻 높은 러닝 커브: Python 필수
- 💰 운영 복잡: 워커 관리, 스케일링
- 🔧 설정 복잡: Executor, Queue 설정

**적합한 경우**:
- Python 팀
- 복잡한 파이프라인 (100+ 작업)
- 다양한 데이터 소스 통합
- 실시간 + 배치 혼합

**검증 사례**: Airbnb, Lyft, Reddit

---

#### 옵션 3: Fivetran

**핵심 스펙**:
- **변환 방식**: ELT (자동 커넥터)
- **배포**: Fully Managed (SaaS)
- **언어**: No-code (UI 설정)
- **커넥터**: 500+ 소스

**비용**:
- **Starter**: $120/월 (500K MAR)
- **Standard**: $180/월 (500K MAR)
- **Enterprise**: 맞춤형 가격
- **MAR**: Monthly Active Rows (변경된 행)
- **예상**: 월 $1,000~$10,000+

**장점**:
- 🚀 빠른 배포: 커넥터 클릭만
- 🤖 자동 스키마 변경 감지
- 🔗 500+ 커넥터: Salesforce, MySQL 등
- 💼 관리형: 유지보수 불필요

**단점**:
- 💰 높은 비용: MAR 기반 폭증 가능
- 🔧 커스터마이징 제한
- 🔒 벤더 종속

**적합한 경우**:
- No-code 선호
- 표준 SaaS 통합 (Salesforce 등)
- 빠른 MVP
- 운영 리소스 < 1명

**검증 사례**: DocuSign, Autodesk, Square

---

#### ETL/ELT 비교표

| 항목 | dbt | Airflow | Fivetran |
|------|-----|---------|----------|
| **언어** | SQL | Python | No-code |
| **비용** | $250~$500/월 | $700~$1.5K/월 | $1K~$10K/월 |
| **배포** | 수 시간 | 1~2주 | 수 시간 |
| **운영** | ⚙️ 낮음 | ⚙️⚙️⚙️ 높음 | ⚙️ 낮음 |
| **유연성** | SQL만 | 무제한 | 제한적 |

**의사결정 가이드**:
```
Python 팀? → Airflow
  └─ NO
     ↓
복잡한 로직 필요? → Airflow
  └─ NO
     ↓
표준 SaaS 통합? → Fivetran
  └─ NO → dbt
```

---

### 2.3 BI/시각화 선택

**패밀리 요구**:
- 대시보드 생성
- 드릴다운 분석
- 스케줄 리포트
- 공유 및 권한 관리

---

#### 옵션 1: Tableau

**핵심 스펙**:
- **배포**: Desktop, Server, Cloud
- **라이선스**: Creator, Explorer, Viewer
- **커넥터**: 100+ 데이터 소스

**비용**:
- **Creator**: $70/user/월
- **Explorer**: $42/user/월
- **Viewer**: $15/user/월
- **예상** (5 Creator, 20 Viewer): 월 $650

**장점**:
- 🎨 강력한 시각화
- 📊 드래그앤드롭: No-code
- 🔗 다양한 커넥터
- 📈 대규모 조직 지원

**단점**:
- 💰 높은 비용
- 🔧 서버 운영 필요 (온프렘)
- 📚 러닝 커브

**적합한 경우**:
- 대기업
- 복잡한 시각화
- 많은 Viewer

**검증 사례**: LinkedIn, Walmart, Verizon

---

#### 옵션 2: Google Looker

**핵심 스펙**:
- **배포**: Cloud only
- **모델링**: LookML (YAML 기반)
- **임베딩**: API 지원

**비용**:
- **Standard**: $5,000+/월 (10 users)
- **Enterprise**: 맞춤형
- **예상**: 월 $5,000~$20,000

**장점**:
- 🔗 GCP 통합
- 📊 LookML: 코드 기반 모델링
- 🔧 임베딩: 제품 통합

**단점**:
- 💰 매우 비쌈
- 🔒 GCP 종속
- 📚 LookML 러닝 커브

**적합한 경우**:
- GCP 중심
- 개발자 중심 팀
- 임베딩 필수

**검증 사례**: BuzzFeed, Warby Parker, Venmo

---

#### 옵션 3: Power BI

**핵심 스펙**:
- **배포**: Desktop, Service, Premium
- **라이선스**: Pro, Premium Per User

**비용**:
- **Pro**: $10/user/월
- **Premium Per User**: $20/user/월
- **예상** (20 users): 월 $200~$400

**장점**:
- 💵 저렴함
- 🔗 Microsoft 생태계
- 📊 Excel 친화적

**단점**:
- 🔒 Windows 권장
- 📉 복잡한 시각화 제약

**적합한 경우**:
- Microsoft 생태계
- 예산 제약
- Excel 중심 팀

**검증 사례**: Adobe, HP, Coca-Cola

---

#### BI 비교표

| 항목 | Tableau | Looker | Power BI |
|------|---------|--------|----------|
| **비용** | $650/월 | $5K+/월 | $200/월 |
| **시각화** | ⭐⭐⭐ | ⭐⭐ | ⭐⭐ |
| **러닝 커브** | 중간 | 높음 | 낮음 |

**의사결정 가이드**:
```
예산 > $5K/월? → Tableau or Looker
  └─ NO
     ↓
GCP 중심? → Looker
  └─ NO
     ↓
Microsoft 생태계? → Power BI
  └─ NO → Tableau
```

---

## Part 3: 도메인 선택 요소 (프로젝트별)

이 요소들은 **패밀리와 무관**하게 프로젝트 요구사항에 따라 선택합니다.

### 3.1 프론트엔드 프레임워크
- React, Vue, Angular (BI 임베딩 시)

### 3.2 백엔드 API
- REST API for 대시보드 데이터
- GraphQL for 복잡한 쿼리

### 3.3 인증/권한
- SSO, SAML (BI 통합)
- Row-Level Security (RLS)

### 3.4 모니터링
- Datadog, New Relic (파이프라인 모니터링)

---

## Part 4: Stage 2 통합

### 4.1 Layer 3 제약 반영 예시

**시나리오**: 금융 리포팅 시스템

**Layer 3 제약 발견**:
- 규제: SOX, GDPR 준수
- 비용: 쿼리 비용 제한 ($5K/월)
- 팀: SQL 중심 (Python 약함)

**기술 선택 영향**:
```
DW:
- BigQuery (선호) → Snowflake
- 이유: SOX 준수 인증, Time Travel

ETL:
- Airflow (선호) → dbt
- 이유: SQL 중심 팀

BI:
- Looker (선호) → Tableau
- 이유: 비용 ($650 vs $5K)
```

---

### 4.2 충돌 해결 예시

**NFR 목표 vs Layer 3 제약**:

**충돌 1**: 정확성 A + 비용 제약
- NFR: 100% 정확, 실시간 대시보드
- 제약: 쿼리 비용 $5K/월
- **해결**: Materialized Views + 1시간 새로고침

**충돌 2**: 속도 A + 팀 역량
- NFR: 초 단위 쿼리
- 제약: SQL만 가능 (Python 약함)
- **해결**: DW 내 최적화 (Clustering, Partitioning)

---

### 4.3 ADR 작성 준비

**선택한 기술 스택 정리**:
```
Bootstrap 필수:
✅ DW: Snowflake (SOX, Time Travel)
✅ ETL: dbt (SQL 중심)
✅ BI: Tableau (비용 효율)

도메인 선택:
✅ 인증: Okta SSO
✅ 모니터링: Datadog
```

**ADR 작성 대상**:
1. DW 선택 (Snowflake vs Redshift)
2. ETL 선택 (dbt vs Airflow)
3. BI 선택 (Tableau vs Looker)
4. 새로고침 주기 (1시간 vs 실시간)

---

**마지막 업데이트**: 2025-11-12  
**다음 검토**: 2026-02-12 (기술 스택 업데이트 반영)


================================================================================

📄 FILE: 07_safety_critical_iot_tech_options.md
--------------------------------------------------------------------------------

# 안전-임계 IoT 패밀리 (A-B-A) - 기술 매트릭스

**작성일**: 2025-11-12  
**패밀리**: 안전-임계 IoT (A-B-A)  
**검증 사례**: SCADA (5-250ms), IoT 긴급 경보 (450ms), 산업 안전 시스템

---

## Part 1: 패밀리가 요구하는 시스템 구조 ⭐⭐⭐

### 1.1 A-B-A 특성이 강제하는 것

#### A (치명적 실패) → 안전 시스템 필수

**특성**:
- 실패 시 인명 손실, 재산 피해
- 산업 재해, 화재, 폭발 위험
- 긴급 대응 필수 (경보, 셧다운)
- 규제 준수 (SIL 2+, UL, IEC)

**강제되는 기술적 요구**:
```
✅ Fail-Safe 설계 (기본값 안전)
✅ 중복성 (Redundancy)
✅ 워치독 (Watchdog) 타이머
✅ 감사 로그 (Audit Trail)
✅ 긴급 셧다운 (Emergency Shutdown)
```

**검증 사례**:
- 산업 제어 시스템 (SCADA): 센서 고장 시 자동 정지
- 긴급 경보 (EAS): 10분 내 전국 경보, FEMA/FCC

---

#### B (반구조화 데이터) → 센서 융합 필수

**특성**:
- JSON, XML 센서 데이터
- 가변 스키마 (센서별 다른 필드)
- 시계열 데이터 (온도, 압력, 진동)
- 다중 센서 융합 (Sensor Fusion)

**강제되는 기술적 요구**:
```
✅ 유연한 스키마 (Flexible Schema)
✅ 시계열 DB (Time-Series DB)
✅ 센서 융합 알고리즘
✅ JSON/XML 파싱
✅ 동적 필드 처리
```

**검증 사례**:
- IoT 센서: 온도 + 습도 + 진동 + 가스 농도
- SCADA: PLCraw 데이터 + 알람 메시지 + 상태 정보

---

#### A (밀리초 응답) → 실시간 처리 필수

**특성**:
- SCADA: 5-250ms 응답
- 긴급 경보: 450ms 미만
- 산업 제어: 수 밀리초 루프
- Edge Computing 필수

**강제되는 기술적 요구**:
```
✅ Edge Computing (로컬 처리)
✅ 경량 프로토콜 (MQTT, CoAP)
✅ 비동기 처리
✅ 우선순위 큐
✅ 저지연 네트워크 (5G, LoRaWAN)
```

**검증 사례**:
- Uber GPS: 2-5초 위치 업데이트
- 제조 안전: 밀리초급 센서-액추에이터 루프

---

### 1.2 이 패밀리에 필요한 DNA 시스템 및 메인 서비스

#### DNA 11개 시스템 중 필요한 것

A-B-A 패밀리는 다음 DNA 시스템이 필요합니다:

| DNA 시스템 | 중요도 | 이유 |
|-----------|-------|------|
| 1. Testing | ✅ 필수 | 안전 로직 검증, SIL 준수 |
| 2. Code Quality | ✅ 필수 | 결함 없는 코드 필수 |
| 3. Architecture | ✅ 필수 | Fail-safe 모듈 분리 |
| 4. **Type System** | **⭐⭐⭐ 매우 중요** | **컴파일 타임 안전성, SIL 인증** |
| 5. **Error Handling** | **⭐⭐⭐ 매우 중요** | **Fail-safe 전략, Watchdog** |
| 6. Configuration | ✅ 필수 | 센서 임계값, 타임아웃 설정 |
| 7. Identity & Access | ✅ 필수 | 센서 인증, 명령 권한 |
| 8. Observability | ✅ 필수 | 센서 상태, 알람 모니터링 |
| 9. API Gateway | ⚠️ 조건부 | SCADA 연동 시 필요 |
| 10. **Resilience** | **⭐⭐⭐ 매우 중요** | **N+1 중복, Failover, 생명 안전** |
| 11. Performance | ✅ 필수 | 밀리초 응답 보장 |

**특별히 중요한 DNA 시스템 (⭐⭐⭐)**:
- **Type System**: 런타임 에러 0을 목표, 컴파일 타임 검증 필수 (SIL 2+ 인증)
- **Error Handling**: 모든 에러는 안전 모드 전환, Watchdog 필수, 복구 불가 시 셧다운
- **Resilience**: 센서/액추에이터 N+1 중복, 5-250ms 페일오버, 크로스 체크

→ **Part 2.5에서 이 3가지 DNA 시스템의 기술 옵션을 다룹니다.**

#### 메인 서비스 필수 요소 (패밀리 강제)

A-B-A 패밀리는 다음 3가지 메인 서비스 기술을 **반드시** 포함해야 합니다:

#### 1. IoT 메시징 (MQTT/AMQP) (필수!)
**역할**: 센서 데이터 수집, 명령 전송
**이유**: 반구조화(B) + 밀리초(A)
**선택지**: EMQX, AWS IoT Core, RabbitMQ

#### 2. 시계열 DB (필수!)
**역할**: 센서 데이터 저장, 이력 조회
**이유**: 반구조화(B) + 시계열
**선택지**: InfluxDB, TimescaleDB, DynamoDB

#### 3. Edge Computing (필수!)
**역할**: 로컬 실시간 처리, 긴급 대응
**이유**: 치명적(A) + 밀리초(A)
**선택지**: AWS IoT Greengrass, Azure IoT Edge, K3s

---

## Part 2: 메인 서비스 기술 선택 ⭐⭐⭐

### 2.1 IoT 메시징 선택

**패밀리 요구**:
- 경량 프로토콜 (배터리 제약)
- QoS 보장 (메시지 손실 방지)
- 대규모 연결 (수만~수백만 센서)
- 낮은 레이턴시 (밀리초~초)

---

#### 옵션 1: EMQX (Enterprise)

**핵심 스펙**:
- **연결 처리량**: 500만+ 동시 연결
- **메시지 처리량**: 초당 100만+ 메시지
- **레이턴시**: 밀리초 미만 (단일 홉)
- **프로토콜**: MQTT 3.1/3.1.1/5.0, MQTT-SN, CoAP, LwM2M

**비용**:
- **오픈소스**: 무료 (EMQX Broker)
- **Enterprise**: $5,000~$20,000/년 (노드당)
- **클라우드**: $0.15~$0.30/million messages

**장점**:
- ⚡ 초대규모 확장 (500만+ 연결)
- 🔧 완벽한 MQTT 지원
- 📡 다중 프로토콜 (MQTT, CoAP, LwM2M)
- 💪 고가용성 (클러스터링)
- 🔐 TLS/SSL, 인증/권한

**단점**:
- 💰 Enterprise 고가
- 🧑‍💻 복잡한 운영 (클러스터)
- 📚 학습 곡선
- 🔧 튜닝 필요

**적합한 경우**:
- 산업 IoT (수만~수백만 센서)
- SCADA, 스마트 팩토리
- 높은 신뢰성 필수
- 예산 $20K~$100K /year

**검증 사례**: 중국 제조업, 스마트 시티 프로젝트

---

#### 옵션 2: AWS IoT Core

**핵심 스펙**:
- **연결 처리량**: 무제한 (자동 확장)
- **메시지 처리량**: 사용량 기반
- **레이턴시**: 수십~수백 밀리초
- **프로토콜**: MQTT, MQTT over WebSocket, HTTPS

**비용**:
- **연결 비용**: $0.08/million connection-minutes
- **메시지 비용**: $1/million messages (first 1B/월)
- **예상**: 월 $1,000~$10,000 (중규모)

**장점**:
- 🤖 완전 관리형 (운영 부담 없음)
- 🚀 무제한 확장
- 🔗 AWS 통합 (Lambda, S3, DynamoDB)
- 🔐 강력한 보안 (X.509 인증)
- 📊 내장 규칙 엔진

**단점**:
- 🔒 AWS 종속
- 💰 대규모 시 비용 급증
- 📊 제한적 프로토콜 (MQTT 중심)
- 🌐 글로벌 배포 복잡

**적합한 경우**:
- AWS 중심 조직
- 소규모~중규모 (수만~수십만 센서)
- 빠른 프로토타이핑
- 운영 부담 최소화

**검증 사례**: 스마트 홈, 소규모 공장 자동화

---

#### 옵션 3: RabbitMQ (MQTT 플러그인)

**핵심 스펙**:
- **연결 처리량**: 수만~수십만 연결
- **메시지 처리량**: 초당 3만 메시지
- **레이턴시**: 밀리초~초
- **프로토콜**: MQTT, AMQP, STOMP, HTTP

**비용**:
- **오픈소스**: 무료
- **Self-hosted**: 월 $200~$2,000 (VM 비용)
- **CloudAMQP**: $19~$1,199/월

**장점**:
- 💰 저렴한 비용
- 📚 성숙한 기술
- 🔧 간단한 운영
- 🔌 다양한 프로토콜
- 💪 메시지 라우팅 유연성

**단점**:
- 📉 제한적 확장 (수만 연결)
- ⚡ EMQX 대비 낮은 성능
- 🔧 MQTT 기능 제한 (플러그인)
- 📊 대규모 IoT 부적합

**적합한 경우**:
- 소규모 IoT (수천~수만 센서)
- 레거시 통합 (AMQP)
- 예산 $5K~$30K /year
- 간단한 아키텍처

**검증 사례**: 스타트업 IoT, 빌딩 자동화

---

#### IoT 메시징 비교표

| 항목 | EMQX | AWS IoT Core | RabbitMQ |
|------|------|--------------|----------|
| **연결 수** | 500만+ | 무제한 | 수만 |
| **메시지/초** | 100만+ | 사용량 기반 | ~3만 |
| **레이턴시** | <10ms | 수십~수백ms | 밀리초~초 |
| **비용** | $5K~$20K/년 | $1K~$10K/월 | $200~$2K/월 |
| **운영** | ⚙️⚙️⚙️ 높음 | ⚙️ 낮음 | ⚙️⚙️ 중간 |

**의사결정 가이드**:
```
센서 > 10만? → EMQX
  └─ NO
     ↓
AWS 중심? → AWS IoT Core
  └─ NO
     ↓
센서 < 5만? → RabbitMQ
  └─ NO → AWS IoT Core
```

---

### 2.2 시계열 DB 선택

**패밀리 요구**:
- 빠른 쓰기 (초당 수십만~수백만 포인트)
- 시간 기반 쿼리 최적화
- 압축 (저장 공간 절약)
- 다운샘플링 (Downsampling)

---

#### 옵션 1: InfluxDB (Enterprise)

**핵심 스펙**:
- **쓰기 처리량**: 초당 100만+ 포인트
- **압축**: 10:1 이상
- **레이턴시**: 밀리초 미만 (쓰기)
- **보존 정책**: 자동 다운샘플링

**비용**:
- **오픈소스**: 무료 (InfluxDB OSS)
- **Cloud**: $50~$500/월
- **Enterprise**: $10,000~$50,000/년

**장점**:
- ⚡ 초고속 쓰기
- 🔧 IoT 최적화 (Telegraf 통합)
- 📊 강력한 쿼리 (Flux, InfluxQL)
- 💾 효율적 압축
- 🕐 자동 다운샘플링

**단점**:
- 💰 Enterprise 고가
- 📊 제한적 분산 (클러스터링 Enterprise만)
- 🔧 메모리 사용량 높음
- 📈 대규모 확장 어려움

**적합한 경우**:
- IoT 센서 데이터 (초당 수십만 포인트)
- SCADA, 제조 라인
- 실시간 대시보드
- 예산 $10K~$100K /year

**검증 사례**: Cisco IoT, Salesforce 모니터링

---

#### 옵션 2: TimescaleDB (PostgreSQL 확장)

**핵심 스펙**:
- **쓰기 처리량**: 초당 10만 포인트
- **압축**: Native 압축 (7:1)
- **레이턴시**: <10ms (쓰기)
- **쿼리**: Full SQL 지원

**비용**:
- **오픈소스**: 무료
- **Timescale Cloud**: $50~$500/월
- **Enterprise**: $5,000~$20,000/년

**장점**:
- 🔍 Full SQL 지원
- 📊 복잡한 조인 가능
- 🛠️ PostgreSQL 생태계
- 💰 상대적 저렴
- 🔧 익숙한 운영

**단점**:
- ⚡ InfluxDB 대비 느림
- 📈 확장 제한 (vs 분산 DB)
- 💾 압축률 낮음
- 🔧 튜닝 필요

**적합한 경우**:
- SQL 필수 (복잡한 분석)
- PostgreSQL 팀 역량
- 중소규모 (초당 수만 포인트)
- 예산 $5K~$50K /year

**검증 사례**: 에너지 모니터링, 스마트 빌딩

---

#### 옵션 3: DynamoDB (AWS)

**핵심 스펙**:
- **쓰기 처리량**: 사용량 기반 (무제한)
- **레이턴시**: 단일 자릿수 밀리초
- **확장**: 자동 스케일링
- **TTL**: 자동 데이터 만료

**비용**:
- **On-Demand**: $1.25/million writes
- **Provisioned**: $0.00065/WCU/hour
- **예상**: 월 $500~$5,000

**장점**:
- 🤖 완전 관리형
- 🚀 무제한 확장
- 🔗 AWS 통합
- 💵 사용량 기반 과금
- 🕐 자동 TTL

**단점**:
- 🔒 AWS 종속
- 💰 대규모 시 비용 급증
- 📊 제한적 쿼리 (NoSQL)
- 🔧 시계열 최적화 부족

**적합한 경우**:
- AWS 중심
- 소규모~중규모
- 빠른 프로토타이핑
- 운영 부담 최소화

**검증 사례**: AWS IoT 사용자, 스타트업

---

#### 시계열 DB 비교표

| 항목 | InfluxDB | TimescaleDB | DynamoDB |
|------|----------|-------------|----------|
| **쓰기/초** | 100만+ | 10만 | 사용량 기반 |
| **SQL** | Flux/InfluxQL | ✅ Full SQL | ❌ NoSQL |
| **압축** | 10:1 | 7:1 | N/A |
| **비용** | $10K~$50K/년 | $5K~$20K/년 | $500~$5K/월 |
| **운영** | ⚙️⚙️ 중간 | ⚙️⚙️ 중간 | ⚙️ 낮음 |

**의사결정 가이드**:
```
쓰기 > 10만/초? → InfluxDB
  └─ NO
     ↓
SQL 필수? → TimescaleDB
  └─ NO
     ↓
AWS 중심? → DynamoDB
  └─ NO → InfluxDB
```

---

### 2.3 Edge Computing 선택

**패밀리 요구**:
- 로컬 실시간 처리 (밀리초)
- 오프라인 동작 (네트워크 단절 시)
- 경량 (저전력, 제한된 리소스)
- 클라우드 동기화

---

#### 옵션 1: AWS IoT Greengrass

**핵심 스펙**:
- **레이턴시**: 밀리초급 (로컬)
- **언어**: Python, Node.js, Java, C++
- **배포**: Over-the-Air (OTA)
- **오프라인**: 완전 지원

**비용**:
- **소프트웨어**: 무료
- **디바이스**: $10~$500 (하드웨어)
- **클라우드 연동**: AWS IoT Core 비용

**장점**:
- ⚡ 로컬 실시간 처리
- 🔗 AWS 완벽 통합
- 🤖 Lambda 로컬 실행
- 🔐 강력한 보안 (X.509)
- 📡 오프라인 동작

**단점**:
- 🔒 AWS 종속
- 💰 디바이스 비용 (ARM/x86)
- 🔧 복잡한 설정
- 📊 ML 추론 제한적

**적합한 경우**:
- AWS 중심 IoT
- 중간~고성능 Edge (Raspberry Pi 이상)
- 오프라인 필수
- 예산 $100~$500 per device

**검증 사례**: 석유/가스 리모트 모니터링, 스마트 빌딩

---

#### 옵션 2: Azure IoT Edge

**핵심 스펙**:
- **레이턴시**: 밀리초급 (로컬)
- **언어**: C#, Python, Node.js, Java, C
- **컨테이너**: Docker 기반
- **AI**: Azure ML 로컬 배포

**비용**:
- **소프트웨어**: 무료
- **디바이스**: $10~$500 (하드웨어)
- **클라우드 연동**: Azure IoT Hub 비용

**장점**:
- ⚡ 로컬 AI 추론 (ML 모델)
- 🐳 Docker 컨테이너 (표준)
- 🔗 Azure 통합
- 🔐 보안 모듈 (TPM)
- 📡 오프라인 동작

**단점**:
- 🔒 Azure 종속
- 💰 디바이스 비용
- 🧑‍💻 .NET 편향
- 📊 대규모 관리 복잡

**적합한 경우**:
- Azure 중심 조직
- AI/ML 추론 필요
- Docker 친숙
- 예산 $100~$500 per device

**검증 사례**: 제조업 품질 검사 (AI), 소매 매장 분석

---

#### 옵션 3: K3s (경량 Kubernetes)

**핵심 스펙**:
- **메모리**: 512MB RAM 이상
- **언어**: 모든 컨테이너화 앱
- **배포**: GitOps (Flux, ArgoCD)
- **클라우드**: 멀티 클라우드 지원

**비용**:
- **오픈소스**: 무료
- **디바이스**: $10~$200 (하드웨어)
- **관리**: Rancher (무료/Enterprise)

**장점**:
- 💰 완전 무료 (오픈소스)
- 🌐 멀티 클라우드 (AWS, Azure, GCP)
- 🔧 표준 Kubernetes API
- 🐳 모든 컨테이너 지원
- 📚 풍부한 생태계

**단점**:
- 🧑‍💻 Kubernetes 학습 곡선
- 🔧 직접 운영 필요
- 📊 클라우드 통합 별도 구현
- ⚠️ IoT 최적화 부족

**적합한 경우**:
- 멀티 클라우드 전략
- Kubernetes 팀 역량
- 예산 최소화
- 완전한 제어 필요

**검증 사례**: 엣지 AI 플랫폼, 스마트 시티 게이트웨이

---

#### Edge Computing 비교표

| 항목 | AWS Greengrass | Azure IoT Edge | K3s |
|------|----------------|----------------|-----|
| **레이턴시** | 밀리초 | 밀리초 | 밀리초 |
| **AI 추론** | 제한적 | ✅ Azure ML | ✅ 모든 프레임워크 |
| **오프라인** | ✅ | ✅ | ✅ |
| **비용** | AWS 연동 | Azure 연동 | 무료 |
| **운영** | ⚙️⚙️ 중간 | ⚙️⚙️ 중간 | ⚙️⚙️⚙️ 높음 |

**의사결정 가이드**:
```
AWS 중심? → AWS IoT Greengrass
  └─ NO
     ↓
AI 추론 필요? → Azure IoT Edge
  └─ NO
     ↓
멀티 클라우드? → K3s
  └─ NO → AWS IoT Greengrass
```

---

## Part 2.5: 핵심 DNA 시스템 기술 선택 ⭐⭐⭐

이 패밀리에서 특별히 중요한 DNA 시스템(⭐⭐⭐)에 대한 기술 선택입니다.

### 2.5.1 Type System (DNA #4) - 안전 인증 타입 시스템 ⭐⭐⭐

**패밀리 요구**:
- 런타임 에러 0 목표 (컴파일 타임 검증)
- SIL 2+ 인증 지원
- 메모리 안전성 보장
- 정적 분석 통합
- Null pointer, buffer overflow 완전 방지

---

#### 옵션 1: Rust + RTIC

**핵심 스펙**:
- **메모리 안전성**: 컴파일 타임 보장 (borrow checker)
- **실시간 지원**: RTIC 프레임워크 (Zero-cost abstractions)
- **타겟**: Cortex-M, RISC-V 임베디드
- **인증**: ISO 26262 (자동차), IEC 61508 진행 중

**비용**: 오픈소스 (무료), 도구체인 무료

**장점**:
- 🔧 메모리 안전성 컴파일 타임 보장
- 🔧 Zero-cost abstractions (C 수준 성능)
- 🔧 우선순위 기반 리소스 공유 (RTIC)
- 🔧 활발한 임베디드 생태계 (Embassy, probe-rs)

**단점**:
- ⚠️ SIL 인증 아직 진행 중 (완료 아님)
- ⚠️ 학습 곡선 (borrow checker)
- ⚠️ 레거시 C 코드와 통합 복잡
- ⚠️ 일부 MCU 지원 제한

**적합한 경우**:
- 신규 프로젝트 (레거시 없음)
- SIL 2 미만 또는 인증 불필요
- 팀이 Rust 경험 있음
- 메모리 안전성 최우선

**검증 사례**: Volvo (자동차), Oxide Computer, Arm Pelion

---

#### 옵션 2: Ada/SPARK

**핵심 스펙**:
- **정적 검증**: SPARK 프로버 (수학적 증명)
- **인증**: DO-178C (항공), EN 50128 (철도), IEC 61508 인증 완료
- **타겟**: 모든 주요 MCU, x86, ARM
- **역사**: 40년+ 안전-임계 시스템 검증

**비용**: GNAT Community (무료), GNAT Pro ($10K~$50K/년)

**장점**:
- 🔧 SIL 4까지 인증 완료
- 🔧 DO-178C Level A 인증 (항공)
- 🔧 수학적 증명 가능 (SPARK)
- 🔧 40년 검증된 안전 기록

**단점**:
- ⚠️ 개발자 풀 제한적
- ⚠️ GNAT Pro 고비용 ($10K+/년)
- ⚠️ 현대 라이브러리 생태계 부족
- ⚠️ 학습 자료 제한적

**적합한 경우**:
- SIL 3/4 필수 (항공, 철도, 원자력)
- DO-178C 인증 필수
- 장기 유지보수 (20년+)
- 예산 충분

**검증 사례**: Boeing 787, Airbus A380, 프랑스 TGV

---

#### 옵션 3: C + MISRA + 정적 분석

**핵심 스펙**:
- **표준**: MISRA C:2012 (자동차/산업 표준)
- **인증**: IEC 61508, ISO 26262 광범위 인증
- **도구**: Polyspace, PC-lint, Coverity, PVS-Studio
- **타겟**: 모든 MCU 지원

**비용**: 도구 $5K~$50K/년 (PC-lint $400, Polyspace $20K+)

**장점**:
- 🔧 가장 넓은 MCU 지원
- 🔧 개발자 풀 풍부
- 🔧 레거시 코드 활용 가능
- 🔧 기존 인증 사례 풍부

**단점**:
- ⚠️ 언어 자체 안전성 없음 (도구 의존)
- ⚠️ 정적 분석으로 모든 버그 못 잡음
- ⚠️ MISRA 준수 수동 검토 필요
- ⚠️ 메모리 오류 런타임에 발생 가능

**적합한 경우**:
- 레거시 C 코드 유지보수
- 기존 팀 C 전문성
- 검증된 도구체인 필수
- MCU 지원 범위 우선

**검증 사례**: 자동차 ECU 대부분, 산업 PLC, 의료기기

---

**Type System 의사결정 플로우차트**:
```
SIL 3/4 또는 DO-178C 필수? → Ada/SPARK
  └─ NO
     ↓
신규 프로젝트 + 메모리 안전성 우선? → Rust + RTIC
  └─ NO
     ↓
레거시 C + 넓은 MCU 지원? → C + MISRA
```

---

### 2.5.2 Error Handling (DNA #5) - Fail-Safe 전략 ⭐⭐⭐

**패밀리 요구**:
- 모든 에러 → 안전 모드 전환
- Watchdog 타이머 필수
- 센서 융합 에러 처리
- 복구 불가 시 안전한 셧다운
- 에러 전파 차단

---

#### 옵션 1: Rust Result + Custom Error Types

**핵심 스펙**:
- **에러 모델**: Result<T, E> (강제 처리)
- **전파**: `?` 연산자 (명시적)
- **패닉 처리**: `#[panic_handler]` 커스텀
- **Watchdog**: HAL 통합 (cortex-m, stm32)

**비용**: 오픈소스 (무료)

**장점**:
- 🔧 컴파일 타임 에러 처리 강제
- 🔧 에러 무시 불가능
- 🔧 Zero-cost (런타임 오버헤드 없음)
- 🔧 패닉 → 안전 모드 자동 전환 가능

**단점**:
- ⚠️ 학습 곡선 (Result, Option)
- ⚠️ 기존 C 라이브러리 래핑 필요
- ⚠️ 에러 타입 설계 복잡
- ⚠️ 일부 HAL 미성숙

**적합한 경우**:
- Rust 기반 신규 프로젝트
- 컴파일 타임 안전성 우선
- 팀이 함수형 프로그래밍 경험
- 에러 처리 누락 방지 필수

---

#### 옵션 2: C + Defensive Programming + Watchdog

**핵심 스펙**:
- **패턴**: MISRA C 에러 처리 규칙
- **Watchdog**: 하드웨어 WDT + 소프트웨어 타이머
- **방어**: 어설션, 범위 체크, 센서 크로스 체크
- **복구**: 상태 머신 기반 복구 로직

**비용**: 도구 $1K~$20K/년 (정적 분석 포함)

**장점**:
- 🔧 검증된 패턴 풍부
- 🔧 하드웨어 Watchdog 직접 제어
- 🔧 레거시 코드와 호환
- 🔧 MISRA 준수 도구 지원

**단점**:
- ⚠️ 에러 처리 누락 가능 (컴파일러 미강제)
- ⚠️ 수동 방어 코딩 필요
- ⚠️ 정적 분석 의존
- ⚠️ 런타임 에러 가능

**적합한 경우**:
- 레거시 C 코드베이스
- 검증된 Watchdog 패턴 필요
- MISRA 준수 필수
- 팀 C 전문성

---

#### 옵션 3: Ada Exception + SPARK 계약

**핵심 스펙**:
- **에러 모델**: Ada Exception (구조화된 예외)
- **계약**: SPARK Pre/Post conditions (정적 증명)
- **검증**: 런타임 체크 + 정적 증명 조합
- **복구**: Exception handler 체계

**비용**: GNAT Community (무료), GNAT Pro ($10K+/년)

**장점**:
- 🔧 수학적 에러 부재 증명 (SPARK)
- 🔧 구조화된 예외 처리
- 🔧 Pre/Post condition 강제
- 🔧 런타임 + 정적 검증 조합

**단점**:
- ⚠️ SPARK 증명 복잡
- ⚠️ 예외 오버헤드 (SPARK 미사용 시)
- ⚠️ 개발자 풀 제한적
- ⚠️ 도구 비용

**적합한 경우**:
- SIL 3/4 프로젝트
- 수학적 증명 필수
- Ada 팀 구성 가능
- 장기 유지보수

---

**Error Handling 의사결정 플로우차트**:
```
수학적 에러 부재 증명 필수? → Ada Exception + SPARK
  └─ NO
     ↓
컴파일 타임 에러 처리 강제? → Rust Result
  └─ NO
     ↓
레거시 C + Watchdog? → C Defensive Programming
```

---

### 2.5.3 Resilience (DNA #10) - 생명 안전 중복성 ⭐⭐⭐

**패밀리 요구**:
- N+1 센서/액추에이터 중복
- 5-250ms 페일오버
- 센서 크로스 체크 (Voting)
- 자동 복구 (Self-healing)
- Health Check + 격리

---

#### 옵션 1: 하드웨어 중복 + Voting

**핵심 스펙**:
- **패턴**: Triple Modular Redundancy (TMR)
- **Voting**: 2-out-of-3, 다수결
- **페일오버**: 하드웨어 스위칭 (<1ms)
- **격리**: 물리적 분리 (별도 전원, 별도 회로)

**비용**: 하드웨어 3배 + 설계 $50K~$500K

**장점**:
- 🔧 하드웨어 레벨 안전성
- 🔧 1ms 미만 페일오버
- 🔧 Byzantine Fault Tolerance
- 🔧 SIL 4 달성 가능

**단점**:
- ⚠️ 하드웨어 비용 3배+
- ⚠️ 설계 복잡도 높음
- ⚠️ 전력 소비 증가
- ⚠️ 물리적 공간 필요

**적합한 경우**:
- SIL 3/4 필수
- 예산 충분
- 물리적 공간 여유
- 하드웨어 팀 존재

**검증 사례**: 항공기 비행 제어, 원자력 발전소

---

#### 옵션 2: 소프트웨어 Failover + Circuit Breaker

**핵심 스펙**:
- **패턴**: Primary-Standby, Active-Active
- **Circuit Breaker**: failsafe-rs, 지수 백오프
- **Health Check**: 주기적 Heartbeat
- **페일오버**: 5-50ms (소프트웨어)

**비용**: 추가 하드웨어 $500~$5K + 개발

**장점**:
- 🔧 비용 효율적
- 🔧 유연한 복구 전략
- 🔧 소프트웨어 업데이트 가능
- 🔧 Circuit Breaker로 장애 전파 차단

**단점**:
- ⚠️ 하드웨어 TMR보다 느림 (5-50ms)
- ⚠️ 소프트웨어 버그 가능
- ⚠️ SIL 4 달성 어려움
- ⚠️ 복잡한 상태 관리

**적합한 경우**:
- SIL 2 이하
- 예산 제한
- 소프트웨어 팀 강점
- 유연한 복구 필요

**검증 사례**: 산업 자동화, 스마트 팩토리

---

#### 옵션 3: 클라우드 기반 Redundancy

**핵심 스펙**:
- **패턴**: Edge + Cloud 이중화
- **동기화**: 상태 복제 (MQTT, Kafka)
- **페일오버**: 100-500ms (네트워크 의존)
- **관리**: AWS IoT Greengrass, Azure IoT Edge

**비용**: 클라우드 $100~$1K/월 + Edge 하드웨어

**장점**:
- 🔧 원격 모니터링/관리
- 🔧 자동 스케일링
- 🔧 글로벌 분산
- 🔧 OTA 업데이트

**단점**:
- ⚠️ 네트워크 의존 (오프라인 시 제한)
- ⚠️ 페일오버 느림 (100-500ms)
- ⚠️ 데이터 주권 이슈
- ⚠️ SIL 인증 어려움

**적합한 경우**:
- 비-임계 모니터링
- 원격 관리 필수
- 네트워크 안정적
- SIL 인증 불필요

**검증 사례**: 스마트 빌딩, 원격 자산 모니터링

---

**Resilience 의사결정 플로우차트**:
```
SIL 3/4 + 1ms 미만 페일오버? → 하드웨어 TMR
  └─ NO
     ↓
Edge 로컬 처리 + 유연한 복구? → 소프트웨어 Failover
  └─ NO
     ↓
원격 관리 + 비-임계? → 클라우드 Redundancy
```

---

## Part 3: 도메인 선택 요소 (프로젝트별)

이 요소들은 **패밀리와 무관**하게 프로젝트 요구사항에 따라 선택합니다.

### 3.1 센서 하드웨어

**선택지**:
- **Raspberry Pi 4**: 범용, Linux, Python/C++
- **Arduino**: 저전력, 실시간, C/C++
- **ESP32**: WiFi/BLE, 초저전력, MicroPython
- **산업용 PLC**: Siemens, Allen-Bradley (규제 인증)

**선택 기준**:
- 처리 능력: 복잡한 센서 융합 → Raspberry Pi
- 저전력: 배터리 → Arduino, ESP32
- 산업 표준: 규제 준수 → PLC

**A-B-A 영향**: **큼** - 실시간 처리(A) + 센서 융합(B) 요구  
(Edge Computing 성능 결정)

---

### 3.2 통신 프로토콜

**선택지**:
- **WiFi**: 고대역폭, 짧은 거리, 실내
- **4G/5G**: 이동성, 넓은 범위, 고비용
- **LoRaWAN**: 초저전력, 장거리 (수 km), 저속 (50kbps)
- **Zigbee**: 저전력, 메쉬 네트워크, 짧은 거리

**선택 기준**:
- 레이턴시: 밀리초(A) → WiFi, 4G/5G
- 저전력: 배터리 수명 → LoRaWAN, Zigbee
- 이동성: 차량, 드론 → 4G/5G
- 범위: 공장/건물 → WiFi, Zigbee

**A-B-A 영향**: **매우 큼** - 밀리초(A) 달성 가능 여부  
(WiFi: 5-50ms, 4G: 50-100ms, LoRaWAN: 1-5초)

---

### 3.3 대시보드/시각화

**선택지**:
- **Grafana**: 오픈소스, 시계열, Prometheus 통합
- **Kibana**: Elasticsearch, 로그 중심
- **Power BI**: 엔터프라이즈, Microsoft 생태계
- **Custom Web**: React, D3.js (맞춤형)

**선택 기준**:
- 실시간 모니터링: Grafana (초 단위 갱신)
- 로그 분석: Kibana (ELK Stack)
- 비즈니스 리포트: Power BI (주간/월간)
- 특수 요구사항: Custom Web

**A-B-A 영향**: 최소 (패밀리 무관, 사용자 선호도)

---

### 3.4 클라우드 vs 온프레미스

**선택지**:
- **클라우드**: AWS IoT, Azure IoT (확장성, 관리 편의)
- **하이브리드**: Edge + 클라우드 (로컬 처리 + 중앙 집계)
- **온프레미스**: 완전 자체 호스팅 (데이터 주권, 규제)

**선택 기준**:
- 밀리초 응답(A): 하이브리드 또는 온프레미스 (네트워크 지연 회피)
- 규제: 데이터 주권, SIL 인증 → 온프레미스
- 확장성: 수십만 센서 → 클라우드

**A-B-A 영향**: **큼** - 치명적 실패(A) + 밀리초(A) 요구  
(클라우드 왕복 100-500ms → 로컬 처리 필수)

---

## Part 4: Stage 2 통합

### 4.1 Layer 3 제약 반영 예시

**시나리오**: 제조 공장 안전 시스템

**Layer 3 제약 발견**:
- 규제: SIL 2 인증 필수 (IEC 61508)
- 네트워크: 공장 WiFi 불안정 (패킷 손실 5%)
- 예산: $100K/년 (전체)
- 기존 시스템: Siemens PLC (Profinet)

**기술 선택 영향**:
```
IoT 메시징:
- EMQX (선호) → RabbitMQ
- 이유: 예산 제약, Profinet 연동

시계열 DB:
- InfluxDB (선호) → TimescaleDB
- 이유: SQL 필수 (규제 보고), 예산

Edge Computing:
- AWS Greengrass (불가능) → K3s
- 이유: 공장 내 온프레미스, 오프라인
```

---

### 4.2 충돌 해결 예시

**NFR 목표 vs Layer 3 제약**:

**충돌 1**: 밀리초 응답 A + WiFi 불안정
- **NFR**: 450ms 미만 경보 응답
- **제약**: 공장 WiFi 불안정 (패킷 손실 5%)
- **해결**: Edge Computing 필수 (로컬 처리) + 유선 백업
- **트레이드오프**:
  - ✅ 로컬 처리로 50ms 응답 달성 (WiFi 독립)
  - ✅ 네트워크 장애 시에도 작동
  - ⚠️ Edge 디바이스 비용 증가 ($200~$500/센서)
  - ⚠️ 유선 백업 설치 비용 ($50~$100/센서)
  - ⚠️ 유지보수 복잡도 증가 (센서별 업데이트)

---

**충돌 2**: 치명적 실패 A + 예산 제약
- **NFR**: SIL 2 인증 필수 (안전 규제)
- **제약**: 예산 $100K/년 (EMQX Enterprise, InfluxDB Enterprise 불가)
- **해결**: 오픈소스 스택 (RabbitMQ + TimescaleDB + K3s) + 외부 인증 비용
- **트레이드오프**:
  - ⚠️ 확장성 제한 (수만 센서까지, 수백만 불가)
  - ⚠️ 고가용성 구성 복잡 (직접 클러스터링)
  - ✅ 소프트웨어 비용 $50K/년 → $10K/년 (80% 절감)
  - ✅ SIL 2 인증 $30K (외부 인증 기관)
  - ✅ 총 예산 $40K/년 (목표 $100K 내)

---

**충돌 3**: 센서 융합 B + 레거시 PLC
- **NFR**: JSON 센서 데이터 (온도, 습도, 진동 융합)
- **제약**: Siemens PLC (Profinet 바이너리 프로토콜)
- **해결**: Edge Gateway 변환 (Profinet → MQTT/JSON)
- **트레이드오프**:
  - ⚠️ 레이턴시 추가 10-50ms (변환 오버헤드)
  - ⚠️ Gateway 단일 장애 지점 (SPOF)
  - ⚠️ Gateway 비용 $2,000~$5,000
  - ✅ 레거시 PLC 활용 (교체 불필요)
  - ✅ 표준 MQTT 인프라 구축
  - ✅ 향후 센서 추가 용이

**추가 해결**: Gateway 이중화 (Active-Standby)  
**추가 비용**: $3,000~$6,000 (Gateway 2대)

---

### 4.3 ADR 작성 준비

**선택한 기술 스택 정리**:
```
Bootstrap 필수:
✅ IoT 메시징: RabbitMQ (MQTT 플러그인)
✅ 시계열 DB: TimescaleDB
✅ Edge Computing: K3s (온프레미스)

도메인 선택:
✅ 센서: Raspberry Pi 4 + DHT22 + MCP3008
✅ 통신: WiFi (주) + 유선 Ethernet (백업)
✅ 대시보드: Grafana + Prometheus
```

**ADR 작성 대상**:
1. IoT 메시징 선택 (EMQX vs RabbitMQ)
2. 시계열 DB 선택 (InfluxDB vs TimescaleDB)
3. Edge Computing 전략 (Greengrass vs K3s)
4. 네트워크 이중화 방안 (WiFi + 유선)
5. SIL 2 인증 경로

---

## 📚 참고 자료

### IoT 메시징 벤치마크
- [EMQX Performance](https://www.emqx.com/en/products/emqx/performance)
- [AWS IoT Core Limits](https://docs.aws.amazon.com/general/latest/gr/iot-core.html)

### 시계열 DB 벤치마크
- [InfluxDB Performance](https://www.influxdata.com/influxdb-performance/)
- [TimescaleDB Benchmark](https://docs.timescale.com/timescaledb/latest/overview/how-it-works/)

### Edge Computing
- [AWS IoT Greengrass](https://aws.amazon.com/greengrass/)
- [Azure IoT Edge](https://azure.microsoft.com/en-us/products/iot-edge/)
- [K3s](https://k3s.io/)

### 산업 표준
- [IEC 61508: SIL](https://en.wikipedia.org/wiki/IEC_61508)
- [ISA-95: 제조 표준](https://www.isa.org/standards-and-publications/isa-standards/isa-standards-committees/isa95)

### 검증 사례
- [IoT 긴급 경보 시스템](https://www.fcc.gov/emergency-alert-system-eas)
- [SCADA 시스템](https://en.wikipedia.org/wiki/SCADA)

---

**마지막 업데이트**: 2025-11-12  
**다음 검토**: 2026-02-12 (기술 스택 업데이트 반영)


================================================================================
