# DNA Stage 1-9 가이드 - 각 Stage별 상세 실행 가이드
# 생성일: 2025-12-10
# 포함된 파일 수: 9

================================================================================

📄 FILE: 01G-00_core_definition_guide.md
--------------------------------------------------------------------------------

# Stage 1: 핵심 정의 가이드 (Core Definition Guide)

> **목적**: 시스템의 본질적 특성을 파악하여 7가지 패밀리 중 하나로 분류
>
> **버전**: v4.1 (2025-12-03)
>
> - v4.0 (2025-12-03): Gemini 연구 기반 10가지 ADQ 체계 도입, 01_DNA_METHODOLOGY_DETAILED.md 기준 전면 재작성
> 
> - v3.0: 3-Layer Decision Tree 도입

---

## 📚 이 가이드의 위치

```
DNA 방법론 문서 체계:

Tier 1: 00_CORE_METHODOLOGY.md (전체 맥락)
           ↓
Tier 2: 01_DNA_METHODOLOGY_DETAILED.md (상세 원리)
           ↓
Tier 3: 이 문서 (Stage1 실행 가이드) ← 지금 여기!
```

**참조 문서**:
- **원리 이해**: `01_DNA_METHODOLOGY_DETAILED.md` **Part 3**
- **패밀리별 기술**: `./family-tech-matrix/` (8개 파일)
  - `00_overview.md`
  - `01_ultra_high_frequency_trading_tech_options.md`
  - `02_transaction_crud_tech_options.md`
  - `03_collaboration_sync_tech_options.md`
  - `04_search_recommendation_tech_options.md`
  - `05_real_time_streaming_tech_options.md`
  - `06_analytics_batch_tech_options.md`
  - `07_safety_critical_iot_tech_options.md`

- **실전 사례**: `./manual-cases/02E-01_stock_trading_case.md`

---

## 📥 입력 문서

**없음** - Stage 1은 프로젝트의 시작점입니다.

**필요한 것**:
- 프로젝트 아이디어 (간단한 설명)
- 해결하고자 하는 문제
- 기본적인 요구사항 (선택적)

---

## 📤 출력 문서

### 필수 산출물 (3개)

| 파일명 | 내용 | 다음 Stage 전달 |
|--------|------|----------------|
| `01C-01_family_classification.md` | 패밀리 코드 + 10가지 ADQ 답변 | ✅ 패밀리 코드 (예: B-C-A) |
| `01C-02_nfr_profile.md` | NFR 우선순위 프로파일 | ✅ NFR 프로파일 (예: A-B-B-A) |
| `01D-01_tech_candidates.md` | 기술 후보군 (family-tech-matrix 기반) | ✅ 기술 방향 |

---

## Part 0: 핵심 기능 파악 ⭐

프로젝트의 시작은 아이디어나 문제 인식에서 출발합니다. 
먼저 **가장 근원적인 기능**과 **비즈니스 목적**을 파악해야 합니다.

### Q0: 이 시스템은 무엇을 하기 위한 시스템인가?

**작성 원칙**:
- 가장 **원자적인 기능(핵심기능)**만 파악
- **구현 방식**을 별개의 기능으로 보지 않음
- **비즈니스 목적**으로 구분

**예시**:
```
❌ 잘못된 구분:
   - 수동 거래 (기능 1)
   - 자동 거래 (기능 2)

✅ 올바른 구분:
   - 거래 (핵심기능)
     ├─ 구현 방식 A: 수동
     └─ 구현 방식 B: 자동
   - 비즈니스 목적: 계약 체결로 법적 소유권 이전 

✅ 다른 예시:
   - AI 챗봇 + 외부메모리 (X) → AI 외부메모리 (CRUD) (O)
   - 일반 검색 + AI 검색 (X) → 검색 (O)
```

---

## Part 1: 10가지 ADQ (Architecture-Driving Questions)

> **핵심 원칙**: "질문이 결론을 이끈다"
>
> 10가지 질문에 답하면 패밀리와 NFR이 자연스럽게 도출됩니다.


### 카테고리 A: 비즈니스 가치

#### Q1: "이 시스템이 1시간 동안 멈추면 어떤 일이 일어나나요?"

**목적**: 실패의 치명도 판단 → Layer 1 결정

| 답변 | 의미 | 예시 |
|------|------|------|
| **A (치명적)** | 금전/인명/법적 피해 | 주식 거래: "1시간 정지 = 수억 원 손실" |
| **B (심각)** | 비즈니스 영향, 고객 불만 | 병원 예약: "환자 대기, 심각한 불편" |
| **C (경미)** | 불편함, 대체 수단 존재 | 블로그: "불편하지만 치명적이진 않음" |

---

#### Q2: "고객이 이 시스템에서 가장 중요하게 생각하는 것은?"

**목적**: 핵심 품질 속성 식별 → NFR 우선순위

| 답변 | 의미 | 전형적 시스템 |
|------|------|-------------|
| **속도** | "빨라야 함", "즉시 응답" | 검색 엔진 (0.1초 내 결과) |
| **정확성** | "틀리면 안 됨", "100% 정확" | 은행 이체 (1원도 틀리면 안 됨) |
| **가용성** | "항상 접속 가능", "24/7" | 채팅 앱 |
| **보안** | "절대 유출 안 됨" | 의료 시스템 |
| **비용** | "저렴해야 함" | 내부 도구 |

---

### 카테고리 B: 사용자/규모

#### Q3: "사용자가 이 시스템에서 가장 자주 하는 행동 3가지는?"

**목적**: 핵심 사용자 여정 파악 → Layer 3 참고

**답변 형식**:
```
1. [행동 1] - 빈도: 일 N회, 소요시간: N초
2. [행동 2] - 빈도: 일 N회, 소요시간: N초
3. [행동 3] - 빈도: 일 N회, 소요시간: N초
```

**예시 (이커머스)**:
```
1. 상품 검색 - 일 100회, 1초 이내
2. 상품 상세 보기 - 일 50회, 3초 이내
3. 주문하기 - 일 5회, 30초 이내
```

---

#### Q4: "동시에 이 시스템을 사용하는 사용자는 얼마나 되나요?"

**목적**: 확장성 요구사항 파악

| 답변 | 규모 | 아키텍처 영향 |
|------|------|-------------|
| **A (소규모)** | 10-100명 | 단일 서버 가능 |
| **B (중규모)** | 100-10,000명 | 수평 확장 고려 |
| **C (대규모)** | 10,000-100,000명 | 분산 아키텍처 필수 |
| **D (초대규모)** | 100,000명+ | 글로벌 분산 |

**추가 질문**:
- 피크 시간대는? (출퇴근, 점심, 이벤트)
- 성장 예상치는? (월 N% 증가)

---

### 카테고리 C: 데이터/의존성

#### Q5: "이 시스템에서 다루는 데이터 중 가장 민감한 것은?"

**목적**: 보안 수준 결정 → Layer 2, NFR

| 답변 | 데이터 유형 | 규제 연결 |
|------|-----------|----------|
| **A (극비)** | 금융, 의료, 생체 | PCI-DSS, HIPAA |
| **B (민감)** | 개인정보, 위치 | GDPR, 개인정보보호법 |
| **C (내부)** | 비즈니스 데이터 | 내부 정책 |
| **D (공개)** | 공개 콘텐츠 | 없음 |

---

#### Q6: "데이터는 어디서 오나요? (원천)"

**목적**: 통합 복잡도 파악 → Layer 2

| 답변 | 원천 | 예시 |
|------|------|------|
| **자체 생성** | 사용자 입력, 시스템 생성 | 게시글, 주문 |
| **외부 API** | 증권사, 결제, 지도 | KIS API, Stripe |
| **데이터 피드** | 실시간 시세, 뉴스 | WebSocket 피드 |
| **배치 수집** | 일별 정산, 크롤링 | ETL 파이프라인 |
| **사용자 업로드** | 파일, 이미지 | S3 업로드 |

---

#### Q7: "데이터는 얼마나 오래 보관해야 하나요?"

**목적**: 저장소 설계, 아카이빙 전략

| 답변 | 기간 | 저장소 전략 |
|------|------|-----------|
| **실시간** | 현재 상태만 | 캐시, 세션 |
| **단기** | 7-30일 | 로그, 임시 |
| **중기** | 1-5년 | 거래 내역, 활동 |
| **장기** | 5년+ | 법적 보관, 감사 |
| **영구** | 삭제 불가 | 블록체인, 아카이브 |

---

### 카테고리 D: 운영/환경

#### Q8: "이 시스템이 연동해야 하는 외부 시스템은?"

**목적**: 의존성 파악, 장애 전파 범위

**답변 형식**:
| 시스템 | 연동 방식 | 의존도 | 대체 가능 |
|--------|----------|--------|----------|
| KIS API | REST | 필수 | X |
| Slack | Webhook | 선택 | O (이메일) |

---

#### Q9: "시스템은 어디에 배포되나요?"

**목적**: 인프라 제약 파악

| 답변 | 환경 | 고려사항 |
|------|------|---------|
| **클라우드** | AWS, GCP, Azure | 관리형 서비스 활용 |
| **온프레미스** | 자체 서버, IDC | 직접 운영 |
| **하이브리드** | 클라우드 + 온프레미스 | 연결 복잡도 |
| **엣지** | IoT, CDN, 로컬 | 지연시간 최적화 |

---

#### Q10: "시스템은 얼마나 자주 변경되나요?"

**목적**: 유지보수 전략, 배포 파이프라인

| 답변 | 빈도 | CI/CD 요구 |
|------|------|-----------|
| **초고빈도** | 일 수회 | 완전 자동화 필수 |
| **고빈도** | 주 1-2회 | 자동화 권장 |
| **중빈도** | 월 1-2회 | 반자동화 |
| **저빈도** | 분기 1회 | 수동 가능 |

---


## Part 2: 3-Layer Decision Tree → 패밀리 코드 도출

10가지 ADQ 답변을 3개 Layer로 매핑하여 패밀리 코드를 도출합니다.

### ADQ → Layer 매핑

```
Layer 1 (실패 영향): Q1 기반
├─ A: 치명적 (금전/인명/법적)
└─ B: 점진적 (불편함, 재시도 가능)

Layer 2 (데이터 형태): Q5, Q6 기반
├─ A: 구조화 (고정 스키마, RDBMS)
├─ B: 반구조화 (JSON, 유연한 스키마)
└─ C: 비구조화 (스트림, 로그, 자연어)

Layer 3 (응답 시점): Q3 기반
├─ A: 밀리초 (<100ms, 실시간)
├─ B: 초 단위 (1-10초, 대화형)
└─ C: 배치 (분~시간)
```

### 7가지 패밀리

| 코드 | 패밀리명 | 특성 | 대표 사례 | 기술 매트릭스 |
|------|---------|------|----------|-------------|
| **A-A-A** | 초고속 거래 | 치명적, 구조화, 마이크로초 | NASDAQ (14μs), HFT | `01_ultra_high_frequency_trading_tech_options.md` |
| **A-A-B** | 트랜잭션/CRUD | 치명적, 구조화, 초 | Amazon 주문, Stripe | `02_transaction_crud_tech_options.md` |
| **B-A-A** | 협업/동기화 | 점진적, 구조화, 밀리초 | Google Docs, Figma | `03_collaboration_sync_tech_options.md` |
| **B-B-B** | 검색/추천 | 점진적, 반구조화, 초 | Elasticsearch, AI 외부메모리 | `04_search_recommendation_tech_options.md` |
| **B-C-A** | 실시간 스트리밍 | 점진적, 비구조화, 밀리초 | Netflix, Uber GPS | `05_real_time_streaming_tech_options.md` |
| **B-A-C** | 분석/배치 | 점진적, 구조화, 배치 | Snowflake, BigQuery | `06_analytics_batch_tech_options.md` |
| **A-B-A** | 안전-임계 IoT | 치명적, 반구조화, 밀리초 | SCADA, 의료기기 | `07_safety_critical_iot_tech_options.md` |

### 패밀리 선택 플로우차트

```
시작: 프로젝트 아이디어
  ↓
[Q1] 1시간 멈추면?
  ├─ 금전/인명/법적 손실 → A (치명적)
  └─ 불편함, 재시도 가능 → B (점진적)
       ↓
[Q5, Q6] 데이터 형태는?
  ├─ 고정 스키마, 관계형 → A (구조화)
  ├─ JSON, 유연한 스키마 → B (반구조화)
  └─ 이벤트, 로그, 스트림 → C (비구조화)
       ↓
[Q3] 응답 속도는?
  ├─ 즉시 (<100ms) → A (밀리초)
  ├─ 기다림 (1-10초) → B (초)
  └─ 나중에 (분~시간) → C (배치)
       ↓
패밀리 코드 확정! (예: B-C-A)
  ↓
해당 패밀리 기술 매트릭스 참고
→ ./family-tech-matrix/05_real_time_streaming_tech_options.md
```

---

## Part 3: NFR 프로파일 도출

### NFR 5가지 품질 속성 (SEI Quality Attributes 기반)

Q1, Q2, Q3, Q4, Q5 답변을 기반으로 NFR 프로파일을 도출합니다.

```
NFR 프로파일: [정확성]-[속도]-[가용성]-[보안]-[비용]

예: A-B-A-A-B
├─ 정확성: A (100% 정확해야 함)
├─ 속도: B (1초 이내면 충분)
├─ 가용성: A (99.9%+ 가동률)
├─ 보안: A (극비 수준)
└─ 비용: B (중간 예산)
```

### 각 속성 등급 기준

| 속성 | A 등급 | B 등급 | C 등급 | 근거 ADQ |
|------|--------|--------|--------|----------|
| **정확성** | 100% 정확 필수 | 99%+ 허용 | 95%+ 허용 | Q2 |
| **속도** | <100ms 실시간 | <1초 준실시간 | 배치 허용 | Q3 |
| **가용성** | 99.9%+ (연 8.7시간 이하 장애) | 99%+ | 95%+ | Q1 |
| **보안** | 극비 (금융, 의료) | 민감 (개인정보) | 공개 가능 | Q5 |
| **비용** | 무제한 | 중간 (예산 내) | 최소화 | 예산 제약 |

### 컨텍스트 정보 (별도 기록)

NFR 프로파일과 별도로, 환경 조건을 기록합니다:

| 항목 | 값 예시 | 근거 ADQ |
|------|---------|----------|
| **규모** | 중규모 (10만 사용자) | Q4 |
| **최신성** | 실시간 (<100ms) | Q3 |
| **데이터량** | 일 100만 건 | Q7 |
| **보관 기간** | 5년 | Q7 |

### NFR 충돌 패턴 감지 ⚠️

**5차원 프로파일에서 충돌 패턴 식별**:

| 충돌 패턴 | 조건 | 이론적 근거 | 해결 방향 |
|----------|------|------------|----------|
| **정확성 vs 속도** | 둘 다 A | CAP Theorem (C vs Latency) | 쓰기=동기, 읽기=캐시 |
| **가용성 vs 정확성** | 둘 다 A | CAP Theorem (A vs C) | 정상=둘 다, 장애=정확성 우선 |
| **속도 vs 보안** | 둘 다 A | 암호화 오버헤드 | 인증 후 고속 처리 |
| **가용성 vs 비용** | A + C | 고가용성=고비용 | 중요 컴포넌트만 HA |

⚠️ **충돌 발견 시**: Stage 2 Part 2에서 트레이드오프 결정 필수!

---


## 📋 템플릿

### 01C-01_family_classification.md 템플릿

```markdown
# 패밀리 분류 문서

**프로젝트**: [프로젝트명]
**작성일**: [YYYY-MM-DD]
**작성자**: [이름]

---

## Part 0: 핵심 기능

### Q0: 존재 이유
- **핵심 기능**: [기능명]
- **비즈니스 목적**: [목적]
- **구현 방식들**: [A, B, C...]

---

## Part 1: 10가지 ADQ 답변

### 카테고리 A: 비즈니스 가치

**Q1: 1시간 멈추면?**
- 답변: [A/B/C]
- 이유: [구체적 설명]

**Q2: 고객이 가장 중요하게 생각하는 것?**
- 답변: [속도/정확성/가용성/보안/비용]
- 이유: [구체적 설명]

### 카테고리 B: 사용자/규모

**Q3: 가장 자주 하는 행동 3가지?**
1. [행동 1] - 빈도: 일 N회, 소요시간: N초
2. [행동 2] - 빈도: 일 N회, 소요시간: N초
3. [행동 3] - 빈도: 일 N회, 소요시간: N초

**Q4: 동시 사용자 규모?**
- 답변: [A/B/C/D]
- 피크 시간대: [시간]
- 성장 예상: [월 N%]

### 카테고리 C: 데이터/의존성

**Q5: 가장 민감한 데이터?**
- 답변: [A/B/C/D]
- 데이터 유형: [구체적 데이터]
- 관련 규제: [규제명]

**Q6: 데이터 원천?**
- [ ] 자체 생성
- [ ] 외부 API: [API명]
- [ ] 데이터 피드: [피드 유형]
- [ ] 배치 수집
- [ ] 사용자 업로드

**Q7: 데이터 보관 기간?**
- 답변: [실시간/단기/중기/장기/영구]
- 이유: [법적 요건 등]

### 카테고리 D: 운영/환경

**Q8: 연동 외부 시스템?**
| 시스템 | 연동 방식 | 의존도 | 대체 가능 |
|--------|----------|--------|----------|
| [시스템1] | [방식] | [필수/선택] | [O/X] |

**Q9: 배포 환경?**
- 답변: [클라우드/온프레미스/하이브리드/엣지]
- 상세: [AWS/GCP 등]

**Q10: 변경 빈도?**
- 답변: [초고빈도/고빈도/중빈도/저빈도]
- CI/CD 요구: [수준]

---

## Part 2: 패밀리 코드 도출

### Layer 매핑
- Layer 1 (Q1 → 실패 영향): [A/B]
- Layer 2 (Q5,Q6 → 데이터 형태): [A/B/C]
- Layer 3 (Q3 → 응답 시점): [A/B/C]

### 📌 패밀리 코드: [X-X-X]
### 📌 패밀리명: [패밀리 이름]

---

## Part 3: 기술 방향

**참조**: `./family-tech-matrix/[해당 파일].md`

### 필수 기술 방향
- ✅ [방향 1]
- ✅ [방향 2]
- ✅ [방향 3]

### 기술 후보군
- [기술 1], [기술 2], [기술 3]
```

---

### 01C-02_nfr_profile.md 템플릿

```markdown
# NFR 프로파일 문서

**프로젝트**: [프로젝트명]
**작성일**: [YYYY-MM-DD]

---

## NFR 5가지 품질 속성 (SEI Quality Attributes 기반)

| 속성 | 등급 | 의미 | 근거 (ADQ) |
|------|------|------|-----------|
| **정확성** | [A/B/C] | [100% 정확 / 99%+ / 95%+] | Q2: [이유] |
| **속도** | [A/B/C] | [<100ms / <1초 / 배치] | Q3: [이유] |
| **가용성** | [A/B/C] | [99.9%+ / 99%+ / 95%+] | Q1: [이유] |
| **보안** | [A/B/C] | [극비 / 민감 / 공개] | Q5: [이유] |
| **비용** | [A/B/C] | [무제한 / 중간 / 최소화] | 예산: [금액] |

### 📌 NFR 프로파일: [X-X-X-X-X]

---

## 컨텍스트 정보

| 항목 | 값 | 근거 (ADQ) |
|------|-----|-----------|
| 규모 | [소/중/대/초대규모] | Q4: [동시 사용자 수] |
| 최신성 | [실시간/준실시간/배치] | Q3: [사용자 기대] |
| 데이터량 | [일 N건] | Q7: [추정 근거] |
| 보관 기간 | [N년] | Q7: [법적/비즈니스 요건] |

---

## 충돌 패턴 분석

### 잠재적 충돌 체크
- [ ] 정확성 A + 속도 A → CAP Theorem 충돌 가능
- [ ] 가용성 A + 정확성 A → CAP Theorem 충돌 가능
- [ ] 속도 A + 보안 A → 암호화 오버헤드
- [ ] 가용성 A + 비용 C → 고가용성=고비용

### 발견된 충돌
| 충돌 | 설명 | Stage 2 분석 필요? |
|------|------|-------------------|
| [충돌 1] | [설명] | ✅/❌ |
| [충돌 2] | [설명] | ✅/❌ |

### Stage 2 전달 사항
- [Stage 2에서 상세 분석 필요한 충돌 목록]
```

---

### 01D-01_tech_candidates.md 템플릿

```markdown
# 기술 후보군 문서

**프로젝트**: [프로젝트명]
**작성일**: [YYYY-MM-DD]
**패밀리 코드**: [X-X-X]

---

## 패밀리 기반 기술 방향

**참조**: `./family-tech-matrix/[해당 파일].md`

### 이 패밀리의 필수 특성
- ✅ [특성 1] (예: ACID 트랜잭션 필수)
- ✅ [특성 2] (예: 실시간 처리)
- ✅ [특성 3] (예: 강한 일관성)

---

## 기술 후보군

### 데이터베이스
| 후보 | 장점 | 단점 | 적합도 |
|------|------|------|--------|
| [DB 1] | [장점] | [단점] | ⭐⭐⭐ |
| [DB 2] | [장점] | [단점] | ⭐⭐ |
| [DB 3] | [장점] | [단점] | ⭐ |

### 프레임워크
| 후보 | 장점 | 단점 | 적합도 |
|------|------|------|--------|
| [FW 1] | [장점] | [단점] | ⭐⭐⭐ |
| [FW 2] | [장점] | [단점] | ⭐⭐ |

### 메시징/캐시
| 후보 | 장점 | 단점 | 적합도 |
|------|------|------|--------|
| [기술 1] | [장점] | [단점] | ⭐⭐⭐ |
| [기술 2] | [장점] | [단점] | ⭐⭐ |

---

## Stage 2 검토 필요 사항

- [ ] [후보 1] vs [후보 2] 성능 비교
- [ ] [기술 X] 팀 역량 확인
- [ ] [기술 Y] 비용 분석
```

---

## ✅ Stage 1 완료 체크리스트

```
□ Part 0: 핵심 기능 파악 완료
□ Part 1: 10가지 ADQ 모두 답변
□ Part 2: 패밀리 코드 도출 (X-X-X)
□ Part 3: NFR 프로파일 도출 (X-X-X-X-X)
□ 산출물 생성:
  □ 01C-01_family_classification.md
  □ 01C-02_nfr_profile.md
  □ 01D-01_tech_candidates.md (family-tech-matrix 참조)
□ 충돌 패턴 기록 (있는 경우)
```

---

## 🔜 다음 단계

### Stage 1 → Stage 2 전달 사항

| 항목 | 예시 | Stage 2에서 사용 |
|------|------|----------------|
| 패밀리 코드 | B-C-A | 기술 스택 결정 기준 |
| 핵심 기능 | 거래 | 도메인 설계 기준 |
| NFR 프로파일 | A-B-B-A | 트레이드오프 결정 |
| 기술 후보군 | Kafka, Redis, PostgreSQL | 비교 평가 대상 |
| 충돌 패턴 | 속도 vs 정확성 | Stage 2에서 해결 |

### Stage 2에서 할 일
- 🔄 외부 제약 상세 조사 (API 비교, 법규 등)
- 🔄 충돌 패턴 해결 방안 도출
- 🔄 기술 스택 최종 확정
- 🔄 결정 요소 목록 작성 (ADR 준비)

**다음 문서**: `02G-00_environment_constraints_guide.md`

---

## 📚 참고 문서

| 문서 | 용도 |
|------|------|
| `01_DNA_METHODOLOGY_DETAILED.md` Part 3 | 10가지 ADQ 상세 원리 |
| `./family-tech-matrix/*.md` | 7가지 패밀리별 기술 선택 |
| `./02E-01_stock_trading_case.md` | 실전 사례 (주식 거래 플랫폼) |
| `./standards/01_STAGE_STRUCTURE.md` | Stage 간 연결 구조 |

---

**버전 이력**:
- v4.0 (2025-12-03): Gemini 연구 기반 10가지 ADQ 체계 도입, 01_DNA_METHODOLOGY_DETAILED.md 기준 전면 재작성
- v3.0 (2025-11-12): 3-Layer Decision Tree 도입
- v2.0 (2025-11-11): 초기 버전


================================================================================

📄 FILE: 02G-00_environment_constraints_guide.md
--------------------------------------------------------------------------------

# Stage 2: 환경 제약 가이드 (Environment Constraints Guide)

> **목적**: Stage 1의 패밀리/NFR이 현실 환경에서 구현 가능한지 확인하고, 충돌 발견 시 트레이드오프 결정
>
> **버전**: v4.1 (2025-12-03)
>
> - v4.0 (2025-12-03): Gemini 연구 기반 전면 재작성, 01_DNA_METHODOLOGY_DETAILED.md 기준
> - v3.0 (2025-11-14): Stage 2 구조 확립

---

## 📚 이 가이드의 위치

```
DNA 방법론 문서 체계:

Tier 1: 00_CORE_METHODOLOGY.md (전체 맥락)
           ↓
Tier 2: 01_DNA_METHODOLOGY_DETAILED.md (상세 원리)
           ↓
Tier 3: 이 문서 (Stage 2 실행 가이드) ← 지금 여기!
```

**참조 문서**:
- **원리 이해**: `01_DNA_METHODOLOGY_DETAILED.md` Part 3.2
- **실전 사례**: `./02E-01_stock_trading_case.md`

---

## 📥 입력 문서

### Stage 1에서 전달받는 것

| 파일 | 핵심 내용 | 이 Stage에서 사용 |
|------|----------|-----------------|
| `01C-01_family_classification.md` | 패밀리 코드, 10가지 ADQ 답변 | Layer 3 목표 확인 |
| `01C-02_nfr_profile.md` | NFR 프로파일 | 충돌 패턴 분석 기준 |
| `01D-01_tech_candidates.md` | 기술 후보군 | 기술 스택 결정 입력 |

---

## 📤 출력 문서

### 필수 산출물 (3개)

| 파일명 | 내용 | 다음 Stage 전달 |
|--------|------|----------------|
| `02C-01_external_constraints.md` | 외부 제약 조사 결과 | ✅ API, 규제, 인프라 제약 |
| `02C-02_conflict_patterns.md` | 충돌 패턴 분석 | ✅ 트레이드오프 결정 |
| `02D-01_tech_stack.md` | 기술 스택 최종 결정 | ✅ ADR 작성 기반 |

---

## 🎯 Stage 2가 필요한 이유

> **"이상과 현실 사이의 간극 파악"**

Stage 1에서 결정한 패밀리와 NFR은 **이상적 목표**입니다.
Stage 2에서는 **현실의 제약**을 조사하여 충돌을 발견하고 해결합니다.

```
예시: 주식 거래 플랫폼

Stage 1 결정:
├─ 패밀리: A-A-B (트랜잭션/CRUD)
├─ NFR 프로파일: A-B-B-A (정확성, 중규모, 민감, 실시간)
└─ 목표: "100개 조건을 실시간 감시"

Stage 2 조사:
├─ 한국투자증권 API: 초당 20건 제한 ❌
├─ WebSocket: 최대 41개 종목 ❌
└─ 현실: "100개 동시 감시 불가능!"

충돌 발견! → 트레이드오프 필요
├─ 옵션 A: 감시 종목 41개로 축소
├─ 옵션 B: Polling + WebSocket 하이브리드
└─ 옵션 C: 목표 조정 (초단위 → 분단위)
```

---


## Part 1: 외부 제약 조사

Stage 1의 Q8-Q10 답변을 심화 조사합니다.

### 외부 제약 조사 체크리스트

#### 1. API/연동 제약 (Q8 심화)

```
조사 항목:
[ ] 사용할 외부 API 목록
[ ] 각 API의 호출 제한 (rate limit)
[ ] 인증 방식 (OAuth, API Key, 인증서)
[ ] 응답 시간 SLA
[ ] 장애 시 대응 방안
[ ] 문서화 수준 및 지원 품질
```

**작성 예시**:
```markdown
## API 제약 조사: 증권 거래 API

| 항목 | 한국투자증권 | 키움증권 |
|------|------------|---------|
| 호출 제한 | 실전 20건/초, 모의 2건/초 | 5건/초 |
| 인증 방식 | OAuth 2.0 + 앱키 | HTS ID/PW |
| 평균 응답 | 200-400ms | 300-600ms |
| WebSocket | ✅ (41개 종목) | ❌ |
| SLA | 99.9% | 99.5% |
```

---

#### 2. 규제/법적 제약

```
조사 항목:
[ ] 적용되는 법규 목록
[ ] 데이터 보관 요건 (기간, 형식)
[ ] 감사 로그 요건
[ ] 암호화 요건
[ ] 지역 제한 (데이터 거주지)
[ ] 인증/면허 요건
```

**산업별 주요 규제**:

| 산업 | 주요 규제 | 핵심 요건 |
|------|----------|----------|
| **금융** | 전자금융거래법, PCI-DSS | 거래 기록 5년, 이상거래 탐지 |
| **의료** | HIPAA, 개인정보보호법 | PHI 암호화, 접근 로그 |
| **교육** | FERPA | 학생 정보 보호 |
| **일반** | GDPR, 개인정보보호법 | 동의, 삭제권, 국외 이전 제한 |

---

#### 3. 인프라 제약 (Q9 심화)

```
조사 항목:
[ ] 클라우드 제공자 제한 (AWS/GCP/Azure/온프레미스)
[ ] 가용 리전 (데이터 거주지 요건)
[ ] 네트워크 대역폭
[ ] 스토리지 용량/비용
[ ] 기존 인프라 연동 요건
[ ] 예산 한도
```

**작성 예시**:
```markdown
## 인프라 제약

- 클라우드: AWS 허용 (금융권 승인됨)
- 리전: 서울 필수 (데이터 국외 반출 금지)
- 예산: 월 50만원 이하
- 기존 인프라: 없음 (신규 프로젝트)
```

---

#### 4. 시간 제약

```
조사 항목:
[ ] 서비스 운영 시간
[ ] 배치 처리 시간 윈도우
[ ] 유지보수 허용 시간
[ ] 마감 시간 (정산, 리포트)
[ ] 시장 시간 (거래소, 외부 시스템)
```

**작성 예시**:
```markdown
## 시간 제약

- 시장 시간: 09:00-15:30 (정규), 15:40-18:00 (시간외)
- 배치 윈도우: 18:00-09:00 (야간)
- 유지보수: 주말 00:00-06:00
- 정산 마감: 매일 18:00
```

---


## Part 2: 충돌 패턴 식별

Part 1의 **현실적 제약**과 Stage 1의 **이상적 목표(NFR)** 사이의 충돌을 분석합니다.

### 4가지 공통 충돌 패턴

#### 충돌 1: 정확성 vs 속도 (CAP Theorem의 C vs A)

```
상황: 강한 일관성을 원하지만 낮은 지연시간도 필요

예시:
├─ 목표: "잔고 조회는 항상 정확해야 함" (정확성)
├─ 목표: "조회 응답은 100ms 이하" (속도)
└─ 충돌: 동기화 대기 vs 캐시 사용

해결 전략:
├─ 쓰기: 동기식 (정확성 보장)
├─ 읽기: 캐시 + 비동기 (속도 확보)
├─ 중요 작업만 동기, 나머지 비동기
└─ Read-after-Write 일관성 적용
```

---

#### 충돌 2: 가용성 vs 정확성 (CAP Theorem의 A vs C)

```
상황: 항상 응답해야 하지만 항상 정확해야 함

예시:
├─ 목표: "시스템은 24/7 응답 가능" (가용성)
├─ 목표: "거래 금액은 절대 틀리면 안 됨" (정확성)
└─ 충돌: 네트워크 장애 시 어떻게 할 것인가?

해결 전략:
├─ 네트워크 정상: 둘 다 만족
├─ 네트워크 장애: 정확성 우선 (금융)
├─ Saga 패턴: 분산 트랜잭션 관리
└─ Outbox 패턴: 이벤트 유실 방지
```

---

#### 충돌 3: 성능 vs 비용

```
상황: 최고 성능을 원하지만 운영비 제한

예시:
├─ 목표: "피크 시간에도 1초 이내 응답"
├─ 제약: "월 예산 50만원 이하"
└─ 충돌: 상시 고성능 인스턴스 vs 비용

해결 전략:
├─ 오토스케일링: 피크 시간만 확장
├─ 예약 인스턴스: 기본 용량 확보
├─ 스팟 인스턴스: 비용 절감 (배치용)
└─ 비용 상한선 알림 설정
```

---

#### 충돌 4: 보안 vs 사용성

```
상황: 강한 보안이 필요하지만 편리한 사용도 원함

예시:
├─ 목표: "모든 거래는 2단계 인증" (보안)
├─ 목표: "빠른 조회/주문 경험" (사용성)
└─ 충돌: 매번 MFA vs 원클릭 주문

해결 전략:
├─ 조회: 간단한 인증 (세션 기반)
├─ 거래: MFA 필수
├─ 위험 기반 인증: 이상 징후 시만 추가 인증
└─ 세션 유효 기간 차등 적용
```

---

### 충돌 분석 템플릿

각 충돌마다 다음 형식으로 분석:

```markdown
### 충돌 #N: [목표 vs 제약]

**NFR 목표** (Stage 1):
- [NFR 프로파일에서 정한 목표]

**현실 제약** (Part 1 조사 결과):
- [외부 제약 조사에서 발견한 제약]

**충돌 상황**:
- [왜 불가능한가? 구체적 수치로]

**영향 분석**:
- 이 충돌을 무시하면: [결과]
- 이 충돌을 해결하면: [기대 효과]

**트레이드오프 옵션**:
| 옵션 | 설명 | 장점 | 단점 |
|------|------|------|------|
| A | [방법 1] | [장점] | [단점] |
| B | [방법 2] | [장점] | [단점] |
| C | [방법 3] | [장점] | [단점] |

**선택**: [옵션 X]
**근거**: [선택 이유]
```

---


## Part 3: 기술 스택 결정

Stage 1의 기술 후보군 + Part 1의 제약 + Part 2의 충돌 해결을 종합하여 최종 기술 스택을 결정합니다.

### 기술 스택 결정 3단계

#### 단계 1: 패밀리 기반 후보군 확인

```
Stage 1에서 결정된 패밀리 기반 기술 후보군 확인

예시: A-A-B (트랜잭션/CRUD) 패밀리

참조: ./family-tech-matrix/02_transaction_crud_tech_options.md

후보 DB:
├─ PostgreSQL: ACID, JSON 지원, 성숙
├─ MySQL: ACID, 대중적, Aurora 옵션
└─ CockroachDB: 분산 ACID, 글로벌

후보 프레임워크 (언어별):
├─ Python: FastAPI, Django
├─ TypeScript: NestJS, Express
├─ Java: Spring Boot
├─ Go: Gin, Echo
└─ Rust: Axum, Actix
```

---

#### 단계 2: 제약조건 필터링

```
Part 1 조사 결과로 후보군 필터링

필터링 기준:
├─ 팀 역량: [팀 주력 언어] 중심 → 다른 언어 제외
├─ 비용 제한: 오픈소스 우선 → 상용 라이선스 제외
├─ 규제 요건: 국내 서버 → 글로벌 분산 DB 제한
├─ 기존 인프라: 없음 → 제약 없음
└─ 성능 요건: 비동기 필수 → 동기 전용 프레임워크 제외

필터링 결과:
├─ DB: [선택된 DB] ✅
├─ Framework: [선택된 프레임워크] ✅
└─ Cache: [선택된 캐시] ✅
```

---

#### 단계 3: 충돌 해결 반영

```
Part 2의 트레이드오프 결정을 기술 스택에 반영

예시:
├─ 충돌 1 (정확성 vs 속도) 해결:
│   → Redis 캐시 도입 (읽기 속도)
│   → PostgreSQL 트랜잭션 유지 (쓰기 정확성)
│
├─ 충돌 3 (성능 vs 비용) 해결:
│   → AWS t3.medium 시작
│   → 오토스케일링 설정
│
└─ 충돌 4 (보안 vs 사용성) 해결:
    → JWT + Refresh Token
    → 거래 시 추가 인증
```

---

### 기술 스택 문서화 형식

```markdown
## 최종 기술 스택

### 핵심 선택

| 영역 | 선택 | 대안 | 선택 근거 |
|------|------|------|----------|
| 언어 | [프로젝트 선택 언어] | - | 팀 역량, 에코시스템 |
| 프레임워크 | [선택 프레임워크] | [대안들] | 비동기, 타입 안전 |
| DB | PostgreSQL 15 | MySQL | ACID, JSON, 성숙도 |
| 캐시 | Redis | Memcached | 데이터 구조, 지속성 |
| 메시징 | Redis Streams | Kafka | 규모 적합, 단순성 |

### DNA 시스템 기술

| DNA 시스템 | 역할 | 언어별 도구 예시 |
|-----------|------|-----------------|
| Testing | 테스트 프레임워크 | pytest(Py), Jest(TS), JUnit(Java) |
| Code Quality | 린터/타입 체커 | Ruff+MyPy(Py), ESLint+TSC(TS) |
| Observability | 구조화 로깅 | structlog(Py), winston(TS), logback(Java) |
| Configuration | 설정 관리 | pydantic-settings(Py), zod(TS) |
| Resilience | 재시도/회복 | tenacity(Py), cockatiel(TS) |

**참조**: 언어별 상세 도구는 `docs/manuals/` 참조

### 인프라

| 영역 | 선택 | 비고 |
|------|------|------|
| 클라우드 | AWS Seoul | 규제 요건 |
| 컴퓨팅 | ECS Fargate | 서버리스 컨테이너 |
| DB | RDS PostgreSQL | 관리형 |
| 캐시 | ElastiCache Redis | 관리형 |
```

---


## 📋 템플릿

### 02C-01_external_constraints.md 템플릿

```markdown
# 외부 제약 조건

**프로젝트**: [프로젝트명]
**작성일**: [YYYY-MM-DD]
**작성자**: [이름]

---

## 1. API/연동 제약

### 1.1 외부 API 목록

| API | 용도 | 호출 제한 | 인증 | 응답 시간 |
|-----|------|----------|------|----------|
| [API 1] | [용도] | [제한] | [방식] | [시간] |
| [API 2] | [용도] | [제한] | [방식] | [시간] |

### 1.2 연동 시 제약사항
- [제약 1]
- [제약 2]

---

## 2. 규제/법적 제약

### 2.1 적용 법규
- [법규 1]: [핵심 요건]
- [법규 2]: [핵심 요건]

### 2.2 데이터 보관 요건
| 데이터 유형 | 보관 기간 | 형식 | 근거 법규 |
|------------|----------|------|----------|
| [유형 1] | [기간] | [형식] | [법규] |

### 2.3 암호화 요건
- [요건 1]
- [요건 2]

---

## 3. 인프라 제약

### 3.1 클라우드/서버
- 허용 클라우드: [AWS/GCP/Azure/온프레미스]
- 필수 리전: [리전명]
- 이유: [데이터 거주지 등]

### 3.2 예산
- 초기 예산: [금액]
- 월 운영비: [금액]

### 3.3 기존 인프라
- [연동 필요한 기존 시스템]

---

## 4. 시간 제약

### 4.1 서비스 운영 시간
- 정규: [시간]
- 시간외: [시간]

### 4.2 배치 처리 윈도우
- [시간대]

### 4.3 외부 시스템 시간
- [시장 시간, 정산 마감 등]
```

---

### 02C-02_conflict_patterns.md 템플릿

```markdown
# 충돌 패턴 분석

**프로젝트**: [프로젝트명]
**작성일**: [YYYY-MM-DD]

---

## NFR 달성 가능성 분석

### Stage 1 NFR 프로파일: [X-X-X-X]

| NFR | 목표 | 외부 제약 | 달성 가능? |
|-----|------|----------|-----------|
| [NFR 1] | [목표] | [제약] | ✅/⚠️/❌ |
| [NFR 2] | [목표] | [제약] | ✅/⚠️/❌ |

---

## 발견된 충돌 패턴

### 충돌 #1: [목표 vs 제약]

**NFR 목표**:
- [목표 설명]

**현실 제약**:
- [제약 설명]

**충돌 상황**:
- [구체적 수치로 설명]

**트레이드오프 옵션**:
| 옵션 | 설명 | 장점 | 단점 |
|------|------|------|------|
| A | [방법] | [장점] | [단점] |
| B | [방법] | [장점] | [단점] |

**선택**: [옵션]
**근거**: [이유]

---

### 충돌 #2: [목표 vs 제약]
[같은 형식으로 작성]

---

## 충돌 해결 요약

| 충돌 | 선택한 옵션 | Stage 3 ADR 필요? |
|------|-----------|------------------|
| #1 | [옵션] | ✅/❌ |
| #2 | [옵션] | ✅/❌ |
```

---

### 02D-01_tech_stack.md 템플릿

```markdown
# 기술 스택 결정

**프로젝트**: [프로젝트명]
**작성일**: [YYYY-MM-DD]

---

## 결정 과정

### 1. 패밀리 기반 후보군
- 패밀리: [코드] ([패밀리명])
- 참조: `./family-tech-matrix/[파일].md`

### 2. 제약조건 필터링
| 제약 | 영향 | 필터링 결과 |
|------|------|-----------|
| [제약 1] | [영향] | [제외된 기술] |

### 3. 충돌 해결 반영
| 충돌 | 해결 옵션 | 기술 영향 |
|------|----------|----------|
| [충돌 1] | [옵션] | [기술 추가/변경] |

---

## 최종 기술 스택

### 핵심 선택

| 영역 | 선택 | 대안 | 선택 근거 |
|------|------|------|----------|
| 언어 | [언어] | [대안] | [근거] |
| 프레임워크 | [프레임워크] | [대안] | [근거] |
| DB | [DB] | [대안] | [근거] |
| 캐시 | [캐시] | [대안] | [근거] |

### DNA 시스템 기술

| DNA 시스템 | 기술 | 설정 |
|-----------|------|------|
| Testing | [기술] | [설정] |
| Code Quality | [기술] | [설정] |
| Observability | [기술] | [설정] |
| Configuration | [기술] | [설정] |
| Resilience | [기술] | [설정] |

### 인프라

| 영역 | 선택 | 비고 |
|------|------|------|
| 클라우드 | [선택] | [비고] |
| 컴퓨팅 | [선택] | [비고] |
| DB | [선택] | [비고] |

---

## Stage 3 ADR 목록 (예정)

이 문서의 결정들은 Stage 3에서 ADR로 공식화됩니다:

- [ ] ADR-001: [DB 선택]
- [ ] ADR-002: [프레임워크 선택]
- [ ] ADR-003: [충돌 해결 전략]
```

---


## ✅ Stage 2 완료 체크리스트

```
□ Part 1: 외부 제약 조사 완료
  □ API/연동 제약 조사
  □ 규제/법적 제약 조사
  □ 인프라 제약 조사
  □ 시간 제약 조사

□ Part 2: 충돌 패턴 식별 완료
  □ NFR 달성 가능성 분석
  □ 충돌 패턴 식별 (최소 1개 이상)
  □ 각 충돌별 트레이드오프 옵션 도출
  □ 각 충돌별 선택 및 근거 문서화

□ Part 3: 기술 스택 결정 완료
  □ 패밀리 기반 후보군 확인
  □ 제약조건 필터링
  □ 충돌 해결 반영
  □ 최종 기술 스택 문서화

□ 산출물 생성:
  □ 02C-01_external_constraints.md
  □ 02C-02_conflict_patterns.md
  □ 02D-01_tech_stack.md

□ Stage 3 ADR 목록 작성
```

---

## 🔜 다음 단계

### Stage 2 → Stage 3 전달 사항

| 항목 | 예시 | Stage 3에서 사용 |
|------|------|-----------------|
| 외부 제약 | API 호출 제한, 규제 | ADR 카테고리 1 (외부 제약) |
| 충돌 해결 | 정확성 vs 속도 해결 | ADR 카테고리 2 (충돌 해결) |
| 기술 스택 | PostgreSQL, [선택 프레임워크] | ADR 카테고리 3 (기술 스택) |
| ADR 목록 | 예정된 ADR 3개 | Stage 3 작업 범위 |

### Stage 3에서 할 일
- 🔄 ADR 카테고리별 작성
- 🔄 Bootstrap ADR (DNA 시스템)
- 🔄 Domain ADR (도메인 특화)
- 🔄 Design Doc → ADR 변환 (복잡한 결정)

**다음 문서**: `03G-00_adr_guide.md`

---

## ⏪ 이전 Stage 검증 및 수정 프로토콜

### 검증 시점
- Stage 2 시작 전 필수 체크
- Part 1 (기술 환경 조사) 완료 후 재검증

### 검증 대상

| Stage | 산출물 | 검증 항목 |
|-------|--------|----------|
| Stage 1 | 01C-01_*.md (패밀리) | 선택한 패밀리가 기술 제약과 호환? |
| Stage 1 | 01C-01_*.md (NFR) | NFR 우선순위가 현실적? |

### 오류 발견 시 프로토콜

```
Stage 2에서 Stage 1 오류 발견 시:

Step 1: 오류 발견 및 문서화
├─ 발견 위치: Stage 2 Part [N]
├─ 오류 내용: [구체적 설명]
└─ 기록: 02C-01에 "발견된 이슈" 섹션 추가

Step 2: 영향 범위 파악
├─ 직접 영향: Stage 1 (패밀리/NFR)
├─ 재작업 예상: [X]시간
└─ 기록 완료

Step 3: Stage 1로 이동 → 수정
├─ 01C-01_*.md 수정
├─ 버전 업데이트 (v1.0 → v1.1)
└─ 수정 완료 검증

Step 4: Stage 2 재진행
├─ 수정된 입력으로 Part 1부터 재검토
└─ 충돌 분석 재수행

Step 5: 검증
├─ 오류 해결 확인
├─ 새로운 문제 없음 확인
└─ Stage 3 전달 가능 ✅
```

### 흔한 오류 패턴

| 오류 유형 | 예시 | 해결 |
|----------|------|------|
| 패밀리 불일치 | 실시간 요구사항인데 CRUD 패밀리 선택 | Stage 1 패밀리 재분류 |
| NFR 비현실적 | 10ms 응답 요구 but 팀에 경험 없음 | Stage 1 NFR 현실화 |
| 제약 누락 | 예산 제약 미고려 | Stage 1 제약조건 추가 |

### 추적성

```
수정 이력 파일: docs/revision_log.md

기록 형식:
## [날짜] Stage 2 → Stage 1 수정
- **발견**: [오류 내용]
- **원인**: [근본 원인]
- **수정**: [수정 내용]
- **영향**: [영향 범위]
- **검증**: [검증 결과]
```

---

## 📚 참고 문서

| 문서 | 용도 |
|------|------|
| `01_DNA_METHODOLOGY_DETAILED.md` Part 3.2 | Stage 2 상세 원리 |
| `./family-tech-matrix/*.md` | 패밀리별 기술 선택 |
| `./02E-01_stock_trading_case.md` | 실전 사례 (주식 거래) |
| `./standards/01_STAGE_STRUCTURE.md` | Stage 간 연결 구조 |

---

## 💡 핵심 원칙 요약

```
Stage 2의 본질:

1. "이상과 현실의 간극 파악"
   - Stage 1의 NFR은 이상
   - Part 1 조사 결과는 현실
   - 간극 = 충돌

2. "충돌은 정상이다"
   - 모든 프로젝트에 충돌 존재
   - 중요한 것은 의식적 트레이드오프
   - 결정과 근거를 문서화

3. "기술 스택은 제약의 산물"
   - 이상적 기술 ≠ 최종 선택
   - 제약조건 필터링 후 남는 것이 정답
   - 선택 근거가 핵심
```

---

**버전 이력**:
- v5.0 (2025-12-03): Gemini 연구 기반 전면 재작성, 01_DNA_METHODOLOGY_DETAILED.md 기준
- v4.0 (2025-11-14): Stage 2 구조 확립
- v3.0 (2025-11-12): 초기 버전


================================================================================

📄 FILE: 03G-00_adr_guide.md
--------------------------------------------------------------------------------

# Stage 3: ADR 작성 가이드 (Architecture Decision Records Guide)

> **목적**: Stage 2에서 결정된 기술 스택과 충돌 해결을 공식 ADR로 문서화
>
> **버전**: v4.1 (2025-12-03)
>
> - v4.0 (2025-12-03): Gemini 연구 기반 전면 재작성, 01_DNA_METHODOLOGY_DETAILED.md 기준
> - v3.0 (2025-11-13): Stage 3 분리

---

## 📚 이 가이드의 위치

```
DNA 방법론 문서 체계:

Tier 1: 00_CORE_METHODOLOGY.md (전체 맥락)
           ↓
Tier 2: 01_DNA_METHODOLOGY_DETAILED.md (상세 원리) - Part 4
           ↓
Tier 3: 이 문서 (Stage 3 실행 가이드) ← 지금 여기!
```

**참조 문서**:
- **원리 이해**: `01_DNA_METHODOLOGY_DETAILED.md` Part 4
- **실전 사례**: `IMPLEMENTATION_CASES.md`

---

## 🧬 DNA 방법론 4대 핵심 원칙 (Stage 3 적용)

> **"AI가 한 세션에서 최고 성과를 낼 수 있는 크기로 작업하고, 완전해질 때까지 반복하며, 오류 발견 시 되돌아가서 수정한다"**

Stage 3 (ADR 작성)에서 DNA 4대 핵심 원칙이 적용되는 방식:

---

### DNA 핵심 원칙 1: AI 최적 크기

**"컨텍스트 범위 내에서 작업한다"**

#### Stage 3의 작업 크기 전략

```
❌ 잘못된 접근: 모든 ADR 한 번에
"20개 ADR을 한 세션에서 모두 작성하세요"
→ 컨텍스트 초과 (200K 토큰 한계)
→ 후반부 ADR 품질 저하
→ 일관성 없는 형식

✅ 올바른 접근: 카테고리별 순차 작성
Session 1: 외부 제약 ADR (03A-001 ~ 03A-00N)
Session 2: 충돌 해결 ADR (03A-101 ~ 03A-1NN)
Session 3: 기술 스택 ADR (03A-201 ~ 03A-2NN)
Session 4: 도메인 기술 ADR (03A-301 ~ 03A-3NN)
Session 5: DNA 시스템 ADR (03A-401 ~ 03A-4NN)

각 세션: 3-5개 ADR, 80-90K 토큰 범위
```

#### 컨텍스트 구성 (각 세션)

```
AI 컨텍스트 윈도우 (예: 200K 토큰):
├─ 시스템 프롬프트: ~30K 토큰
├─ 대화 히스토리: ~20K 토큰
├─ Stage 2 참조 문서: ~30-40K 토큰
│   ├─ 02C-01_external_constraints.md
│   ├─ 02C-02_conflict_patterns.md
│   └─ 02D-01_tech_stack.md
├─ ADR 템플릿: ~10K 토큰
├─ 작업 중 ADR 작성: ~20K 토큰 (3-5개 × 4-6K)
└─ 응답 생성 여유: ~80K 토큰
```

#### 세션당 작업량 기준

| 카테고리 | 평균 ADR 수 | 세션 수 | 세션당 ADR 수 |
|---------|------------|--------|--------------|
| 외부 제약 | 3-5개 | 1 session | 3-5개 |
| 충돌 해결 | 5-10개 | 2 sessions | 3-5개 |
| 기술 스택 | 10-15개 | 3 sessions | 3-5개 |
| 도메인 기술 | 5-10개 | 2 sessions | 3-5개 |
| DNA 시스템 | 11개 | 3 sessions | 3-4개 |

**핵심**: 한 세션에 3-5개 ADR이 최적 (각 4-6K 토큰)

---

### DNA 핵심 원칙 2: 완전해질 때까지 반복

**"부족하면 반복해서 부족함이 없어질 때까지"**

#### ADR 완전성 기준

각 ADR은 다음 5가지 섹션을 모두 포함해야 함:

```
✅ 완전한 ADR 체크리스트:
□ 1. Status & Context (상태 및 맥락)
   - 상태: Proposed/Accepted/Deprecated/Superseded
   - 날짜: 작성일, 승인일, 폐기일
   - 맥락: 왜 이 결정이 필요한가?

□ 2. Decision (결정 사항)
   - 무엇을 선택했는가?
   - 구체적 기술/방법 명시

□ 3. Rationale (근거)
   - 왜 이것을 선택했는가?
   - 어떤 대안이 있었는가?
   - 각 대안의 장단점은?

□ 4. Consequences (결과)
   - 긍정적 결과 (이점)
   - 부정적 결과 (트레이드오프)
   - 영향받는 시스템/모듈

□ 5. Compliance (준수 사항)
   - 검증 방법 (어떻게 확인?)
   - 위반 시 조치 (어떻게 강제?)
   - 재검토 조건 (언제 다시 평가?)
```

#### 3단계 검증 프로토콜

```
ADR 세션 완전성 검증 (의사코드):

FUNCTION validate_adr_session(adrs):
    
    # 검증 1: 각 ADR 구조 검증
    FOR EACH adr IN adrs:
        IF adr가 5개 섹션 중 하나라도 누락:
            - 상태/맥락, 결정, 근거, 결과, 준수
            RETURN 실패: "ADR {id}: 5개 섹션 중 누락 발견"
            ACTION: "해당 ADR 재작성"

    # 검증 2: 카테고리 일관성 검증
    IF adrs의 카테고리가 서로 다름:
        RETURN 실패: "한 세션에 여러 카테고리 혼재"
        ACTION: "카테고리별로 세션 분리"

    # 검증 3: Stage 2 추적성 검증
    FOR EACH adr IN adrs:
        IF adr에 Stage 2 참조가 없음:
            RETURN 실패: "ADR {id}: Stage 2 참조 누락"
            ACTION: "Stage 2 문서 참조 추가"

    RETURN 성공
```

#### 불완전 → 재작성 사례

```markdown
## 사례: ADR-201 데이터베이스 선택

### ❌ 불완전한 버전 (1차 작성)
**결정**: PostgreSQL 사용
**이유**: 관계형 데이터베이스가 필요해서

❌ 문제점:
- 대안 검토 없음 (MySQL, MongoDB는?)
- 구체적 근거 없음 ("필요해서"는 설명 아님)
- 결과/영향 명시 없음
- 준수 사항 없음

### ✅ 완전한 버전 (2차 재작성)
**맥락**: 주문 데이터는 ACID 보장 필요, 복잡한 조인 쿼리 빈번

**결정**: PostgreSQL 13+ 사용

**근거**:
- 검토한 대안:
  1. PostgreSQL: ACID 완벽, JSON 지원, 성능 우수
  2. MySQL: ACID 지원하나 JSON 기능 제한적
  3. MongoDB: 유연하나 트랜잭션 복잡
- 선택 이유: 주문 데이터의 ACID 필수, JSON 컬럼 필요

**결과**:
- 긍정: 데이터 일관성 보장, 복잡한 쿼리 가능
- 부정: NoSQL 대비 스키마 변경 부담
- 영향: DNA Database 시스템, Order 도메인

**준수**:
- 검증: SQLAlchemy ORM으로만 접근
- 위반 시: pre-commit hook으로 raw SQL 차단
- 재검토: 쓰기 속도 < 100 TPS 시
```

---

### DNA 핵심 원칙 3: 기능별 분해 + 연결부 + 조립

**"모듈이 크면 기능별로 나누고, 연결부 설계 후 조립"**

#### Stage 3에서의 적용

Stage 3는 "문서 작성" 단계이므로 원칙 3은 직접 적용되지 않습니다.

다만, ADR 자체가 "연결부" 역할을 합니다:

```
Stage 2 (결정) ←─┐
                  ├─ ADR (연결부) ─→ Stage 4 (DNA 계획)
Stage 8 (작업)  ←─┘                     ↓
   ↓                                 Stage 5 (DNA 구현)
Stage 9 (체크리스트)

ADR의 연결 역할:
├─ Stage 2 결정을 공식 기록
├─ Stage 4-5에서 참조
└─ Stage 8-9 작업 시 검증 기준
```

#### ADR 간 연결 관리

```markdown
## ADR 간 의존성 예시

ADR-001: Python 3.11+ 사용
   ↓ supersedes
ADR-005: Python 3.9+ 사용 (폐기됨)

ADR-201: PostgreSQL 사용
   ↓ related to
ADR-401: DNA Database 시스템 (SQLAlchemy 2.0)

ADR-102: 캐시는 조회만 사용
   ↓ enforced by
ADR-402: DNA Cache 시스템 (Redis 구조)
```

---

### DNA 핵심 원칙 4: 역방향 수정 프로토콜

**"앞선 결정의 오류 발견 시 → 되돌아가서 수정 → 다시 현재까지 진행"**

#### Stage 3에서 역방향 수정이 발생하는 경우

```
시나리오 1: Stage 2 결정 오류 발견
├─ Stage 3 ADR 작성 중
├─ Stage 2 충돌 해결이 잘못됨을 발견
├─ → Stage 2로 돌아가 수정
├─ → Stage 3 ADR 재작성
└─ → 추적성 업데이트

시나리오 2: Stage 4-5에서 ADR 오류 발견
├─ Stage 5 DNA 구현 중
├─ ADR-201 (PostgreSQL) 제약 불가능 발견
├─ → Stage 3로 돌아가 ADR-201 수정
├─ → Stage 4 청사진 업데이트
├─ → Stage 5 구현 재진행
└─ → 추적성 업데이트
```

#### 6단계 수정 프로토콜

```markdown
## 실제 사례: ADR-102 캐시 전략 수정

### Step 1: 오류 발견 및 문서화
**발견 시점**: Stage 5 (DNA Cache 시스템 구현 중)
**파일**: `docs/adr/category-2-conflict/03A-102_cache_strategy.md`
**문제**: "조회만 캐시 사용"인데, 통계 데이터도 캐시 필요함을 발견

### Step 2: 영향 범위 파악
**영향받는 문서**:
- Stage 2: `02D-01_tech_stack.md` (Line 234-256)
- Stage 3: `03A-102_cache_strategy.md` (전체)
- Stage 4: `04D-02_dna_cache_blueprint.md` (Line 45-67)

**영향받는 구현**: 없음 (아직 구현 전)

### Step 3: 해당 Stage로 이동 및 수정
```bash
# Stage 2 재검토
$ edit 02D-01_tech_stack.md
  Line 234-256: "조회 + 통계 데이터에 캐시 사용" 으로 수정

# Stage 3 ADR 수정
$ edit 03A-102_cache_strategy.md
  - Status: Accepted → Superseded
  - Superseded by: 03A-102-v2

$ create 03A-102-v2_cache_strategy_updated.md
  - 새로운 결정: 조회 + 통계 → 캐시
  - 주문/결제 → 캐시 없음
```

### Step 4: 중간 Stage 전파
```bash
# Stage 4 청사진 업데이트
$ edit 04D-02_dna_cache_blueprint.md
  Line 45-67: 통계 데이터 캐시 구조 추가
  Ref: 03A-102-v2 (Line 23-45)
```

### Step 5: 현재 Stage 재진행
```bash
# Stage 5 재구현
$ implement src/core/cache/
  - stats_cache.py 추가
  - Ref: 03A-102-v2
```

### Step 6: 재진행 결과 검증
**검증 항목**:
- [ ] Stage 2 충돌 재분석 완료
- [ ] ADR-102-v2 5개 섹션 완전
- [ ] Stage 4 청사진 ADR 참조 업데이트
- [ ] Stage 5 구현 ADR 준수
- [ ] 모든 파일에 추적성 명시
```

#### 추적성 (Traceability) 유지

**모든 수정은 명시적으로 참조**:

```markdown
## Stage 2 문서 (02D-01_tech_stack.md)
Line 234-256: 캐시 전략
> **History**:
> - v1.0 (2024-11-10): "조회만 캐시"
> - v2.0 (2024-11-15): "조회 + 통계 캐시" (Reason: ADR-102-v2)

## Stage 3 ADR (03A-102-v2_cache_strategy_updated.md)
**Supersedes**: ADR-102 (2024-11-10)
**Reason**: 통계 데이터 캐시 필요성 발견
**Impact**: Stage 4 (04D-02, Line 45-67), Stage 5 (src/core/cache/)

## Stage 4 청사진 (04D-02_dna_cache_blueprint.md)
Line 45-67: 통계 데이터 캐시 구조
> **Ref**: ADR-102-v2 (Line 23-45)
> **Updated**: 2024-11-15 (Reason: ADR 수정)

## Stage 5 구현 (src/core/cache/stats_cache.py)
Line 1: # Ref: ADR-102-v2 (docs/adr/category-2-conflict/03A-102-v2)
Line 5: # Updated: 2024-11-15 (통계 데이터 캐시 추가)
```

---

## 🎯 DNA 원칙 적용 요약 (Stage 3)

| 원칙 | Stage 3 적용 방법 | 체크포인트 |
|------|------------------|-----------|
| **1. AI 최적 크기** | 카테고리별 세션 분리 (3-5 ADR/세션) | 세션당 80-90K 토큰 |
| **2. 완전해질 때까지** | 5개 섹션 완전성, 3단계 검증 | 모든 ADR 5 sections |
| **3. 기능별 분해** | (문서 단계라 직접 적용 안 됨) | ADR 자체가 연결부 |
| **4. 역방향 수정** | 6단계 프로토콜, 추적성 유지 | Superseded/History |

---

## 🤔 왜 ADR이 필요한가?

### 문제 상황: "왜 이렇게 했지?"

```
6개월 후...

새로운 팀원: "왜 PostgreSQL인가요? MongoDB가 더 좋을 것 같은데..."
기존 팀원: "음... 그때 뭔가 이유가 있었는데..."

결과:
├─ 같은 논의 반복 (시간 낭비)
├─ 근거 없이 기술 변경 시도
├─ 변경 후 예상치 못한 문제 발생
└─ "그냥 원래대로 하자" (발전 없음)
```

### 실제 사례: 주식 거래 플랫폼

```
상황:
- Stage 2에서 "정확성 > 속도" 결정
- 주문 처리에 캐시 사용 안 함
- 조회에만 캐시 사용

6개월 후:
- 새 개발자: "주문도 캐시 쓰면 빨라질 텐데?"
- ADR 없다면 → 캐시 적용 → 금액 불일치 사고
- ADR 있다면 → ADR-101 확인 → "아, 이래서 안 쓰는구나"

ADR-101 정확성 우선 전략:
├─ 맥락: 주문 금액 정확성 필수
├─ 검토한 대안: 캐시 사용, 실시간 조회, 하이브리드
├─ 결정: 주문은 실시간, 조회만 캐시
├─ 결과: 500ms 느려지지만 정확도 100%
└─ 재검토 조건: 정확도 문제 발생 시
```

### ADR의 핵심 가치

| 가치 | 설명 | 없을 때 문제 |
|------|------|-------------|
| **기억** | 결정 근거 보존 | 왜 이렇게 했는지 모름 |
| **방지** | 같은 실수 반복 방지 | 이미 검토한 대안 재논의 |
| **속도** | 신규 인원 온보딩 | 모든 결정을 다시 설명 |
| **변경** | 영향 범위 파악 | 변경 시 뭐가 깨지는지 모름 |

---

## 📥 입력 문서

### Stage 2에서 전달받는 것

| 파일 | 핵심 내용 | 이 Stage에서 사용 |
|------|----------|-----------------|
| `02C-01_external_constraints.md` | 외부 제약 조사 | ADR 카테고리 1 |
| `02C-02_conflict_patterns.md` | 충돌 패턴 분석 | ADR 카테고리 2 |
| `02D-01_tech_stack.md` | 기술 스택 결정 | ADR 카테고리 3, 5 |

---

## 📤 출력 문서

### 필수 산출물

```
docs/adr/
├── 03A-000_adr_index.md           # ADR 목록 및 상태
├── category-1-external/           # 외부 제약 ADR
│   └── 03A-001_*.md ~ 03A-00N.md
├── category-2-conflict/           # 충돌 해결 ADR
│   └── 03A-101_*.md ~ 03A-1NN.md
├── category-3-tech-stack/         # 기술 스택 ADR
│   └── 03A-201_*.md ~ 03A-2NN.md
├── category-4-domain/             # 도메인 기술 ADR
│   └── 03A-301_*.md ~ 03A-3NN.md
└── category-5-dna-system/         # DNA 시스템 ADR
    └── 03A-401_*.md ~ 03A-4NN.md
```

---

## 🎯 ADR이란?

> **ADR = Architecture Decision Record**
> 
> "코드는 '무엇'을 보여주지만, ADR은 '왜'를 설명한다"

### ADR의 역할

```
왜 필요한가?
├─ 왜 이 결정을 했는지 기록
├─ 어떤 대안이 있었는지 기록
├─ 나중에 "왜 이렇게 했지?" 질문에 답변
└─ 결정 변경 시 영향 범위 파악
```

### ADR vs Design Doc

| 구분 | Design Doc | ADR |
|------|------------|-----|
| **목적** | 상세 분석 | 결정 기록 |
| **분량** | 10-50 페이지 | 1-2 페이지 |
| **내용** | 문제 정의, 대안 분석, 벤치마크 | 맥락, 결정, 결과 |
| **사용 시점** | 복잡한 결정 전 | 모든 결정 후 |
| **관계** | "어머니" 문서 | Design Doc의 "결론" |

**판단 기준**:
```
├─ 간단한 결정: ADR만 작성
│   예: "로깅 라이브러리 선택"
│
├─ 복잡한 결정: Design Doc → ADR
│   예: "DB 선택 (PostgreSQL vs MySQL vs MongoDB)"
│
└─ 매우 복잡: RFC/KEP → Design Doc → ADR
    예: "마이크로서비스 vs 모놀리식"
```

---


## 5대 ADR 카테고리

### 카테고리 1: 외부 제약 ADR (001-099)

> **정의**: 변경할 수 없는 외부 요인에 의한 결정

```
특징:
├─ 우리가 선택할 수 없음
├─ 반드시 따라야 함
├─ 위반 시 시스템 작동 불가 또는 법적 문제
└─ "왜?"보다 "무엇?"이 중요
```

**예시**:
| 유형 | 예시 | ADR 제목 |
|------|------|---------|
| 법규 | 거래 기록 5년 보관 | ADR-001: 전자금융거래법 준수 |
| API 제한 | KIS API 초당 20회 | ADR-002: KIS API Rate Limit 대응 |
| 시장 시간 | KRX 정규장 09:00-15:30 | ADR-003: 시장 시간 기반 스케줄링 |
| 지역 제한 | 개인정보 국내 서버 필수 | ADR-004: 데이터 거주지 요건 |

---

### 카테고리 2: 충돌 해결 ADR (101-199)

> **정의**: 상충하는 요구사항 간 Trade-off 결정

```
특징:
├─ 둘 다 중요하지만 둘 다 만족 불가
├─ 하나를 선택하면 다른 하나 희생
├─ "왜 이걸 선택했나?"가 핵심
└─ 나중에 재검토 가능성 있음
```

**예시**:
| 충돌 | 결정 | ADR 제목 |
|------|------|---------|
| 정확성 vs 속도 | 주문=정확성, 조회=속도 | ADR-101: 정확성 우선 전략 |
| 일관성 vs 가용성 | CP 선택 (장애 시 거부) | ADR-102: CAP 선택 - CP |
| 보안 vs 편의성 | 거래=MFA, 조회=단순 | ADR-103: 인증 레벨 차등화 |
| 비용 vs 성능 | 피크=성능, 비피크=비용 | ADR-104: 오토스케일링 전략 |

---

### 카테고리 3: 기술 스택 ADR (201-299)

> **정의**: 여러 기술 대안 중 하나를 선택하는 결정

```
특징:
├─ 비교 가능한 대안 존재
├─ 정량적 비교 가능 (성능, 비용, 생태계)
├─ Context7 검증 필수
└─ 팀 역량, 생태계 고려
```

**예시**:
| 영역 | 선택 | 대안 | ADR 제목 |
|------|------|------|---------|
| DB | PostgreSQL | MySQL, MongoDB | ADR-201: PostgreSQL 선택 |
| 프레임워크 | [선택 프레임워크] | [대안들] | ADR-202: 프레임워크 선택 |
| 메시지 큐 | Redis Streams | Kafka, RabbitMQ | ADR-203: Redis Streams 선택 |
| 캐시 | Redis | Memcached | ADR-204: Redis 캐시 선택 |

---

### 카테고리 4: 도메인 기술 ADR (301-399)

> **정의**: 프로젝트 특화 로직/알고리즘 설계 결정

```
특징:
├─ 외부 라이브러리로 해결 안 됨
├─ 자체 설계/구현 필요
├─ 비즈니스 로직 깊숙이 관련
└─ 성능/정확도가 핵심
```

**예시**:
| 영역 | 설계 내용 | ADR 제목 |
|------|----------|---------|
| 주문 처리 | 상태 머신, 재시도 전략 | ADR-301: 주문 실행 전략 |
| 데이터 모델 | 주문 스키마, 관계 | ADR-302: 주문 데이터 모델 |
| API 설계 | 엔드포인트, 응답 형식 | ADR-303: REST API 설계 |
| 동시성 | 낙관적 락, 충돌 해결 | ADR-304: 동시성 제어 전략 |

---

### 카테고리 5: DNA 시스템 ADR (401-499)

> **정의**: 프로젝트 공통 인프라/표준 결정

```
특징:
├─ 전체 프로젝트에 영향
├─ Stage 4-6 (Bridge)에서 구현
├─ 일관성이 핵심
└─ 변경 시 영향 범위 큼
```

**예시**:
| 시스템 | 결정 내용 | ADR 제목 |
|--------|----------|---------|
| 로깅 | 구조화 로깅 + JSON | ADR-401: 로깅 표준화 |
| 에러 처리 | 예외 계층 + 에러 코드 | ADR-402: 에러 처리 표준 |
| 설정 관리 | 타입 안전 설정 | ADR-403: 설정 관리 표준 |
| 테스트 | 테스트 프레임워크 + 95% 커버리지 | ADR-404: 테스트 전략 |
| 인증 | JWT + RS256 | ADR-405: 인증 표준 |

---


## ADR 작성 우선순위

### 권장 순서

```
Phase 1: 외부 제약 ADR (카테고리 1)
────────────────────────────────────
- 가장 먼저 작성 (변경 불가능)
- Stage 2 02C-01_external_constraints.md 기반
- 다른 ADR의 제약 조건이 됨

Phase 2: 충돌 해결 ADR (카테고리 2)
────────────────────────────────────
- 외부 제약 기반 해결책
- Stage 2 02C-02_conflict_patterns.md 기반
- 기술 스택 선택에 영향

Phase 3: 기술 스택 ADR (카테고리 3)
────────────────────────────────────
- Stage 2 02D-01_tech_stack.md 기반
- 핵심 기술 선택 근거

Phase 4: DNA 시스템 ADR (카테고리 5)
────────────────────────────────────
- 공통 인프라 결정
- Stage 4-6에서 구현할 내용

Phase 5: 도메인 기술 ADR (카테고리 4)
────────────────────────────────────
- 비즈니스 로직 설계
- Stage 7-9에서 구현할 내용
```

---

## 📋 ADR 템플릿

### 표준 ADR 템플릿

```markdown
# ADR-XXX: {Decision Title}

**상태**: Proposed | Accepted | Deprecated | Superseded
**작성일**: YYYY-MM-DD
**카테고리**: 외부제약 | 충돌해결 | 기술스택 | 도메인기술 | DNA시스템

---

## 맥락 (Context)

왜 이 결정이 필요한가?
- 문제 상황
- 제약 조건
- 요구사항

## 검토한 대안 (Alternatives)

### 대안 1: [이름]
- 설명: ...
- 장점: ...
- 단점: ...

### 대안 2: [이름]
- 설명: ...
- 장점: ...
- 단점: ...

### 대안 3: [이름]
- 설명: ...
- 장점: ...
- 단점: ...

## 결정 (Decision)

**선택**: [대안 N]

**핵심 근거**:
1. [이유 1]
2. [이유 2]
3. [이유 3]

## 결과 (Consequences)

### 긍정적 영향
- ✅ [영향 1]
- ✅ [영향 2]

### 트레이드오프
- ⚠️ [트레이드오프 1]
- ⚠️ [트레이드오프 2]

### 부정적 영향
- ❌ [영향 1] (해결 방안: ...)

## 후속 조치 (Follow-up)

- [ ] [조치 1]
- [ ] [조치 2]

## 참조 (References)

- Stage 2 문서: `02C-01_external_constraints.md`
- 관련 ADR: ADR-XXX
- 외부 링크: [URL]
```

---

### 카테고리별 템플릿 변형

#### 외부 제약 ADR (간소화)

```markdown
# ADR-00X: [외부 제약 제목]

**상태**: Accepted
**카테고리**: 외부제약
**작성일**: YYYY-MM-DD

---

## 제약 조건

| 항목 | 내용 |
|------|------|
| 출처 | [법규/API/규제 등] |
| 제약 내용 | [구체적 제약] |
| 위반 시 영향 | [결과] |

## 대응 방안

[제약을 준수하기 위한 구현 방안]

## 결과

- 모든 [관련 기능]은 [제약]을 준수해야 함
- [구현 위치/방법]
```

---

#### 기술 스택 ADR (비교표 포함)

```markdown
# ADR-2XX: [기술 선택 제목]

**상태**: Accepted
**카테고리**: 기술스택
**작성일**: YYYY-MM-DD

---

## 맥락

[왜 이 기술이 필요한가]

## 대안 비교

| 기준 | [기술 A] | [기술 B] | [기술 C] |
|------|---------|---------|---------|
| 성능 | ⭐⭐⭐ | ⭐⭐ | ⭐ |
| 비용 | 무료 | 무료 | $$$ |
| 팀 경험 | ✅ 있음 | ⚠️ 적음 | ❌ 없음 |
| 생태계 | ✅ 풍부 | ⚠️ 보통 | ⚠️ 보통 |
| [기타 기준] | ... | ... | ... |

## 결정

**선택**: [기술 A]

**핵심 근거**:
1. [이유 1]
2. [이유 2]

## 결과

- [구현에 미치는 영향]
- [함께 사용할 라이브러리]
```

---


### ADR Index 템플릿 (03A-000_adr_index.md)

```markdown
# ADR Index

**프로젝트**: [프로젝트명]
**최종 업데이트**: YYYY-MM-DD
**총 ADR 수**: [N]개

---

## 상태별 요약

| 상태 | 개수 |
|------|------|
| Proposed | N |
| Accepted | N |
| Deprecated | N |
| Superseded | N |

---

## 카테고리 1: 외부 제약 (001-099)

| 번호 | 제목 | 상태 | 작성일 |
|------|------|------|--------|
| ADR-001 | [제목] | Accepted | YYYY-MM-DD |
| ADR-002 | [제목] | Accepted | YYYY-MM-DD |

---

## 카테고리 2: 충돌 해결 (101-199)

| 번호 | 제목 | 충돌 유형 | 상태 | 작성일 |
|------|------|----------|------|--------|
| ADR-101 | [제목] | 정확성 vs 속도 | Accepted | YYYY-MM-DD |

---

## 카테고리 3: 기술 스택 (201-299)

| 번호 | 제목 | 영역 | 선택 | 상태 |
|------|------|------|------|------|
| ADR-201 | [제목] | DB | PostgreSQL | Accepted |
| ADR-202 | [제목] | Framework | [선택 프레임워크] | Accepted |

---

## 카테고리 4: 도메인 기술 (301-399)

| 번호 | 제목 | 도메인 | 상태 |
|------|------|--------|------|
| ADR-301 | [제목] | 주문 | Accepted |

---

## 카테고리 5: DNA 시스템 (401-499)

| 번호 | 제목 | 시스템 | 상태 |
|------|------|--------|------|
| ADR-401 | [제목] | 로깅 | Accepted |
| ADR-402 | [제목] | 에러처리 | Accepted |

---

## 의존성 그래프

```
ADR-001 (외부제약)
    ↓
ADR-101 (충돌해결) ← ADR-002 (외부제약)
    ↓
ADR-201 (기술스택)
    ↓
ADR-401 (DNA시스템)
```
```

---

## 📝 ADR 작성 예시 (주식 거래 플랫폼)

### 예시 1: 외부 제약 ADR

```markdown
# ADR-002: KIS API 호출 제한 대응

**상태**: Accepted
**카테고리**: 외부제약
**작성일**: 2024-01-15

---

## 제약 조건

| 항목 | 내용 |
|------|------|
| 출처 | 한국투자증권 KIS API 문서 |
| 제약 내용 | 초당 20회 호출 제한, 초과 시 일시 차단 |
| 위반 시 영향 | API 차단으로 서비스 중단 |

## 대응 방안

1. Rate Limiter 구현
   - 초당 15회로 제한 (5회 여유분)
   - Token Bucket 알고리즘 사용
   
2. 요청 큐잉
   - 초과 요청은 큐에 대기
   - 최대 대기 시간: 5초

3. 벌크 요청 최적화
   - 여러 종목 조회 → 배치 API 활용

## 결과

- core/external/kis_client.py에 RateLimiter 구현
- 모든 KIS API 호출은 rate_limiter를 거쳐야 함
- 모니터링: 초당 호출 수, 큐 대기 시간
```

---

### 예시 2: 충돌 해결 ADR

```markdown
# ADR-101: 정확성 우선 전략

**상태**: Accepted
**카테고리**: 충돌해결
**작성일**: 2024-01-15

---

## 맥락

주문 처리에서 정확성(금액 정확)과 속도(빠른 응답)가 충돌.
캐시 사용 시 속도↑ but 정확성 위험.

## 검토한 대안

### 대안 1: 캐시 전면 사용
- 장점: 응답 속도 200ms → 50ms
- 단점: 가격 불일치 가능, 금융 사고 위험
- 거부 이유: 금융 거래에서 정확성 타협 불가

### 대안 2: 실시간 조회 전면 사용
- 장점: 100% 정확
- 단점: 모든 요청 500ms, 시세 조회도 느림
- 거부 이유: 시세 조회까지 느릴 필요 없음

### 대안 3: 하이브리드 (선택)
- 주문 관련: 항상 실시간
- 시세 조회: 1초 캐시 허용
- 장점: 정확성 + 사용성 균형

## 결정

**선택**: 대안 3 (하이브리드)

**핵심 근거**:
1. 주문 정확성은 금융 서비스의 핵심 가치
2. 시세 조회는 1초 지연 허용 가능
3. 사용자 경험과 안전성 균형

## 결과

### 긍정적 영향
- ✅ 주문 금액 100% 정확
- ✅ 시세 조회 응답 속도 개선

### 트레이드오프
- ⚠️ 주문 응답 500ms (캐시 사용 시 50ms)

### 부정적 영향
- ❌ 구현 복잡도 증가 (해결: 명확한 분리 설계)

## 재검토 조건

- 주문 응답 시간이 1초 초과 시
- 정확도 관련 이슈 발생 시
```

---

### 예시 3: 기술 스택 ADR

```markdown
# ADR-201: PostgreSQL 선택

**상태**: Accepted
**카테고리**: 기술스택
**작성일**: 2024-01-15

---

## 맥락

CRUD/트랜잭션 패밀리(A-A-B)로, ACID 준수 DB 필요.
주문, 계좌, 포트폴리오 데이터 저장.

## 대안 비교

| 기준 | PostgreSQL | MySQL | MongoDB |
|------|------------|-------|---------|
| ACID | ✅ 완전 지원 | ✅ 지원 | ⚠️ 제한적 |
| JSON 지원 | ✅ JSONB | ⚠️ JSON | ✅ 네이티브 |
| 복잡 쿼리 | ✅ 우수 | ⚠️ 보통 | ❌ 제한적 |
| 비용 | 무료 | 무료 | Atlas$$$ |
| 팀 경험 | ✅ 있음 | ✅ 있음 | ⚠️ 적음 |
| 비동기 | asyncpg | aiomysql | motor |

## 결정

**선택**: PostgreSQL 15

**핵심 근거**:
1. ACID 완전 지원 (금융 거래 필수)
2. JSONB로 유연한 스키마 가능 (설정, 메타데이터)
3. 팀 경험 있음, 생태계 풍부

## 결과

- ORM: SQLAlchemy 2.0 (async 지원)
- 마이그레이션: Alembic
- 연결: asyncpg (비동기)
- 풀링: connection pool size 20
```

---

## ✅ Stage 3 완료 체크리스트

```
□ ADR 구조 설정
  □ docs/adr/ 디렉토리 생성
  □ 카테고리별 하위 디렉토리 생성
  □ 03A-000_adr_index.md 생성

□ 카테고리 1: 외부 제약 ADR
  □ Stage 2 02C-01 기반 작성
  □ 법규, API 제한, 시간 제약 등
  □ 최소 1개 이상

□ 카테고리 2: 충돌 해결 ADR
  □ Stage 2 02C-02 기반 작성
  □ 각 충돌 패턴별 해결 전략
  □ 최소 1개 이상

□ 카테고리 3: 기술 스택 ADR
  □ Stage 2 02D-01 기반 작성
  □ DB, 프레임워크, 캐시 등
  □ 주요 기술별 1개씩

□ 카테고리 4: 도메인 기술 ADR
  □ 핵심 비즈니스 로직 설계
  □ 데이터 모델, API 설계

□ 카테고리 5: DNA 시스템 ADR
  □ 로깅, 에러 처리, 설정 관리
  □ 테스트, 인증 전략

□ ADR Index 업데이트
  □ 모든 ADR 등록
  □ 상태별 요약
  □ 의존성 그래프
```

---

## 🔜 다음 단계

### Stage 3 → Stage 4 전달 사항

| 항목 | 예시 | Stage 4에서 사용 |
|------|------|-----------------|
| DNA 시스템 ADR | ADR-401~499 | DNA 시스템 청사진 |
| 기술 스택 ADR | ADR-201~299 | 개발 환경 설정 |
| 도메인 기술 ADR | ADR-301~399 | 도메인 청사진 |

### Stage 4에서 할 일
- 🔄 DNA 시스템 ADR 기반 청사진 작성
- 🔄 src/core/ 모듈 구조 설계
- 🔄 공통 컴포넌트 인터페이스 정의

**다음 문서**: `04G-00_dna_system_blueprint_guide.md`

---

## ⏪ 이전 Stage 검증 및 수정 프로토콜

### 검증 시점
- Stage 3 시작 전 필수 체크
- 각 ADR 카테고리 작성 완료 후 재검증

### 검증 대상

| Stage | 산출물 | 검증 항목 |
|-------|--------|----------|
| Stage 1 | 01C-01_*.md (패밀리) | ADR이 패밀리 특성과 일치? |
| Stage 1 | 01C-01_*.md (NFR) | ADR이 NFR 우선순위 반영? |
| Stage 2 | 02C-01_*.md (제약) | 기술 제약이 ADR에 반영? |
| Stage 2 | 02C-01_*.md (충돌) | 충돌 해결이 ADR로 문서화? |

### 오류 발견 시 프로토콜

```
Stage 3에서 Stage 1-2 오류 발견 시:

Step 1: 오류 발견 및 문서화
├─ 발견 위치: ADR-[NNN] 작성 중
├─ 오류 내용: [구체적 설명]
├─ 영향 Stage: Stage [1 또는 2]
└─ 기록: 해당 ADR에 "발견된 이슈" 추가

Step 2: 영향 범위 파악
├─ Stage 1 영향: 패밀리/NFR 수정 필요?
├─ Stage 2 영향: 제약/충돌 분석 수정 필요?
├─ 재작업 예상: [X]시간
└─ 기록 완료

Step 3: 해당 Stage로 이동 → 수정
├─ 01C-01 또는 02C-01 수정
├─ 버전 업데이트
└─ 수정 검증

Step 4: Stage 3 재진행
├─ 수정된 입력으로 ADR 재검토
├─ 관련 ADR 업데이트
└─ 일관성 확인

Step 5: 검증
├─ 오류 해결 확인
└─ Stage 4 전달 가능 ✅
```

### 흔한 오류 패턴

| 오류 유형 | 예시 | 해결 |
|----------|------|------|
| NFR 충돌 누락 | 성능 vs 보안 충돌 미식별 | Stage 2 충돌 분석 추가 |
| 제약 미반영 | 예산으로 SaaS 불가인데 ADR에 SaaS 선택 | Stage 2 제약 재검토 |
| 패밀리 불일치 | 실시간 패밀리인데 배치 DB 선택 | Stage 1 재검토 또는 ADR 수정 |

### 추적성

```
수정 이력 파일: docs/revision_log.md

기록 형식:
## [날짜] Stage 3 → Stage [N] 수정
- **발견 ADR**: ADR-[NNN]
- **오류**: [오류 내용]
- **수정 Stage**: Stage [N]
- **수정 내용**: [구체적 수정]
- **영향 ADR**: [재검토 필요한 ADR 목록]
- **검증**: [검증 결과]
```

---

## 📚 참고 문서

| 문서 | 용도 |
|------|------|
| `01_DNA_METHODOLOGY_DETAILED.md` Part 4 | Stage 3 상세 원리 |
| `IMPLEMENTATION_CASES.md` | ADR 실전 사례 |
| `./standards/01_STAGE_STRUCTURE.md` | Stage 간 연결 구조 |

---

## 💡 핵심 원칙 요약

```
ADR 작성의 3가지 원칙:

1. "왜"를 기록
   - 코드는 "무엇"을 보여줌
   - ADR은 "왜"를 설명
   - 나중에 질문에 답할 수 있어야 함

2. 대안을 기록
   - 선택한 것만 기록 ❌
   - 검토한 대안과 거부 이유도 기록 ✅
   - 재검토 시 불필요한 반복 방지

3. 결과를 예측
   - 긍정적 영향
   - 트레이드오프
   - 부정적 영향과 완화 방안
```

```
카테고리 분류 원칙:

1. 외부 제약: "변경 불가, 따라야 함"
2. 충돌 해결: "둘 다 원하지만 선택해야 함"
3. 기술 스택: "여러 대안 중 하나 선택"
4. 도메인 기술: "직접 설계해야 함"
5. DNA 시스템: "전체에 영향, 일관성 핵심"
```

---

**버전 이력**:
- v5.0 (2025-12-03): Gemini 연구 기반 전면 재작성, 01_DNA_METHODOLOGY_DETAILED.md 기준
- v3.0 (2025-11-13): Stage 3 분리
- v2.0 (2025-11-12): ADR 유형 구분
- v1.0 (2025-11-10): 초기 버전


================================================================================

📄 FILE: 04G-00_dna_planning_guide.md
--------------------------------------------------------------------------------

# Stage 4: DNA 시스템 청사진 가이드 (DNA Blueprint Guide)

> **목적**: Stage 3 ADR 기반으로 DNA 시스템 11개의 설계 청사진 작성
>
> **버전**: v4.1 (2025-12-03)
>
> - v4.0 (2025-12-03): Gemini 연구 기반 전면 재작성, 01_DNA_METHODOLOGY_DETAILED.md 기준
> - v1.0 (2025-11-13): 초기 버전

---

## 📚 이 가이드의 위치

```
DNA 방법론 문서 체계:

Tier 1: 00_CORE_METHODOLOGY.md (전체 맥락)
           ↓
Tier 2: 01_DNA_METHODOLOGY_DETAILED.md (상세 원리)
           ↓
Tier 3: 이 문서 (Stage 4 실행 가이드) ← 지금 여기!
```

**참조 문서**:
- **원리 이해**: `01_DNA_METHODOLOGY_DETAILED.md` Part 5
- **DNA 상세**: `standards/03_DNA_SYSTEMS_GUIDE.md`

---

## 🧬 DNA 방법론 4대 핵심 원칙 (Stage 4 적용)

> **"AI가 한 세션에서 최고 성과를 낼 수 있는 크기로 작업하고, 완전해질 때까지 반복하며, 오류 발견 시 되돌아가서 수정한다"**

Stage 4 (DNA 시스템 청사진)에서 DNA 4대 핵심 원칙이 적용되는 방식:

---

### DNA 핵심 원칙 1: AI 최적 크기

**"컨텍스트 범위 내에서 작업한다"**

#### Stage 4의 작업 크기 전략

```
❌ 잘못된 접근: 11개 DNA 시스템 청사진 한 번에
"11개 DNA 시스템 청사진을 한 세션에서 모두 작성하세요"
→ 컨텍스트 초과 (200K 토큰 한계)
→ 후반부 청사진 품질 저하 (상세도 감소)
→ 시스템 간 일관성 부족

✅ 올바른 접근: 시스템 유형별 순차 작성
Session 1: 기초 시스템 (Logging + Types)
Session 2: 데이터 시스템 (Database + Cache)
Session 3: 통신 시스템 (Messaging + API Gateway)
Session 4: 보안/운영 시스템 (Security + Monitoring)
Session 5: 설정/테스트/에러 (Config + Testing + Error)

각 세션: 2-3개 시스템, 80-90K 토큰 범위
```

#### 컨텍스트 구성 (각 세션)

```
AI 컨텍스트 윈도우 (예: 200K 토큰):
├─ 시스템 프롬프트: ~30K 토큰
├─ 대화 히스토리: ~20K 토큰
├─ Stage 3 참조 문서: ~30-40K 토큰
│   ├─ 03A-401_dna_logging.md (ADR)
│   ├─ 03A-402_dna_types.md (ADR)
│   └─ 03A-000_adr_index.md (인덱스)
├─ DNA 시스템 가이드: ~20K 토큰
│   └─ standards/03_DNA_SYSTEMS_GUIDE.md (해당 섹션)
├─ 작업 중 청사진 작성: ~20K 토큰 (2-3개 × 8-10K)
└─ 응답 생성 여유: ~80K 토큰
```

#### 세션당 작업량 기준

| 세션 | DNA 시스템 | 청사진 크기 | 총 토큰 |
|-----|-----------|-----------|---------|
| Session 1 | Logging, Types | 각 8-10K | ~20K |
| Session 2 | Database, Cache | 각 10-12K | ~24K |
| Session 3 | Messaging, API Gateway | 각 8-10K | ~20K |
| Session 4 | Security, Monitoring | 각 8-10K | ~20K |
| Session 5 | Config, Testing, Error | 각 6-8K | ~21K |

**핵심**: 한 세션에 2-3개 DNA 시스템 청사진이 최적

#### 그룹화 원칙: 의존성 기반

```
그룹 1: 기초 (Foundation)
├─ Logging: 로그 출력
└─ Types: 타입 정의
  → 다른 모든 시스템이 의존

그룹 2: 데이터 (Data)
├─ Database: 영구 저장
└─ Cache: 임시 저장
  → 비즈니스 로직이 의존

그룹 3: 통신 (Communication)
├─ Messaging: 비동기 통신
└─ API Gateway: HTTP 통신
  → 외부 연동이 의존

그룹 4: 보안/운영 (Security/Ops)
├─ Security: 인증/인가
└─ Monitoring: 관찰성
  → 프로덕션 배포 필수

그룹 5: 지원 (Support)
├─ Config: 설정 관리
├─ Testing: 테스트 도구
└─ Error: 에러 처리
  → 개발/배포 지원
```

---

### DNA 핵심 원칙 2: 완전해질 때까지 반복

**"부족하면 반복해서 부족함이 없어질 때까지"**

#### DNA 시스템 청사진 완전성 기준

각 DNA 시스템 청사진은 다음을 모두 포함해야 함:

```
✅ 완전한 DNA 청사진 체크리스트:
□ 1. 목적 및 범위 (Purpose & Scope)
   - 이 시스템이 해결하는 문제
   - 담당 범위와 책임
   - 다른 시스템과의 경계

□ 2. 공개 API (Public API)
   - 함수/클래스 시그니처
   - 입력/출력 타입
   - 사용 예시 (코드)

□ 3. 디렉토리 구조 (Directory Structure)
   - 파일 목록과 역할
   - 모듈 간 의존성
   - 명명 규칙

□ 4. 핵심 설계 결정 (Design Decisions)
   - ADR 참조 (명시적)
   - 아키텍처 패턴
   - 성능/보안 고려사항

□ 5. 의존성 (Dependencies)
   - 외부 라이브러리 (버전 명시)
   - 다른 DNA 시스템 의존
   - 순환 의존성 없음 보장

□ 6. 테스트 전략 (Testing Strategy)
   - 단위 테스트 범위
   - 통합 테스트 시나리오
   - 목표 커버리지 (95%+)

□ 7. 구현 우선순위 (Implementation Priority)
   - 어떤 파일부터 구현?
   - 의존성 순서
   - Stage 5 작업 단위
```

#### 3단계 검증 프로토콜

**검증 프로토콜 (의사코드)**:

```python
def validate_dna_blueprint_session(blueprints: list[Blueprint]) -> ValidationResult:
    """DNA 청사진 세션 완전성 검증."""

    # 검증 1: 각 청사진 구조 검증
    for bp in blueprints:
        if not all([
            bp.has_purpose_and_scope(),
            bp.has_public_api(),
            bp.has_directory_structure(),
            bp.has_design_decisions(),
            bp.has_dependencies(),
            bp.has_testing_strategy(),
            bp.has_implementation_priority()
        ]):
            return ValidationResult(
                passed=False,
                message=f"Blueprint {bp.name}: 7개 섹션 중 누락 발견",
                action="해당 청사진 재작성"
            )

    # 검증 2: 의존성 일관성 검증
    for bp in blueprints:
        for dep in bp.dependencies:
            if dep not in [b.name for b in blueprints] and not dep.startswith("external:"):
                return ValidationResult(
                    passed=False,
                    message=f"Blueprint {bp.name}: 정의되지 않은 의존성 {dep}",
                    action="의존성 추가 또는 제거"
                )

    # 검증 3: ADR 추적성 검증
    for bp in blueprints:
        if not bp.has_adr_references():
            return ValidationResult(
                passed=False,
                message=f"Blueprint {bp.name}: ADR 참조 누락",
                action="Stage 3 ADR 참조 추가"
            )

    # 검증 4: 순환 의존성 검증
    if has_circular_dependency(blueprints):
        return ValidationResult(
            passed=False,
            message="순환 의존성 발견",
            action="의존성 방향 재설계"
        )

    return ValidationResult(passed=True)
```

#### 불완전 → 재작성 사례

```markdown
## 사례: DNA Observability System (Logging) 청사진

### ❌ 불완전한 버전 (1차 작성)
**목적**: 로그를 기록한다
**API**: `log(message)`
**구조**: 로깅 모듈 하나

❌ 문제점:
- 범위 불명확 (콘솔? 파일? 외부 전송?)
- API 너무 단순 (레벨은? 컨텍스트는?)
- 구조 불충분 (설정은? 포맷터는?)
- ADR 참조 없음
- 의존성 명시 없음
- 테스트 전략 없음
- 구현 순서 없음

### ✅ 완전한 버전 (2차 재작성)

#### 1. 목적 및 범위
**문제**: 분산 시스템에서 추적 가능한 구조화된 로그 필요
**범위**:
- 구조화된 로그 (JSON/structured format)
- 컨텍스트 자동 추가 (request_id, user_id 등)
- 다중 출력 (콘솔 + 파일 + 클라우드)
**제외**: 로그 수집/분석 (외부 시스템)

#### 2. 공개 API (개념)
```
기본 사용:
├─ get_logger(module_name) → logger
├─ logger.info(message, context_data)
├─ logger.warning(message, context_data)
└─ logger.error(message, context_data)

컨텍스트 바인딩:
└─ logger.bind(key=value) → 이후 로그에 자동 포함

예외 로깅:
└─ logger.exception(message) → 자동 스택트레이스 포함
```

#### 3. 디렉토리 구조 (개념)
```
core/logging/
├─ [entry point]         # 공개 API 제공
├─ [logger impl]         # Logger 구현
├─ [config]              # 설정 (레벨, 포맷)
├─ [formatters]          # JSON/Console 포맷터
├─ [handlers]            # File/Cloud 핸들러
└─ [context]             # Context 관리
```

#### 4. 핵심 설계 결정
- **Ref**: ADR-401 (로깅 도구 선택)
- **패턴**: Singleton Logger Factory
- **성능**: 비동기 파일 쓰기

#### 5. 의존성
- External: [로깅 라이브러리] (ADR-401 참조)
- External: [비동기 I/O 라이브러리] (필요 시)
- DNA: Type System (LogLevel 타입)

#### 6. 테스트 전략
- 단위: 각 포맷터/핸들러 격리 테스트
- 통합: 전체 로그 파이프라인 E2E 테스트
- 커버리지: 95%+

#### 7. 구현 우선순위
1. LogLevel 타입 정의 - 기초
2. 설정 모듈 - 설정
3. 포맷터 - 핵심
4. Logger 구현 - 핵심
5. Context 관리 - 고급
6. 핸들러 - 확장

**참조**: 구체적 파일명/코드는 언어별 매뉴얼 참조
```

---

### DNA 핵심 원칙 3: 기능별 분해 + 연결부 + 조립

**"모듈이 크면 기능별로 나누고, 연결부 설계 후 조립"**

#### Stage 4에서의 적용

Stage 4는 "청사진 설계" 단계이므로 원칙 3은 **계획 차원**에서 적용됩니다.

```
DNA 시스템 크기 판단:
├─ 작은 시스템 (< 5 파일): 한 번에 청사진 작성
│   예: Types, Config, Error
│
├─ 중간 시스템 (5-10 파일): 청사진에서 모듈 명시
│   예: Logging, Cache, Testing
│   청사진: 모듈별 섹션 분리
│
└─ 큰 시스템 (10+ 파일): 청사진을 모듈별로 분할
    예: Database (Connection + Session + Query + Migration)
    청사진: 각 모듈별 별도 섹션 + 연결부 명시
```

#### 큰 DNA 시스템 청사진 분해 전략

```markdown
## 사례: DNA Database 시스템 (큰 시스템)

### 청사진 구조 (모듈별 분해)

#### Module 1: Connection Pool
**책임**: 데이터베이스 연결 관리
**파일**: `connection.py`
**공개 API**:
- `get_connection_pool() -> Pool`
- `close_pool()`

#### Module 2: Session Manager
**책임**: 트랜잭션 세션 관리
**파일**: `session.py`
**공개 API**:
- `get_session() -> AsyncSession`
- `begin_transaction()`

#### Module 3: Query Builder
**책임**: 타입 안전한 쿼리 빌더
**파일**: `query.py`
**공개 API**:
- `select(model: Type[T]) -> Query[T]`
- `insert(model: T) -> None`

#### Module 4: Migration
**책임**: 스키마 버전 관리
**파일**: `migration.py`
**공개 API**:
- `migrate_up()`
- `migrate_down()`

### 연결부 설계 (Interface/Protocol)

```
연결부: 인터페이스 기반 설계
─────────────────────────────────

ConnectionProvider (인터페이스):
├─ get_connection() → Connection
└─ 목적: 연결 제공 추상화

SessionProvider (인터페이스):
├─ get_session() → Session
└─ 목적: 세션 제공 추상화

모듈 간 의존성:
├─ Module 1 구현 → ConnectionProvider
├─ Module 2 구현 → SessionProvider
├─ Module 3은 SessionProvider 의존
└─ Module 4는 ConnectionProvider 의존

**참조**: 언어별 인터페이스 구현 방법은 매뉴얼 참조
  - Python: Protocol, ABC
  - TypeScript: interface
  - Rust: trait
  - Go: interface
```

### Stage 5 구현 계획 (조립 전략)

```
Task 001: Connection Pool 구현
├─ connection.py 작성
├─ ConnectionProvider 구현
└─ 테스트 (Mock 없음, 실제 Pool)

Task 002: Session Manager 구현
├─ session.py 작성
├─ SessionProvider 구현
├─ ConnectionProvider Mock 사용
└─ 테스트

Task 003: Query Builder 구현
├─ query.py 작성
├─ SessionProvider Mock 사용
└─ 테스트

Task 004: Migration 구현
├─ migration.py 작성
├─ ConnectionProvider Mock 사용
└─ 테스트

Task 999: Database 통합 (조립)
├─ 실제 구현체로 Mock 교체
├─ 통합 테스트 (E2E)
└─ 성능 테스트
```
```

#### 작은 DNA 시스템 청사진 전략

```markdown
## 사례: DNA Types 시스템 (작은 시스템)

### 단일 청사진 (분해 불필요)

#### 목적
타입 안전성 보장을 위한 공통 타입 정의

#### 디렉토리 구조
```
src/core/types/
├─ __init__.py
├─ ids.py        # UserId, OrderId 등
├─ enums.py      # Status, Level 등
└─ models.py     # BaseModel, DTO 등
```

#### 구현 계획 (한 번에)
Task 001: DNA Types 전체 구현
├─ ids.py, enums.py, models.py 모두 작성
├─ 테스트 전체
└─ 완료 (분해 불필요)
```

---

### DNA 핵심 원칙 4: 역방향 수정 프로토콜

**"앞선 결정의 오류 발견 시 → 되돌아가서 수정 → 다시 현재까지 진행"**

#### Stage 4에서 역방향 수정이 발생하는 경우

```
시나리오 1: Stage 3 ADR 오류 발견
├─ Stage 4 청사진 작성 중
├─ ADR-401 (로깅 도구 선택) 제약 발견
│   예: 선택된 도구가 특정 플랫폼에서 문제 발견
├─ → Stage 3로 돌아가 ADR-401 수정
├─ → Stage 4 청사진 재작성
└─ → 추적성 업데이트

시나리오 2: Stage 5에서 청사진 불완전 발견
├─ Stage 5 Observability 구현 중
├─ 청사진에 비동기 로그 쓰기 누락 발견
├─ → Stage 4로 돌아가 청사진 보완
├─ → Stage 5 구현 재진행
└─ → 추적성 업데이트
```

#### 6단계 수정 프로토콜

```markdown
## 실제 사례: DNA Database 청사진 수정

### Step 1: 오류 발견 및 문서화
**발견 시점**: Stage 4 (Data System 청사진 작성 중)
**파일**: `04B-01_dna_blueprint.md`
**문제**: ADR-201에서 "[DB-A]"인데, 청사진에 "[DB-B]" 언급

### Step 2: 영향 범위 파악
**영향받는 문서**:
- Stage 3: `03A-402_database_selection.md` (확인 필요)
- Stage 4: `04D-02_dna_database_blueprint.md` (현재)

**영향받는 구현**: 없음 (아직 구현 전)

### Step 3: 해당 Stage로 이동 및 수정
```bash
# Stage 3 ADR 재확인
$ cat 03A-402_database_selection.md
  → "PostgreSQL 13+" 맞음

# Stage 4 청사진 수정
$ edit 04D-02_dna_database_blueprint.md
  Line 45: MySQL → PostgreSQL로 수정
  Line 67: MySQL 전용 기능 제거
  Line 89: PostgreSQL 전용 기능 추가 (JSONB, Full-text search)
```

### Step 4: 중간 Stage 전파
Stage 5 아직 시작 안 함 → 전파 불필요

### Step 5: 현재 Stage 재진행
```bash
# Stage 4 청사진 재검토
$ review 04D-02_dna_database_blueprint.md
  - PostgreSQL 전용 기능 반영 확인
  - ADR-402 참조 업데이트
  - 의존성에 psycopg3 추가
```

### Step 6: 재진행 결과 검증
**검증 항목**:
- [ ] ADR-402 "PostgreSQL 13+" 확인
- [ ] 청사진 7개 섹션 완전
- [ ] MySQL 언급 모두 제거
- [ ] PostgreSQL 전용 기능 추가
- [ ] 추적성 명시 (Ref: ADR-402)
```

#### 추적성 (Traceability) 유지

**모든 수정은 명시적으로 참조**:

```markdown
## Stage 3 ADR (03A-402_database_selection.md)
**결정**: PostgreSQL 13+ 사용
**날짜**: 2024-11-10

## Stage 4 청사진 (04D-02_dna_database_blueprint.md)
Line 1: # DNA Database 시스템 청사진
Line 2: # Ref: ADR-402 (PostgreSQL 13+)
Line 3:
Line 4: > **History**:
Line 5: > - v1.0 (2024-11-10): 초기 작성
Line 6: > - v1.1 (2024-11-11): MySQL → PostgreSQL 수정 (ADR 불일치 발견)

Line 45: ## 데이터베이스 엔진
Line 46: **선택**: PostgreSQL 13+
Line 47: **Ref**: ADR-402 (Line 23-45)
Line 48: **전용 기능**:
Line 49: - JSONB 타입
Line 50: - Full-text search
Line 51: - Row-level security

## Stage 5 구현 (src/core/database/)
Line 1: # Ref: 04D-02_dna_database_blueprint.md
Line 2: # Updated: 2024-11-11 (PostgreSQL 전용 기능 반영)
```

---

## 🎯 DNA 원칙 적용 요약 (Stage 4)

| 원칙 | Stage 4 적용 방법 | 체크포인트 |
|------|------------------|-----------|
| **1. AI 최적 크기** | 시스템 유형별 세션 분리 (2-3개/세션) | 세션당 80-90K 토큰 |
| **2. 완전해질 때까지** | 7개 섹션 완전성, 4단계 검증 | 모든 청사진 7 sections |
| **3. 기능별 분해** | 큰 시스템은 모듈별 분해 + Protocol | Protocol + Mock + 조립 |
| **4. 역방향 수정** | 6단계 프로토콜, 추적성 유지 | History/Ref 명시 |

---

## 🤔 왜 DNA 시스템 청사진이 필요한가?

### Bridge의 의미: "Gap이 아니라 다리"

```
기존 오해:
├─ Stage 3 (ADR) 완료
├─ ???
├─ ???
├─ ???
└─ Stage 7 (Blueprint) 시작

→ "Stage 4-6은 뭐하는 거지? 그냥 넘어가도 되나?"

실제:
┌─────────────────────────────────────────────────────────┐
│ Stage 4-6 = Bridge (다리)                               │
│                                                         │
│ ADR (결정) ──────────────────────→ Blueprint (설계)     │
│             ↑                   ↑                       │
│             │    Stage 4-6     │                       │
│             │                   │                       │
│             └───────────────────┘                       │
│                                                         │
│ 결정을 "실행 가능한 환경"으로 변환하는 단계             │
└─────────────────────────────────────────────────────────┘
```

### 비유: 집 짓기

```
ADR = "서울에서 부산 가기로 결정" (결정)
Bridge = "KTX 티켓 구매, 역 도착" (준비)
Blueprint = "출발역, 환승, 도착역 계획" (상세 계획)

ADR = "콘크리트 기초로 결정" (결정)
Bridge = "콘크리트 배합, 거푸집 준비" (환경 구축)
Blueprint = "각 방의 기초 위치와 크기" (상세 설계)
```

### DNA 시스템 = 환경/플랫폼

```
┌─────────────────────────────────────────────────────────┐
│                    도메인 코드                          │
│  (Stage 7-9에서 구현)                                   │
│                                                         │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐                   │
│  │ 주문    │ │ 계좌    │ │ 시세    │  ← 비즈니스 로직  │
│  │ 서비스  │ │ 서비스  │ │ 서비스  │                   │
│  └────┬────┘ └────┬────┘ └────┬────┘                   │
│       │          │          │                          │
│  ═════╪══════════╪══════════╪═══════════════════════   │
│       │          │          │                          │
│  ┌────┴──────────┴──────────┴────┐                     │
│  │        DNA 시스템 (환경)       │                     │
│  │  (Stage 4-6에서 구축)          │                     │
│  │                                │                     │
│  │  logging / config / types     │                     │
│  │  database / cache / messaging │                     │
│  │  testing / monitoring / auth  │                     │
│  └────────────────────────────────┘                     │
└─────────────────────────────────────────────────────────┘

핵심:
├─ DNA가 먼저 구축되어야 도메인이 일관되게 구현됨
├─ 도메인은 DNA를 "사용"만 함 (직접 구현 X)
└─ DNA 변경 = 전체 영향 (신중해야)
```

---

## 📥 입력 문서

### Stage 3에서 전달받는 것

| 파일 | 핵심 내용 | 이 Stage에서 사용 |
|------|----------|-----------------|
| `03A-401~499_*.md` | DNA 시스템 ADR | 각 시스템 설계 근거 |
| `03A-201~299_*.md` | 기술 스택 ADR | 구현 기술 선택 |
| `03A-000_adr_index.md` | ADR 목록 | 전체 결정 참조 |

---

## 📤 출력 문서

### 필수 산출물

```
docs/
├── 04B-01_dna_blueprint.md        # DNA 시스템 청사진 (통합)
└── 04B-02_dna_directory.md        # 디렉토리 구조 상세

또는 시스템별 분리:
docs/dna-blueprint/
├── 04B-00_overview.md             # 전체 개요
├── 04B-01_logging.md              # 로깅 시스템
├── 04B-02_config.md               # 설정 시스템
├── 04B-03_types.md                # 타입 시스템
├── 04B-04_errors.md               # 에러 처리
├── 04B-05_database.md             # 데이터베이스
├── 04B-06_cache.md                # 캐시
├── 04B-07_messaging.md            # 메시징
├── 04B-08_testing.md              # 테스팅
├── 04B-09_monitoring.md           # 모니터링
├── 04B-10_security.md             # 보안
└── 04B-11_api_gateway.md          # API 게이트웨이
```

---


## 🧬 DNA 11개 시스템

> **참조**: `standards/03_DNA_SYSTEMS_GUIDE.md` - 언어 무관 개념 및 상세 설명

### 시스템 개요

```
┌──────────────────────────────────────────────────────────┐
│                  DNA 11개 시스템                         │
│              (언어 무관 - Language Agnostic)              │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  핵심 인프라 (4개):                                      │
│  ├─ 1. Type System: 타입 안전성 보장                    │
│  ├─ 2. Observability System: 로깅/메트릭/추적           │
│  ├─ 3. Testing System: 품질 보증                        │
│  └─ 4. Code Quality System: 일관된 스타일               │
│                                                          │
│  아키텍처/설정 (3개):                                    │
│  ├─ 5. Architecture Enforcement: 경계 유지              │
│  ├─ 6. Configuration System: 설정 관리                  │
│  └─ 7. Error Handling System: 에러 처리                 │
│                                                          │
│  성능/통신/데이터/보안 (4개):                            │
│  ├─ 8. Performance System: 성능 측정                    │
│  ├─ 9. API System: 인터페이스/통신                      │
│  ├─ 10. Data System: 저장/조회                          │
│  └─ 11. Security System: 인증/인가                      │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

### 시스템별 상세

| # | 시스템 | 목적 | ADR 참조 | 디렉토리 예시 |
|---|--------|------|---------|-------------|
| 1 | Type System | 타입 안전성, 런타임 에러 방지 | ADR-301 | `core/types/` |
| 2 | Observability System | 시스템 상태 관찰, 디버깅 | ADR-401, ADR-901 | `core/logging/`, `core/monitoring/` |
| 3 | Testing System | 품질 보증, 95%+ 커버리지 | ADR-801 | `tests/` |
| 4 | Code Quality System | 일관된 스타일, 자동 검증 | ADR-302 | `.pre-commit-config.yaml` |
| 5 | Architecture Enforcement | Layer 경계, 의존성 제어 | ADR-102 | `.importlinter` |
| 6 | Configuration System | 환경 변수, 의존성 관리 | ADR-601 | `core/config/` |
| 7 | Error Handling System | 에러 타입, 일관된 처리 | ADR-701 | `core/errors/` |
| 8 | Performance System | 벤치마크, 프로파일링 | ADR-902 | `benchmarks/` |
| 9 | API System | 인터페이스 정의, 통신 | ADR-501 | `api/` |
| 10 | Data System | 데이터 접근, 캐싱, 메시징 | ADR-201, ADR-202 | `core/database/`, `core/cache/` |
| 11 | Security System | 인증, 인가, 입력 검증 | ADR-1001 | `core/security/` |

---

## 🎯 패밀리별 DNA 시스템 선택

### 모든 패밀리 공통 (필수 5개)

```
항상 필요 (언어/프로젝트 무관):
├─ 1. Type System (타입 안전성 필수)
├─ 2. Observability System (디버깅 불가능 방지)
├─ 3. Testing System (품질 보증 필수)
├─ 4. Code Quality System (일관성 유지)
└─ 7. Error Handling System (에러 처리 표준화)
```

### 패밀리별 선택 가이드

| DNA 시스템 | A-A-B (CRUD) | B-C-A (스트리밍) | B-A-A (협업) | B-B-B (검색) |
|-----------|-------------|----------------|-------------|-------------|
| 5. Architecture Enforcement | ✅ 권장 | ✅ 권장 | ✅ 권장 | ✅ 권장 |
| 6. Configuration System | ✅ 필수 | ✅ 필수 | ✅ 필수 | ✅ 필수 |
| 8. Performance System | ✅ 권장 | ✅ 필수 | ✅ 권장 | ✅ 권장 |
| 9. API System | ✅ 필수 | ✅ 필수 | ✅ 필수 | ✅ 필수 |
| 10. Data System | ✅ 필수 | ⚠️ 선택 | ✅ 필수 | ⚠️ 선택 |
| 11. Security System | ✅ 필수 | ⚠️ 선택 | ✅ 필수 | ⚠️ 선택 |

**범례**: ✅ 필수 / ⚠️ 프로젝트에 따라 선택

### 패밀리별 특화 설정

**A-A-B (CRUD/트랜잭션)** - 예: 주식 거래 플랫폼
```
필수: 전체 11개 (금융 서비스 특성)
├─ Data System: ACID 트랜잭션 필수
├─ Security System: 필수 (금융 규제)
├─ Observability System: 감사 추적 필수
└─ Performance System: 응답 시간 모니터링
```

**B-C-A (실시간 스트리밍)** - 예: IoT 센서 데이터
```
필수: 9개 (Data System, Security System 선택)
├─ Data System: 스트림 처리 (메시징)
├─ Performance System: 지연 모니터링 필수
├─ Observability System: 분산 추적
└─ API System: 실시간 통신 (WebSocket)
```

**B-A-A (협업/동기화)** - 예: 실시간 문서 편집
```
필수: 10개 이상
├─ Data System: 상태 저장 + 캐싱
├─ API System: 실시간 동기화
├─ Security System: 사용자 인증 필수
└─ Performance System: 동시성 모니터링
```

---


## 📋 청사진 작성 방법

### Part 1: 시스템 선택 결정

```
Step 1: 패밀리 확인
─────────────────────────────────
01C-01_family.md에서 패밀리 확인
→ A-A-B (CRUD/트랜잭션)

Step 2: 필수/선택 시스템 결정
─────────────────────────────────
필수 (공통 5개):
- Logging, Config, Types, Error, Testing

필수 (패밀리별):
- Database (A-A-B이므로)
- Security (금융이므로)
- API Gateway (웹 서비스이므로)

선택:
- Cache (읽기 최적화 원함 → 포함)
- Monitoring (운영 필수 → 포함)
- Messaging (MVP 이후 → 제외)

Step 3: ADR 확인
─────────────────────────────────
ADR-301: 타입 도구 선택
ADR-401: 로깅 도구 선택
ADR-701: 에러 처리 전략
ADR-201: 데이터 저장소 선택
ADR-202: 캐싱 전략 선택

Step 4: 청사진 포맷 결정
─────────────────────────────────
**통합 청사진 (04B-01_dna_blueprint.md)** vs **분리 청사진 (04B-00~11_*.md)**

통합 청사진 사용 조건:
├─ DNA 시스템 < 5개
├─ 프로젝트 규모 작음 (MVP)
└─ 한 세션에서 전체 청사진 작성 가능

분리 청사진 사용 조건:
├─ DNA 시스템 5-7개
├─ 프로젝트 규모 중간 이상
├─ 세션별로 나눠 작성 필요
└─ 시스템별 독립 유지보수 필요

대규모 프로젝트 (8+ 시스템):
└─ 분리 청사진 필수
    ├─ 04B-00_overview.md (전체 개요)
    ├─ 04B-01~11_*.md (시스템별)
    └─ 각 세션 2-3개 시스템씩

권장:
├─ 첫 프로젝트: 통합 청사진 (간단함)
└─ 운영 프로젝트: 분리 청사진 (유지보수성)
```

---

### Part 2: 디렉토리 구조 설계

**참조**: 언어/프레임워크별 구조는 해당 언어 매뉴얼 참조

```
Step 1: 기본 구조 결정
─────────────────────────────────
프로젝트 루트/
├── src/ (또는 lib/, pkg/)      # 소스 코드
│   ├── core/                   # DNA 시스템
│   ├── domain/                 # 도메인 로직 (Stage 7-9)
│   └── api/                    # API 레이어 (Stage 7-9)
│
├── tests/                      # 테스트 코드
│   ├── unit/                   # 단위 테스트
│   └── integration/            # 통합 테스트
│
└── docs/                       # 문서

Step 2: core/ 상세 구조
─────────────────────────────────
src/core/
├── types/              # Type System (ADR-301)
├── logging/            # Observability System (ADR-401)
├── monitoring/         # Observability System (ADR-901)
├── config/             # Configuration System (ADR-601)
├── errors/             # Error Handling System (ADR-701)
├── database/           # Data System (ADR-201)
├── cache/              # Data System (ADR-202)
├── security/           # Security System (ADR-1001)
└── performance/        # Performance System (ADR-902)
```

---

### Part 3: 인터페이스 설계

각 DNA 시스템의 **공개 API 원칙**을 정의합니다.

```
1. Type System
─────────────────────────────────
목적: 타입 안전한 도메인 모델 제공
공개 API:
├─ 공통 타입 (ID, Value Object)
├─ 도메인 모델 베이스
└─ 타입 검증 함수

2. Observability System
─────────────────────────────────
목적: 로깅, 메트릭, 추적 통합
공개 API:
├─ get_logger(name) → 로거 반환
├─ log(level, message, context) → 구조화된 로그
└─ trace_context() → trace_id 전파

3. Configuration System
─────────────────────────────────
목적: 환경별 설정 관리
공개 API:
├─ get_config(key) → 설정 값
├─ validate_config() → 설정 검증
└─ reload_config() → 동적 리로드

4. Error Handling System
─────────────────────────────────
목적: 일관된 에러 처리
공개 API:
├─ 에러 타입 (NotFound, Validation, etc.)
├─ error_to_response() → 에러 변환
└─ log_error() → 에러 로깅

5. Data System
─────────────────────────────────
목적: 데이터 접근 추상화
공개 API:
├─ get_connection() → DB 연결
├─ transaction() → 트랜잭션 관리
└─ cache(key, value) → 캐싱

6. Security System
─────────────────────────────────
목적: 인증/인가
공개 API:
├─ authenticate() → 인증
├─ authorize(role) → 인가
└─ validate_input() → 입력 검증

**참조**: 구체적 코드 예시는 언어별 매뉴얼 참조
```

---

### Part 4: 구현 순서 결정

의존성 기반으로 구현 순서를 결정합니다.

```
의존성 그래프:
─────────────────────────────────

Types (의존성 없음)
   ↓
Config (Types 의존)
   ↓
Logging (Config, Types 의존)
   ↓
Error (Types, Logging 의존)
   ↓
Database (Config, Types, Error 의존)
   ↓
Cache (Config, Types, Error 의존)
   ↓
Security (Config, Types, Error, Database 의존)
   ↓
Testing (전체 의존)
   ↓
Monitoring (Logging, Config 의존)
   ↓
API Gateway (전체 의존)

권장 구현 순서:
─────────────────────────────────
1. Types      → 의존성 없음, 먼저 구현
2. Config     → Types만 의존
3. Logging    → Config, Types 의존
4. Error      → Types, Logging 의존
5. Testing    → 위 4개 테스트 가능해야
6. Database   → 위 4개 + Testing
7. Cache      → 위 4개 + Testing
8. Security   → 위 전체
9. Monitoring → Logging, Config
10. API GW    → 전체 통합
```

---


## 📋 청사진 템플릿

### 04B-01_dna_blueprint.md 템플릿

```markdown
# DNA 시스템 청사진

**프로젝트**: [프로젝트명]
**패밀리**: [패밀리 코드] ([패밀리명])
**작성일**: YYYY-MM-DD

**참조**: standards/03_DNA_SYSTEMS_GUIDE.md (시스템별 상세 설명)

---

## 1. 선택된 DNA 시스템

### 1.1 필수 시스템 (공통)

| # | 시스템 | 목적 | ADR 참조 |
|---|--------|------|---------|
| 1 | Type System | 타입 안전성, 런타임 에러 방지 | ADR-301 |
| 2 | Observability System | 로깅, 메트릭, 분산 추적 | ADR-401, ADR-901 |
| 3 | Testing System | 품질 보증, 95%+ 커버리지 | ADR-801 |
| 4 | Code Quality System | 일관된 스타일, 품질 유지 | ADR-302, ADR-303 |

### 1.2 필수 시스템 (패밀리)

| # | 시스템 | 목적 | ADR 참조 | 선택 근거 |
|---|--------|------|---------|----------|
| 5 | Architecture Enforcement | 레이어 경계, 의존성 제어 | ADR-501 | 복잡도 관리 |
| 10 | Data System | DB, 캐시, 메시징 | ADR-201, ADR-204 | 데이터 관리 |
| 11 | API System | 인터페이스 정의, 프로토콜 | ADR-202 | 통신 표준화 |

### 1.3 선택 시스템

| # | 시스템 | 목적 | ADR 참조 | 선택 근거 |
|---|--------|------|---------|----------|
| 6 | Configuration System | 환경별 설정 관리 | ADR-601 | 환경 분리 |
| 8 | Performance System | 벤치마킹, 프로파일링 | ADR-701 | 성능 기준 |

### 1.4 제외 시스템

| # | 시스템 | 제외 근거 | 추가 시점 |
|---|--------|----------|----------|
| 7 | Error Handling System | 기본 예외 처리로 충분 | Phase 2 |
| 9 | Security System | MVP 범위 외 | Phase 3 |

---

## 2. 디렉토리 구조

```
src/
├── core/                    # DNA 시스템 모듈
│   ├── types/              # Type System
│   ├── logging/            # Observability System (Logging)
│   ├── monitoring/         # Observability System (Metrics)
│   ├── config/             # Configuration System
│   ├── errors/             # Error Handling System
│   ├── database/           # Data System (DB)
│   ├── cache/              # Data System (Cache)
│   └── security/           # Security System
├── domain/                 # 도메인 로직
└── api/                    # API 레이어

tests/
├── unit/                   # 단위 테스트
├── integration/            # 통합 테스트
└── conftest.py            # 테스트 공통 설정

**참조**: 구체적 파일명/확장자는 언어별 매뉴얼 참조
```

---

## 3. 각 시스템 상세

### 3.1 Type System

**ADR 참조**: ADR-301 (타입 도구 선택)

**디렉토리**: `core/types/`

**목적**:
- 타입 안전한 도메인 모델 제공
- 런타임 에러 방지
- IDE 자동완성 지원

**공개 API (개념)**:
```
├─ 공통 타입 (ID, Value Object)
├─ 도메인 모델 베이스
└─ 타입 검증 함수
```

**설정**:
- 개발: Strict mode, 모든 타입 체크
- 운영: 런타임 검증 추가

**참조**: 구체적 코드 예시는 언어별 매뉴얼 참조

---

### 3.2 Observability System

**ADR 참조**: ADR-401 (로깅 도구), ADR-901 (모니터링 도구)

**디렉토리**: `core/logging/`, `core/monitoring/`

**목적**:
- 구조화된 로깅 (JSON/structured)
- 분산 추적 (trace_id)
- 성능 메트릭 수집

**공개 API (개념)**:
```
로깅:
├─ get_logger(name) → logger instance
├─ logger.info/warning/error(message, **context)
└─ context binding (trace_id, user_id)

메트릭:
├─ counter(name, labels)
├─ histogram(name, value)
└─ gauge(name, value)
```

**설정**:
- 개발: Console, 컬러 출력, DEBUG
- 운영: JSON, 파일/클라우드, INFO

**금지 사항**:
- ❌ print() / console.log() 직접 사용
- ❌ 민감 정보 로깅 (비밀번호, 토큰)

**참조**: 구체적 코드 예시는 언어별 매뉴얼 참조

---

### 3.3 Data System

**ADR 참조**: ADR-201 (DB 선택), ADR-204 (캐시 선택)

**디렉토리**: `core/database/`, `core/cache/`

**목적**:
- 데이터 영속성 (Database)
- 성능 최적화 (Cache)
- 트랜잭션 관리

**공개 API (개념)**:
```
Database:
├─ Session management
├─ Transaction control
└─ Migration tools

Cache:
├─ get(key) → value | null
├─ set(key, value, ttl)
└─ delete(key)
```

**설정**:
- DB 연결 문자열 (환경변수)
- 캐시 TTL, 메모리 제한
- 트랜잭션 격리 수준

**참조**: 구체적 코드 예시는 언어별 매뉴얼 참조

---

[... 다른 시스템도 동일 패턴 ...]

---

## 4. 구현 순서

| 순서 | 시스템 | 의존성 | 예상 시간 |
|------|--------|-------|----------|
| 1 | Type System | 없음 | 2시간 |
| 2 | Configuration System | Type System | 2시간 |
| 3 | Observability System | Config, Types | 3시간 |
| 4 | Error Handling System | Types, Observability | 3시간 |
| 5 | Testing System | 위 4개 | 4시간 |
| 6 | Data System | 위 5개 | 4시간 |
| 7 | Architecture Enforcement | 위 5개 | 3시간 |
| 8 | Security System | 위 전체 | 4시간 |
| 9 | Performance System | Observability, Config | 3시간 |
| 10 | API System | 전체 | 4시간 |

**총 예상 시간**: 32시간 (약 4일)

---

## 5. 의존성 그래프

```
Type System
   ↓
Configuration System ← Observability System
   ↓                      ↓
Error Handling System ←──┘
   ↓
Data System ← Architecture Enforcement
   ↓
Security System
   ↓
Testing System → Performance System → API System
```

---

## 6. Stage 5 전달 사항

- [ ] 각 시스템별 상세 설계 완료
- [ ] 공개 API 정의 완료
- [ ] 구현 순서 결정 완료
- [ ] 예상 시간 산정 완료
```

---


## 📝 청사진 작성 예시 (주식 거래 플랫폼)

### 예시: Observability System 청사진 (Logging 부분)

```markdown
### 3.1 Observability System (Logging)

**ADR 참조**: ADR-401 (로깅 도구 선택)

**디렉토리**: `core/logging/`

**목적**:
- 구조화된 로깅으로 디버깅 효율 향상
- 분산 추적 ID로 요청 추적
- 환경별 로그 레벨/포맷 제어

**파일 구성 (개념)**:
```
core/logging/
├── [entry point]        # get_logger, configure_logging 제공
├── [logger impl]        # 로깅 도구 래퍼
├── [config]             # 로그 설정 (레벨, 포맷)
└── [processors]         # 컨텍스트 추가 (trace_id 주입)
```

**공개 API (개념)**:
```
기본 사용:
├─ get_logger(module_name) → logger
├─ logger.info(message, context_data)
├─ logger.warning(message, context_data)
└─ logger.error(message, context_data)

컨텍스트 바인딩:
└─ logger.bind(key=value) → 이후 모든 로그에 자동 포함

예외 로깅:
└─ logger.exception(message) → 자동 스택트레이스 포함
```

**설정**:
| 환경 | 포맷 | 레벨 | 출력 |
|------|------|------|------|
| 개발 | Console (컬러/읽기 쉬움) | DEBUG | 터미널 |
| 스테이징 | JSON (구조화) | INFO | 터미널 + 파일 |
| 운영 | JSON (구조화) | INFO | 터미널 + 클라우드 |

**필수 컨텍스트**:
- `trace_id`: 분산 추적 ID (미들웨어 자동 주입)
- `user_id`: 인증된 사용자 ID (인증 후 바인딩)
- `request_id`: 요청 고유 ID (미들웨어 자동 주입)

**금지 사항**:
- ❌ print() / console.log() 직접 사용 (ADR-401)
- ❌ 표준 라이브러리 로거 직접 사용
- ❌ 민감 정보 로깅 (비밀번호, 토큰, 카드번호)

**Stage 5 구현 항목**:
- [ ] Logger 모듈 구현
- [ ] Config 모듈 구현
- [ ] Processors 구현 (trace_id, user_id 주입)
- [ ] 단위 테스트 작성

**참조**: 구체적 코드 예시는 언어별 매뉴얼 참조
```

---

### 예시: Error Handling System 청사진

```markdown
### 3.4 Error Handling System

**ADR 참조**: ADR-404 (에러 처리 표준)

**디렉토리**: `core/errors/`

**목적**:
- 일관된 에러 응답 형식
- 에러 코드 체계로 문제 추적
- API 레이어 자동 변환

**파일 구성 (개념)**:
```
core/errors/
├── [entry point]        # 예외 클래스 제공
├── [exceptions]         # 예외 계층 정의
├── [codes]              # 에러 코드 상수/Enum
└── [handlers]           # API 예외 핸들러
```

**예외 계층 (개념)**:
```
AppError (기본 예외)
├─ code: 에러 코드
├─ message: 사용자 메시지
└─ status_code: HTTP 상태 코드

DomainError (도메인 로직 에러)
├─ NotFoundError (404)
├─ ValidationError (400)
└─ ConflictError (409)

ExternalError (외부 시스템 에러)
├─ APIError (502)
└─ TimeoutError (504)
```

**에러 코드 체계**:
```
1xxx: 도메인 에러
├─ 1001: 리소스 없음 (NotFound)
├─ 1002: 중복 생성 (Conflict)
└─ 1003: 검증 실패 (Validation)

2xxx: 외부 API 에러
├─ 2001: API Rate Limit
└─ 2002: API Timeout

9xxx: 시스템 에러
├─ 9001: 데이터베이스 에러
└─ 9002: 캐시 에러
```

**사용 패턴 (개념)**:
```
예외 발생:
└─ throw NotFoundError(code="1001", message="...", context_data)

API 응답 형식:
{
  "error": {
    "code": "1001",
    "message": "리소스를 찾을 수 없습니다",
    "details": { ... }
  }
}
```

**금지 사항**:
- ❌ 일반 예외 throw (반드시 AppError 계층 사용)
- ❌ 예외 무시 (catch 후 아무것도 안 함)
- ❌ 에러 코드 없는 예외 발생

**Stage 5 구현 항목**:
- [ ] 예외 계층 구현
- [ ] 에러 코드 정의
- [ ] API 핸들러 구현
- [ ] 단위 테스트 작성

**참조**: 구체적 코드 예시는 언어별 매뉴얼 참조
```

---

## ✅ Stage 4 완료 체크리스트

```
□ 시스템 선택
  □ 패밀리 확인 (01C-01)
  □ 필수 시스템 5개 확인
  □ 패밀리별 필수 시스템 결정
  □ 선택 시스템 결정 + 근거
  □ 제외 시스템 명시 + 추가 시점

□ 디렉토리 구조
  □ src/core/ 구조 설계
  □ tests/ 구조 설계
  □ 각 시스템별 파일 목록

□ 각 시스템 상세
  □ 공개 API 정의
  □ 설정 항목 정의
  □ 금지 사항 명시
  □ Stage 5 구현 항목 목록

□ 구현 계획
  □ 의존성 그래프 작성
  □ 구현 순서 결정
  □ 예상 시간 산정

□ 산출물 생성
  □ 04B-01_dna_blueprint.md 작성
  □ (선택) 시스템별 분리 문서
```

---

## 🔜 다음 단계

### Stage 4 → Stage 5 전달 사항

| 항목 | 예시 | Stage 5에서 사용 |
|------|------|-----------------|
| DNA 청사진 | 04B-01_dna_blueprint.md | 구현 가이드 |
| 시스템별 상세 | 각 시스템 설계 | 코드 구현 |
| 구현 순서 | 의존성 기반 순서 | 작업 스케줄 |

### Stage 5에서 할 일
- 🔄 청사진 기반 src/core/ 모듈 구현
- 🔄 각 시스템별 테스트 작성
- 🔄 통합 테스트로 시스템 간 연동 검증

**다음 문서**: `05G-00_dna_implementation_guide.md`

---

## ⏪ 이전 Stage 검증 및 수정 프로토콜

### 검증 시점
- Stage 4 시작 전 필수 체크
- DNA 시스템 선택 후 ADR과 교차 검증

### 검증 대상

| Stage | 산출물 | 검증 항목 |
|-------|--------|----------|
| Stage 1 | 01C-01_*.md | DNA 수준이 패밀리 특성에 적합? |
| Stage 2 | 02C-01_*.md | 기술 제약이 DNA 선택에 반영? |
| Stage 3 | 03A-*_*.md | ADR 결정이 DNA 설계에 반영? |

### 오류 발견 시 프로토콜

```
Stage 4에서 Stage 1-3 오류 발견 시:

Step 1: 오류 발견 및 문서화
├─ 발견 위치: DNA 시스템 [N] 설계 중
├─ 오류 내용: [구체적 설명]
├─ 영향 Stage: Stage [1, 2, 또는 3]
└─ 기록: 04B-01에 "발견된 이슈" 추가

Step 2: 영향 범위 파악
├─ Stage 1: 패밀리/NFR 수정 필요?
├─ Stage 2: 제약/충돌 수정 필요?
├─ Stage 3: ADR 수정/추가 필요?
└─ 재작업 예상: [X]시간

Step 3: 해당 Stage로 이동 → 수정
├─ 해당 산출물 수정
├─ 버전 업데이트
└─ 수정 검증

Step 4: 중간 Stage 전파 (해당 시)
├─ Stage 2, 3 영향 확인
└─ 필요 시 수정

Step 5: Stage 4 재진행
├─ 수정된 입력으로 DNA 청사진 재검토
└─ 일관성 확인

Step 6: 검증 → Stage 5 전달 ✅
```

### 흔한 오류 패턴

| 오류 유형 | 예시 | 해결 |
|----------|------|------|
| ADR 누락 | 로깅 레벨 결정 없이 DNA 설계 | Stage 3 ADR 추가 |
| 패밀리 불일치 | 실시간인데 L2 로깅 선택 | Stage 1 재검토 또는 DNA 수준 상향 |
| 제약 미반영 | 팀 경험 없는 기술 DNA에 포함 | Stage 2 제약 반영 |

### 추적성

```
수정 이력: docs/revision_log.md
```

---

## 📚 참고 문서

| 문서 | 용도 |
|------|------|
| `01_DNA_METHODOLOGY_DETAILED.md` Part 5 | Stage 4-6 상세 원리 |
| `standards/03_DNA_SYSTEMS_GUIDE.md` | DNA 시스템 상세 설명 |
| `./standards/01_STAGE_STRUCTURE.md` | Stage 간 연결 구조 |

---

## 💡 핵심 원칙 요약

```
DNA 청사진 작성의 3가지 원칙:

1. 패밀리 기반 선택
   - 모든 패밀리 공통 5개 필수
   - 패밀리별 추가 시스템 선택
   - 제외 시스템도 근거와 추가 시점 명시

2. 의존성 기반 순서
   - Types → Config → Logging → Error
   - 의존성 없는 것부터 구현
   - 테스트는 중간에 (기반 4개 후)

3. 인터페이스 우선
   - 공개 API 먼저 정의
   - 사용법 예시 제공
   - 금지 사항 명확히
```

```
Bridge(Stage 4-6)의 4대 구성요소:

1. 성문화된 결정 (Stage 3)
   = ADR 문서
   → 비유: 법률

2. 청사진 (Stage 4)
   = DNA 시스템 설계
   → 비유: 건축 도면

3. 구현된 코드 (Stage 5)
   = src/core/ 모듈
   → 비유: 공구

4. 강제 규칙 (Stage 6)
   = PROJECT_STANDARDS.md
   → 비유: 교통법규
```

---

**버전 이력**:
- v5.0 (2025-12-03): Gemini 연구 기반 전면 재작성, 01_DNA_METHODOLOGY_DETAILED.md 기준
- v1.0 (2025-11-13): 초기 버전


================================================================================

📄 FILE: 05G-00_dna_implementation_guide.md
--------------------------------------------------------------------------------

# Stage 5: DNA 시스템 구현 가이드 (DNA Implementation Guide)

> **목적**: Stage 4 청사진 기반으로 src/core/ DNA 시스템 실제 구현
>
> **버전**: v4.1 (2025-12-03)
>
> - v5.0 (2025-12-03): Gemini 연구 기반 전면 재작성, 01_DNA_METHODOLOGY_DETAILED.md 기준
> - v1.0 (2025-11-13): 초기 버전

---

## 📚 이 가이드의 위치

```
DNA 방법론 문서 체계:

Tier 1: 00_CORE_METHODOLOGY.md (전체 맥락)
           ↓
Tier 2: 01_DNA_METHODOLOGY_DETAILED.md (상세 원리)
           ↓
Tier 3: 이 문서 (Stage 5 실행 가이드) ← 지금 여기!
```

**참조 문서**:

- **원리 이해**: `01_DNA_METHODOLOGY_DETAILED.md` **Part 5**
- **DNA 상세**: `./standards/03_DNA_SYSTEMS_GUIDE.md`

---

## 🧬 DNA 방법론 4대 핵심 원칙 (Stage 5 적용)

> **"AI가 한 세션에서 최고 성과를 낼 수 있는 크기로 작업하고, 완전해질 때까지 반복하며, 기능별로 분해하여 조립한다"**

Stage 5 (DNA 시스템 구현)에서 DNA 4대 핵심 원칙이 적용되는 방식:

---

### DNA 핵심 원칙 1: AI 최적 크기

**"컨텍스트 범위 내에서 작업한다"**

#### Stage 5의 작업 크기 전략

```
❌ 잘못된 접근: 11개 DNA 시스템 한 번에 구현
"11개 DNA 시스템을 한 세션에서 모두 구현하세요"
→ 컨텍스트 초과 (200K 토큰 한계)
→ 후반부 구현 품질 저하
→ 테스트 누락, 타입 오류, print() 사용 등
→ 품질 게이트 실패

✅ 올바른 접근: 시스템별 순차 구현
Session 1: Logging 시스템 구현 (완전)
Session 2: Types 시스템 구현 (완전)
Session 3: Database 시스템 구현 (완전)
Session 4: Cache 시스템 구현 (완전)
...
Session 11: Error 시스템 구현 (완전)

각 세션: 1개 시스템 완전 구현 + 테스트, 80-90K 토큰
```

#### 컨텍스트 구성 (각 세션)

```
AI 컨텍스트 윈도우 (예: 200K 토큰):
├─ 시스템 프롬프트: ~30K 토큰
├─ 대화 히스토리: ~20K 토큰
├─ Stage 4 청사진: ~10-15K 토큰
│   └─ 04D-0X_dna_XXX_blueprint.md (해당 시스템)
├─ Stage 6 프로젝트 표준: ~10-15K 토큰
│   └─ 06D-01_project_standards.md (관련 섹션)
├─ Stage 3 ADR 참조: ~5-10K 토큰
│   └─ 03A-40X_dna_XXX.md
├─ 구현 코드 작성: ~20-25K 토큰
│   ├─ core/XXX/* (구현 파일들)
│   └─ tests/core/XXX/* (테스트 파일들)
└─ 응답 생성 여유: ~80-90K 토큰

**참조**: 파일 확장자는 언어별로 다름 (.py, .ts, .rs, .go 등)
```

#### 세션당 작업량 기준

| DNA 시스템               | 파일 수 (근사치) | 테스트 파일 | 총 토큰 | 세션 수        |
| ------------------------ | ---------------- | ----------- | ------- | -------------- |
| Type System              | 3-4개            | 3-4개       | ~15K    | 1 session      |
| Configuration System     | 2-3개            | 2-3개       | ~12K    | 1 session      |
| Error Handling System    | 3-4개            | 3-4개       | ~15K    | 1 session      |
| Observability System     | 5-6개            | 5-6개       | ~20K    | 1 session      |
| Data System (Cache)      | 4-5개            | 4-5개       | ~18K    | 1 session      |
| Testing System           | 4-5개            | 4-5개       | ~18K    | 1 session      |
| Security System          | 6-7개            | 6-7개       | ~22K    | 1 session      |
| Performance System       | 5-6개            | 5-6개       | ~20K    | 1 session      |
| API System               | 6-7개            | 6-7개       | ~22K    | 1 session      |
| Data System (DB)         | 8-10개           | 8-10개      | ~28K    | **2 sessions** |
| Architecture Enforcement | 4-5개            | 4-5개       | ~18K    | 1 session      |

**핵심**: 대부분 시스템은 1 세션, Data System (DB)만 2 세션

**참조**: 파일 수는 언어/프로젝트에 따라 다를 수 있음. 핵심은 "AI 최적 크기 (80-90K 토큰)"

#### Data System (DB) 분해 전략 (유일한 예외)

```
Data System (DB)는 유일하게 2 세션 필요:

Session 1: DB 기초 (Connection + Session)
├─ connection.*: Connection Pool 구현
├─ session.*: Session Manager 구현
├─ protocols.*: ConnectionProvider, SessionProvider 정의
└─ 테스트 (각 모듈 격리)
  → ~25K 토큰

Session 2: DB 고급 (Query + Migration)
├─ query.*: Query Builder 구현
├─ migration.*: Schema Migration 구현
├─ integration.*: 모듈 통합
└─ 테스트 (통합 테스트 포함)
  → ~25K 토큰

**참조**: 파일 확장자는 언어별로 다름 (.py, .ts, .rs, .go 등)
```

---

### DNA 핵심 원칙 2: 완전해질 때까지 반복

**"부족하면 반복해서 부족함이 없어질 때까지"**

#### DNA 시스템 구현 완전성 기준

각 DNA 시스템 구현은 다음을 모두 포함해야 함:

```
✅ 완전한 DNA 구현 체크리스트:
□ 1. 공개 API 구현
   - 청사진의 모든 함수/클래스 구현
   - 타입 안전성 완전 (타입 체커 0 오류, ADR-301 참조)
   - 문서 주석 (프로젝트 표준 참조)

□ 2. 내부 헬퍼 구현
   - Private 함수/클래스
   - 유틸리티 모듈
   - 상수/설정

□ 3. 에러 처리
   - 예외 처리 적절히 배치
   - 커스텀 예외 정의
   - 에러 로깅 (직접 출력 금지, ADR-401 참조)

□ 4. 로깅 통합
   - Observability System 통합
   - 모든 중요 시점에 로그
   - 표준 로거 사용 (ADR-401)

□ 5. 테스트 작성 (TDD)
   - 단위 테스트: 각 함수/클래스
   - 통합 테스트: 모듈 간 상호작용
   - 커버리지: 95%+
   - 테스트 프레임워크 (ADR-801 참조)

□ 6. 품질 검증 (Zero-Tolerance)
   - Linter: 0 오류 (ADR-302 참조)
   - Type Checker: 0 오류 (ADR-301 참조)
   - Import 규칙: 0 위반 (ADR-501 참조)
   - 테스트: 100% pass

□ 7. 문서화
   - Entry point: 공개 API 노출
   - README: 사용 예시
   - 주석: 복잡한 로직 설명
```

#### 3단계 검증 프로토콜

```
검증 함수: validate_dna_implementation(system_name)
─────────────────────────────────────────────────

검증 1: 청사진 대비 완성도
├─ 청사진 읽기: 04B-01_dna_blueprint.md
├─ 구현 파일 탐색: core/{system_name}/*
└─ 각 공개 API 구현 확인:
    ├─ 미구현 발견 시:
    │   ├─ passed: false
    │   ├─ message: "{system_name}: 공개 API {api} 미구현"
    │   └─ action: "해당 API 구현"
    └─ 모두 구현됨 → 검증 2로

검증 2: 품질 게이트 (Zero-Tolerance)
├─ Linter 실행 (ADR-302):
│   └─ 오류 > 0 → 실패, "Linter 오류 수정"
├─ Type Checker 실행 (ADR-301):
│   └─ 오류 > 0 → 실패, "타입 오류 수정"
├─ Import 규칙 검증 (ADR-501):
│   └─ 위반 > 0 → 실패, "Import 규칙 수정"
└─ 모두 통과 → 검증 3으로

검증 3: 테스트 커버리지
├─ 테스트 실행 (ADR-801):
│   └─ tests/core/{system_name}/
├─ 커버리지 측정:
│   └─ < 95% → 실패, "테스트 추가"
└─ >= 95% → passed: true

**참조**: 구체적 도구/명령어는 언어별 매뉴얼 참조
```

#### 불완전 → 재구현 사례

```markdown
## 사례: DNA Observability System (Logging) 구현

### ❌ 불완전한 버전 (1차 구현)

**파일**: core/logging/logger.*

함수: get_logger(name)
  ❌ 타입 정보 없음 (반환 타입 미지정)
  └─ 표준 라이브러리 로거 반환

클래스: Logger
  └─ 메서드: info(msg)
      ❌ 타입 정보 없음
      ❌ 직접 출력 사용! (print/console.log)

**품질 검증 실패**:

Type Checker (ADR-301):
  logger.*:3: error: Missing return type
  logger.*:6: error: Missing type for 'msg'
  → Type Checker: 2 errors

Linter (ADR-302):
  logger.*:8: 직접 출력 금지 (print/console.log)
  → Linter: 1 error

테스트 (ADR-801):
  → Coverage: 45% (목표: 95%)

❌ 문제점:
- 타입 정보 누락 → Type Checker 오류
- 직접 출력 사용 → Linter 위반
- 테스트 부족 → 커버리지 45%
- 청사진의 context() 미구현

### ✅ 완전한 버전 (2차 재구현)

**파일**: core/logging/logger.*

함수: get_logger(name: string) → Logger
  ✅ 타입 정보 완전
  ✅ 문서 주석 포함
  └─ 구조화된 로거 반환 (ADR-401 도구 사용)

클래스: Logger
  ├─ 생성자(logger: LoggerImpl) → Logger
  │   ✅ 타입 정보 완전
  │
  ├─ info(msg: string, context: map) → void
  │   ✅ 타입 정보 완전
  │   ✅ 구조화된 로깅 사용 (ADR-401)
  │   └─ 직접 출력 없음!
  │
  └─ context(context: map) → LogContext
      ✅ 청사진 API 완전 구현

**테스트 파일**: tests/core/logging/test_logger.*


테스트 1: get_logger가 Logger 인스턴스 반환
  └─ get_logger("test") → Logger 타입 확인

테스트 2: info()가 메시지 로깅
  └─ logger.info("테스트", key="value")
      → 로그에 메시지/컨텍스트 포함 확인

테스트 3: context()가 컨텍스트 추가
  └─ logger.context(request_id="123")로
      → 이후 로그에 request_id 자동 포함 확인

**품질 검증 성공**:

Type Checker (ADR-301):
  → Success: no issues found

Linter (ADR-302):
  → All checks passed!

테스트 (ADR-801):
  → Coverage: 97% ✅

**참조**: 구체적 코드 예시는 언어별 매뉴얼 참조
```

---

### DNA 핵심 원칙 3: 기능별 분해 + 연결부 + 조립

**"모듈이 크면 기능별로 나누고, 연결부 설계 후 조립"**

#### Stage 5에서의 적용 (가장 중요!)

Stage 5는 **실제 코드 구현** 단계이므로 원칙 3이 **직접 적용**됩니다!

```markdown
DNA 시스템 크기별 전략:

작은 시스템 (< 5 파일):
├─ 한 세션에 전체 구현
└─ 분해 불필요
    예: Type System, Configuration System, Error Handling System

중간 시스템 (5-7 파일):
├─ 한 세션에 구현 가능
├─ 모듈 간 의존성 관리
└─ Interface/Protocol 정의
    예: Observability System, Data System (Cache), Testing System

큰 시스템 (8+ 파일):
├─ 기능별 분해 필수!
├─ Interface/Protocol 정의 (연결부)
├─ 각 기능 독립 구현
└─ 마지막에 조립
    예: Data System (DB) - 유일한 케이스!
```

#### Data System (DB) 분해 실전 (개념)

**참조**: 구체적 코드는 언어별 매뉴얼 참조

```markdown
Task 000: Interface/Protocol 정의 (연결부)
─────────────────────────────────────────

목적: 모듈 간 연결 인터페이스 정의

정의할 Interface:
├─ ConnectionProvider: DB 연결 제공
│   └─ get_connection() → Connection
├─ SessionProvider: DB 세션 제공
│   └─ get_session() → Session
└─ 테스트: Interface 정의만, 구현 없음

---

Task 001: Connection Pool 구현
─────────────────────────────────────────

목적: DB 연결 풀 관리

구현 체크리스트:
□ ConnectionPool 클래스
  ├─ ConnectionProvider 구현
  ├─ 연결 생성/관리/해제
  └─ 설정 주입 (DB URL, pool size 등)

□ 테스트 (Mock 없음, 실제 DB 사용)
  ├─ 연결 생성 테스트
  ├─ 연결 풀 관리 테스트
  └─ 동시성 테스트

□ 품질 검증
  ├─ Type Checker: 0 오류
  ├─ Linter: 0 오류
  └─ Coverage: 95%+

---

Task 002: Session Manager 구현
─────────────────────────────────────────

목적: 트랜잭션 관리, 세션 라이프사이클

구현 체크리스트:
□ SessionManager 클래스
  ├─ SessionProvider 구현
  ├─ ConnectionProvider Mock 사용 (의존성)
  ├─ 트랜잭션 관리 (begin/commit/rollback)
  └─ 설정 주입

□ 테스트 (ConnectionProvider Mock)
  ├─ 세션 생성 테스트
  ├─ 트랜잭션 테스트 (commit/rollback)
  └─ 에러 처리 테스트

□ 품질 검증: Type/Lint/Coverage

---

Task 999: Database 통합 (조립)
─────────────────────────────────────────

목적: 모든 모듈 통합, 공개 API 제공

통합 체크리스트:
□ 공개 API 모듈 (entry point)
  ├─ ConnectionPool, SessionManager import
  ├─ 실제 구현체 생성
  └─ get_session() 함수 제공

□ 통합 테스트 (E2E)
  ├─ Mock 없음, 실제 DB 사용
  ├─ 전체 플로우 테스트
  └─ 성능 테스트 (선택)

□ 최종 검증
  ├─ 모든 공개 API 동작 확인
  ├─ Type/Lint/Coverage 통과
  └─ 문서화 완료 (README, 사용 예시)
```

---

#### 작은/중간 시스템 구현 전략

**개념**: 작은 시스템 (< 5 파일)은 한 세션에 전체 구현

**예시: Type System (분해 불필요)**

```markdown
한 세션 구현 체크리스트:
□ 도메인 타입 정의 (ID types: UserId, OrderId 등)
□ Enum 타입 (LogLevel, Status 등)
□ Value Objects (Email, Money 등)
□ Base 클래스 (BaseEntity, BaseValueObject)
□ 테스트 (모든 타입 생성/검증)
□ 품질 검증 (Type/Lint/Coverage)
```

**참조**: 구체적 코드는 언어별 매뉴얼 참조

**결과**: 1 세션에 전체 완성 (분해 불필요)

---

### DNA 핵심 원칙 4: 역방향 수정 프로토콜

**"앞선 결정의 오류 발견 시 → 되돌아가서 수정 → 다시 현재까지 진행"**

#### Stage 5에서 역방향 수정이 발생하는 경우

```markdown
시나리오 1: Stage 4 청사진 오류 발견
├─ Stage 5 Logging 구현 중
├─ 청사진에 비동기 로그 쓰기 누락 발견
├─ → Stage 4로 돌아가 청사진 보완
├─ → Stage 5 재구현
└─ → 추적성 업데이트

시나리오 2: Stage 3 ADR 오류 발견
├─ Stage 5 Database 구현 중
├─ ADR-402 "PostgreSQL 13+"가 실제로는 14+ 필요
├─ → Stage 3로 돌아가 ADR-402 수정
├─ → Stage 4 청사진 업데이트
├─ → Stage 5 재구현
└─ → 추적성 업데이트

시나리오 3: 구현 중 설계 결함 발견
├─ Stage 5 Cache 구현 중
├─ Redis 연결 풀 전략이 청사진과 다르게 필요
├─ → Stage 4 청사진 수정
├─ → Stage 5 재구현
└─ → 추적성 업데이트
```

#### 6단계 수정 프로토콜

````markdown
## 실제 사례: Logging 시스템 비동기 쓰기 추가

### Step 1: 오류 발견 및 문서화
**발견 시점**: Stage 5 (Observability System 구현 중)
**파일**: `core/logging/handlers.*`
**문제**: 파일 핸들러가 동기 쓰기라 성능 저하
          청사진에 비동기 쓰기 언급 없음

### Step 2: 영향 범위 파악
**영향받는 문서**:
- Stage 4: `04B-01_dna_blueprint.md` (청사진 수정 필요)
- Stage 3: `03A-401_*.md` (ADR 확인 - 수정 불필요)

**영향받는 구현**:
- `core/logging/handlers.*` (재구현 필요)
- `tests/core/logging/test_handlers.*` (재작성 필요)

### Step 3: 해당 Stage로 이동 및 수정
```bash
# Stage 4 청사진 수정
$ edit 04D-01_dna_logging_blueprint.md
  Line 67: 동기 파일 쓰기 → 비동기 파일 쓰기
  Line 78: aiofiles 의존성 추가
  Line 89: FileHandler → AsyncFileHandler

# 수정 이유 명시
> **History**:
> - v1.0 (2024-11-10): 초기 청사진
> - v1.1 (2024-11-12): 비동기 쓰기 추가 (성능 개선)

### Step 4: 중간 Stage 전파

Stage 5 진행 중이므로 즉시 반영

### Step 5: 현재 Stage 재진행

```
Stage 5 재구현 절차:

1. 기존 구현 제거
   ├─ core/logging/handlers.* 삭제
   └─ tests/core/logging/test_handlers.* 삭제

2. 수정된 청사진 기반 재구현
   ├─ AsyncFileHandler 클래스
   │   └─ 비동기 파일 쓰기 구현
   ├─ 비동기 I/O 라이브러리 사용 (ADR-401 참조)
   └─ 설정 주입 (파일 경로 등)

3. 테스트 재작성
   ├─ 비동기 테스트 작성
   ├─ 파일 쓰기/읽기 검증
   └─ 에러 처리 테스트

**참조**: 구체적 코드는 언어별 매뉴얼 참조
```

### Step 6: 재진행 결과 검증

```
품질 검증:
├─ Type Checker (ADR-301): 0 오류 ✅
├─ Linter (ADR-302): 0 오류 ✅
└─ 테스트 (ADR-801): Coverage 97% ✅

검증 체크리스트:
□ 청사진 v1.1 반영 확인
□ 비동기 쓰기 구현 완료
□ 비동기 I/O 의존성 추가
□ 품질 게이트 통과 (Type/Lint: 0 오류)
□ 테스트 커버리지 95%+
□ 추적성 명시 (Ref: 04B-01 v1.1)
```
````

#### 추적성 (Traceability) 유지

**모든 수정은 명시적으로 참조**

````
추적성 예시: 파일 헤더 주석

```
파일: core/logging/handlers.*
목적: 비동기 파일 핸들러

참조: 04B-01_dna_blueprint.md v1.1 (Section 3.2)
수정일: 2024-11-12 (비동기 쓰기로 변경)
사유: 동기 쓰기 성능 저하 → 비동기 쓰기 필요
```

청사진 버전 이력 예시:

```
파일: 04B-01_dna_blueprint.md

History:
- v1.0 (2024-11-10): 초기 청사진
- v1.1 (2024-11-12): 비동기 쓰기 추가 (Stage 5 성능 이슈 발견)

Section 3.2: 파일 핸들러
  전략: 비동기 쓰기
  라이브러리: [ADR-401 참조]
  참조: Stage 5 구현 중 성능 이슈 발견
```

**참조**: 구체적 코드는 언어별 매뉴얼 참조
````

---

## 🎯 DNA 원칙 적용 요약 (Stage 5)

| 원칙                   | Stage 5 적용 방법                               | 체크포인트                              |
| ---------------------- | ----------------------------------------------- | --------------------------------------- |
| **1. AI 최적 크기**    | 시스템별 순차 구현 (1개/세션)                   | Database만 2 sessions                   |
| **2. 완전해질 때까지** | 7개 항목 완전성, Zero-Tolerance                 | Linter 0, Type Checker 0, Coverage 95%+ |
| **3. 기능별 분해**     | Database 시스템만 분해 (Protocol + Mock + 조립) | Protocol 정의 필수                      |
| **4. 역방향 수정**     | 6단계 프로토콜, 추적성 유지                     | Ref + Updated 명시                      |

---

## 🤔 왜 DNA 구현이 필요한가?

### 청사진 vs 구현

```markdown
Stage 4 청사진:
├─ "무엇을" 만들 것인지 설계
├─ 디렉토리 구조, 파일 목록
├─ 공개 API 정의
└─ 문서 (Markdown)

Stage 5 구현:
├─ "실제로" 코드 작성
├─ core/ 모듈 구현
├─ 테스트 작성
└─ 언어별 구현 (ADR-101 참조)

비유:
├─ 청사진 = 건축 도면
└─ 구현 = 실제 건설
```

### DNA 없이 도메인 구현하면?

```
❌ DNA 없이 도메인부터 구현:

domain/orders/service.*:
────────────────────────────────
표준 라이브러리 직접 사용
├─ 직접 출력 사용 (print/console.log)
├─ 표준 로거 직접 사용
├─ 에러 처리 없음
├─ 타입 정보 없음
└─ DB 직접 쿼리

결과 (문제점):
├─ 로깅 형식 불일치 (JSON vs Console)
├─ 직접 출력과 로거 혼재
├─ 에러 처리 누락
├─ 타입 안전성 없음
└─ 테스트 불가능한 코드
```

```
✅ DNA 먼저 구현 후 도메인:

domain/orders/service.*:
────────────────────────────────
DNA Systems 통합 사용
├─ from core.logging import get_logger
├─ from core.errors import ValidationError, NotFoundError
├─ from core.types import OrderId, UserId
└─ from core.database import get_session

OrderService 클래스:
├─ create_order(data: CreateOrderRequest) → OrderId
│   ├─ 타입 안전성 (모든 파라미터/리턴 타입 명시)
│   ├─ 구조화된 로깅 (컨텍스트 포함)
│   ├─ 데이터 검증 (ValidationError 활용)
│   ├─ 세션 관리 (get_session 사용)
│   ├─ 트랜잭션 처리 (commit/rollback)
│   └─ 타입 안전한 반환 (OrderId)

구현 흐름:
1. 입력 데이터 검증 → ValidationError
2. DB 세션 획득 → get_session()
3. 엔티티 생성 및 저장
4. 트랜잭션 커밋
5. 타입 안전한 ID 반환

결과 (장점):
├─ 일관된 로깅 (JSON, trace_id 포함)
├─ 표준화된 에러 처리
├─ 타입 안전성
├─ 테스트 가능한 코드
└─ DNA가 "환경"으로 보호
```

---

## 📥 입력 문서

### Stage 4에서 전달받는 것

| 파일                      | 핵심 내용         | 이 Stage에서 사용 |
| ------------------------- | ----------------- | ----------------- |
| `04B-01_dna_blueprint.md` | DNA 시스템 청사진 | 구현 명세         |
| `03A-401~499_*.md`        | DNA 시스템 ADR    | 기술 선택 근거    |

---

## 📤 출력 문서

### 필수 산출물

```markdown
core/                              # 구현된 DNA 모듈
├── [entry_point]                  # 진입점 (언어별 형식)
├── logging/                       # Observability System
├── config/                        # Configuration System
├── types/                         # Type System
├── errors/                        # Error Handling System
├── database/                      # Data System (DB)
├── cache/                         # Data System (Cache)
└── security/                      # Security System

tests/                             # DNA 테스트
├── unit/core/
│   ├── test_logging.*             # 단위 테스트
│   ├── test_config.*
│   └── ...
└── integration/core/
    └── test_database.*            # 통합 테스트

docs/
└── 05D-01_dna_implementation.md   # 구현 완료 문서

**참조**: 디렉토리 구조는 언어별로 다를 수 있음 (ADR-101 참조)
```

---

## 🔧 DNA 구현 3대 원칙

### 원칙 1: 표준 라이브러리 우선

```markdown
❌ 직접 구현 (실패 사례):
────────────────────────────────
과거 V5 프로젝트:
├─ 89개 커스텀 타입 클래스 직접 작성
├─ 1,679줄의 검증 로직 구현
├─ 버그 발생 시 직접 수정
└─ 유지보수 부담 증가

문제점:
├─ 휠을 재발명 (Reinventing the wheel)
├─ 검증되지 않은 코드
├─ 표준 라이브러리보다 성능 저하
└─ 유지보수 비용 증가

✅ 표준 라이브러리 활용:
────────────────────────────────
타입 시스템 라이브러리 활용 (ADR-301 참조):
├─ 검증된 타입 검증 기능
├─ 자동 변환/직렬화
├─ 명확한 에러 메시지
└─ 3-5줄로 구현 완료

장점:
├─ 커뮤니티 검증된 코드
├─ 성능 최적화 완료
├─ 문서화 및 예제 풍부
└─ 유지보수 부담 최소화
```

**참조**: 구체적 라이브러리는 언어별 매뉴얼 참조

**DNA별 표준 라이브러리 선택 원칙**:

| DNA 시스템           | 라이브러리 선택 기준 (ADR 참조)  | 직접 구현 금지 사항          |
| -------------------- | -------------------------------- | ---------------------------- |
| Observability System | 구조화 로깅 라이브러리 (ADR-401) | print/console 직접 사용      |
| Configuration System | 타입 안전 설정 관리 (ADR-402)    | 환경변수 직접 접근           |
| Type System          | 타입 검증 라이브러리 (ADR-301)   | 커스텀 타입 클래스 직접 작성 |
| Error Handling       | 타입 안전 에러 클래스 (ADR-303)  | 일반 Exception만 사용        |
| Data System (DB)     | ORM/쿼리 빌더 (ADR-501)          | 직접 SQL 문자열 작성         |
| Data System (Cache)  | 캐시 클라이언트 (ADR-502)        | 직접 소켓 통신               |
| Testing System       | 테스트 프레임워크 (ADR-801)      | 커스텀 테스트 러너           |

**원칙**: 언어별 커뮤니티 검증된 표준 라이브러리 사용 (ADR에서 결정)

### 원칙 2: 인터페이스 추상화

**핵심 개념**: 구현체가 아닌 인터페이스에 의존

```
파일 구조:
────────────────────────────────
core/cache/
├── interface.*              # 캐시 인터페이스 정의
│   └─ CacheInterface
│       ├─ get(key) → value
│       ├─ set(key, value, ttl)
│       └─ delete(key)
│
├── redis.*                  # Redis 구현체
│   └─ RedisCache implements CacheInterface
│
└── memcached.*              # 대체 구현체 (교체 가능)
    └─ MemcachedCache implements CacheInterface

인터페이스 정의 (개념):
────────────────────────────────
CacheInterface:
  목적: 캐시 작업 표준 인터페이스
  메서드:
    - get(key: string) → value | null
    - set(key: string, value: any, ttl: number) → void
    - delete(key: string) → void

구현체 1 (Redis):
  RedisCache implements CacheInterface
  ├─ Redis 클라이언트 활용
  └─ 모든 인터페이스 메서드 구현

구현체 2 (Memcached):
  MemcachedCache implements CacheInterface
  ├─ Memcached 클라이언트 활용
  └─ 동일한 인터페이스 구현

교체 시나리오:
  Redis → Memcached 전환
  ├─ 도메인 코드 변경 없음 (인터페이스 동일)
  ├─ 설정만 변경 (ADR-502 업데이트)
  └─ 테스트 통과 확인
```

**가치**:

- **테스트 용이성**: Mock/Stub 주입 간편
- **기술 독립성**: 구현체 교체 시 도메인 코드 무수정
- **설계 원칙**: 의존성 역전 원칙 (DIP) 준수
- **유연성**: 런타임 구현체 선택 가능

**참조**: 구체적 인터페이스 정의는 언어별 매뉴얼 참조

### 원칙 3: 설정 주입 (환경별 분리)

**핵심 개념**: 환경변수 기반 설정 관리, 타입 안전성 보장

```
파일 구조:
────────────────────────────────
core/config/
├── settings.*               # 설정 클래스 정의
└── [환경별 설정 파일]       # .env.* 또는 언어별 형식

설정 클래스 정의 (개념):
────────────────────────────────
Settings 클래스:
  목적: 환경별 설정 중앙 관리

  필드 정의:
    - database_url: string (기본값: 개발 DB URL)
    - cache_url: string (기본값: 로컬 캐시)
    - log_level: string (기본값: "INFO")
    - log_format: string (기본값: "json")
    - environment: string (기본값: "development")

  로딩 전략:
    ├─ 환경변수 파일 읽기 (.env.*)
    ├─ 타입 검증 (문자열 → 타입 변환)
    ├─ 필수 값 검증 (누락 시 에러)
    └─ 기본값 적용 (선택 필드)

사용 패턴:
────────────────────────────────
1. 설정 인스턴스 생성
   settings = Settings()

2. 타입 안전한 접근
   db_url = settings.database_url  # 타입: string
   log_level = settings.log_level  # 타입: string

3. DNA 시스템에서 활용
   logger.configure(level=settings.log_level)
   db.connect(url=settings.database_url)
```

**환경별 설정 파일 예시**:

```bash
# 개발 환경 (.env.development)
DATABASE_URL=postgresql://localhost/dev
CACHE_URL=redis://localhost:6379
LOG_LEVEL=DEBUG
LOG_FORMAT=console
ENVIRONMENT=development

# 프로덕션 환경 (.env.production)
DATABASE_URL=postgresql://prod-db:5432/prod
CACHE_URL=redis://prod-cache:6379
LOG_LEVEL=INFO
LOG_FORMAT=json
ENVIRONMENT=production
```

**장점**:

- **타입 안전성**: 설정 값 타입 검증
- **중앙 관리**: 모든 설정 한 곳에서 관리
- **환경 분리**: 개발/스테이징/프로덕션 독립
- **검증 자동화**: 필수 값 누락 시 즉시 에러

**참조**: 구체적 설정 라이브러리는 언어별 매뉴얼 참조 (ADR-402)

---

## 📋 구현 단계 (Part 1-4)

### Part 1: 프로젝트 구조 생성 (30분)

#### Step 1: 디렉토리 구조 생성

**목적**: Stage 4 청사진 기반 DNA 모듈 디렉토리 구조 생성

```
생성할 디렉토리 구조:
────────────────────────────────
[project_root]/
├── core/                        # DNA 시스템 모듈
│   ├── logging/                 # Observability System
│   ├── config/                  # Configuration System
│   ├── types/                   # Type System
│   ├── errors/                  # Error Handling System
│   ├── database/                # Data System (DB)
│   ├── cache/                   # Data System (Cache)
│   └── security/                # Security System
│
└── tests/                       # 테스트
    ├── unit/core/               # 단위 테스트
    └── integration/core/        # 통합 테스트

필수 작업:
□ 각 DNA 시스템별 디렉토리 생성
□ 테스트 디렉토리 분리 (unit/integration)
□ 언어별 진입점 파일 생성 (필요시)
```

**참조**: 언어별 구체적 명령어는 매뉴얼 참조

#### Step 2: 의존성 설치

**목적**: DNA 시스템 구현에 필요한 라이브러리 설치

```
필수 의존성 (ADR 참조):
────────────────────────────────
□ Type System 라이브러리 (ADR-301)
  └─ 타입 검증, 직렬화/역직렬화

□ Configuration 라이브러리 (ADR-402)
  └─ 환경변수 관리, 타입 안전 설정

□ Observability 라이브러리 (ADR-401)
  └─ 구조화 로깅, 메트릭, 추적

□ Data 라이브러리 (ADR-501, ADR-502)
  └─ ORM/쿼리빌더, 캐시 클라이언트

□ Testing 라이브러리 (ADR-801)
  └─ 테스트 프레임워크, 커버리지 도구

개발 도구:
□ 코드 품질 (ADR-302)
  ├─ Linter (코드 스타일)
  ├─ Formatter (자동 정렬)
  └─ Type Checker (타입 검증)

□ 자동화 도구
  └─ Pre-commit hooks (품질 게이트)
```

**참조**: 언어별 패키지명은 매뉴얼 참조

#### Step 3: 기본 설정 파일

**목적**: 코드 품질 자동 검증 설정

```
설정할 항목:
────────────────────────────────
□ Linter 설정 (ADR-302)
  ├─ 코드 스타일 규칙
  ├─ 금지 패턴 (print/console 사용 등)
  └─ 최대 줄 길이

□ Type Checker 설정 (ADR-301)
  ├─ Strict 모드 활성화
  ├─ 타입 추론 경고
  └─ Any 타입 경고

□ Test 설정 (ADR-801)
  ├─ 최소 커버리지 요구 (95%)
  ├─ 비동기 테스트 지원
  └─ 테스트 경로 설정
```

**참조**: 언어별 설정 파일 형식은 매뉴얼 참조

### Part 2: 핵심 DNA 구현 순서 (의존성 기반)

```
구현 순서 (의존성 그래프):

Phase 1: 기반 (의존성 없음)
────────────────────────────────
1. Types      [30분]  ← 다른 모든 DNA가 의존
2. Config     [30분]  ← Types만 의존
3. Logging    [45분]  ← Config, Types 의존
4. Errors     [45분]  ← Types, Logging 의존

Phase 2: 데이터/통신
────────────────────────────────
5. Database   [1시간] ← Config, Types, Errors, Logging
6. Cache      [45분]  ← Config, Types, Errors, Logging

Phase 3: 품질/보안
────────────────────────────────
7. Testing    [30분]  ← 모든 Phase 1-2 완료 후
8. Security   [1시간] ← Database, Config, Types
```

### Part 3: 각 DNA 시스템 구현 (개념)

**참조**: 구체적 코드 예시는 언어별 매뉴얼 참조

- Python 매뉴얼: `docs/manuals/05M-01_python_implementation.md`
- TypeScript 매뉴얼: `docs/manuals/05M-02_typescript_implementation.md`
- Rust 매뉴얼: `docs/manuals/05M-03_rust_implementation.md`

---

각 DNA 시스템별 핵심 구현 체크리스트:

---

#### 3.1 Type System

**목적**: 타입 안전성 보장, 런타임 에러 방지

**핵심 체크리스트**:

```
□ 도메인 타입 정의
  ├─ Entity Base (ID, timestamps, 동등성)
  ├─ Value Object Base (불변성, 자체 검증)
  └─ Domain-specific 타입 (UserId, Money, Email 등)

□ 타입 검증
  ├─ 생성 시점 검증 (불완전한 객체 생성 금지)
  ├─ 불변성 보장
  └─ 타입 체커 0 오류 (ADR-301)

□ 공개 API
  ├─ BaseEntity, BaseValueObject export
  ├─ 도메인 타입들 export
  └─ 타입 검증 함수 (선택)
```

**파일 구조** (언어 무관):

```
core/types/
├── [entry_point]    # 공개 API export
├── base.*           # Entity/ValueObject 기반 클래스
├── ids.*            # ID 타입들 (UserId, OrderId)
└── common.*         # 공통 타입 (Email, Money)
```

**구현 요소**:

```
1. 공개 API (Entry Point)
   └─ BaseEntity, BaseValueObject, 도메인 타입들 export

2. 기반 클래스 (base.*)
   ├─ BaseEntity: ID, timestamps, 동등성 비교
   └─ BaseValueObject: 불변성, 자체 검증

3. ID 타입들 (ids.*)
   ├─ UserId, OrderId, ProductId 등
   ├─ 타입 안전성 (타입 구분)
   └─ ID 생성 함수

4. 공통 값 객체 (common.*)
   ├─ Email: 이메일 검증
   ├─ Money: 정밀 계산, 통화 관리
   └─ PhoneNumber: 전화번호 형식 검증
```

**구현 체크리스트**:

```
□ Base 클래스 구현
  ├─ Entity: 식별자 기반 동등성
  ├─ ValueObject: 값 기반 동등성
  └─ 불변성 보장 (방어적 복사)

□ ID 타입 구현
  ├─ 타입 안전 ID (UserId ≠ OrderId)
  ├─ ID 생성 함수 (UUID/ULID 등)
  └─ 타입 체커 검증 통과

□ 값 객체 구현
  ├─ Email: 형식 검증
  ├─ Money: 정밀 계산 (부동소수점 금지)
  └─ 도메인 규칙 검증

□ 테스트 작성
  ├─ ID 고유성 검증
  ├─ 값 객체 검증 로직 테스트
  ├─ Money 연산 테스트 (덧셈, 통화 체크)
  └─ 불완전한 객체 생성 방지 확인
```

**참조**: 구체적 코드는 언어별 매뉴얼 참조



#### 3.2 Configuration System

**목적**: 환경별 설정 관리, 타입 안전성 보장

**파일 구조** (언어 무관):

```
core/config/
├── [entry_point]    # 공개 API export
├── settings.*       # 환경 설정 클래스
└── validators.*     # 커스텀 검증 (선택)
```

**구현 요소**:

```
1. Settings 클래스
   ├─ 환경 변수 자동 로딩 (.env.*)
   ├─ 타입 안전 필드 정의
   ├─ 기본값 제공
   └─ 필수 값 검증

2. 설정 카테고리
   ├─ 환경: environment, debug
   ├─ Database: URL, pool_size
   ├─ Cache: URL, TTL
   ├─ Logging: level, format
   └─ External API: keys, rate_limit

3. 접근 패턴
   ├─ 싱글톤 인스턴스
   ├─ get_settings() 함수
   └─ 타입 안전한 접근
```

**구현 체크리스트**:

```
□ Settings 클래스 정의
  ├─ 필드별 타입 지정
  ├─ 기본값 설정
  ├─ 범위 검증 (min/max)
  └─ 환경변수 파일 경로

□ 검증 로직
  ├─ log_level 값 제한 (DEBUG, INFO, etc.)
  ├─ log_format 값 제한 (json, console)
  ├─ URL 형식 검증
  └─ 범위 검증 (pool_size: 1-20)

□ 싱글톤 패턴
  ├─ get_settings() 구현
  ├─ 전역 인스턴스 관리
  └─ 스레드 안전성 (필요시)

□ 환경별 설정 파일
  ├─ .env.development
  ├─ .env.staging
  ├─ .env.production
  └─ 자동 로딩 구현
```

**참조**: 구체적 코드는 언어별 매뉴얼 참조

#### 3.3 Observability System (Logging)

**목적**: 구조화 로깅, 컨텍스트 전파, 환경별 포맷

**파일 구조** (언어 무관):

```
core/logging/
├── [entry_point]    # 공개 API export
├── logger.*         # 로거 설정 및 생성
├── config.*         # 로깅 설정
└── processors.*     # 커스텀 프로세서 (선택)
```

**구현 요소**:

```
1. 로깅 설정 (configure_logging)
   ├─ 환경별 포맷 (JSON/Console)
   ├─ 로그 레벨 필터링
   ├─ 공통 프로세서 체인
   │   ├─ 컨텍스트 병합
   │   ├─ 타임스탬프 추가
   │   ├─ 로그 레벨 추가
   │   └─ 스택 정보 (에러 시)
   └─ 출력 포맷
       ├─ JSON (운영)
       └─ Console (개발)

2. 로거 인스턴스 (get_logger)
   ├─ 모듈별 로거 생성
   ├─ 캐싱 (성능)
   └─ 타입 안전 반환

3. 컨텍스트 관리
   ├─ bind_context(): trace_id, user_id 등
   ├─ clear_context(): 초기화
   └─ 요청 범위 전파
```

**구현 체크리스트**:

```
□ configure_logging() 함수
  ├─ Settings에서 log_level, log_format 로드
  ├─ 프로세서 체인 구성
  ├─ JSON vs Console 렌더러 선택
  └─ 앱 시작 시 1회 호출

□ get_logger() 함수
  ├─ 모듈명 기반 로거 반환
  ├─ 구조화 로깅 지원
  └─ 컨텍스트 자동 포함

□ 컨텍스트 헬퍼
  ├─ bind_context(trace_id, user_id, ...)
  ├─ 스레드/비동기 안전 저장
  └─ 모든 로그에 자동 포함

□ 출력 포맷
  ├─ JSON: {"event": "...", "trace_id": "...", "timestamp": "..."}
  ├─ Console: 컬러 출력 (개발 편의)
  └─ 타임스탬프 ISO 8601 형식
```

**사용 패턴**:

```
1. 앱 시작 시 초기화
   configure_logging()

2. 모듈별 로거 생성
   logger = get_logger(module_name)

3. 요청 컨텍스트 바인딩
   bind_context(trace_id="abc-123", user_id="user-456")

4. 구조화 로깅
   logger.info("주문 생성", order_id="order-789", amount=50000)

5. 출력 (JSON 예시)
   {"event": "주문 생성", "trace_id": "abc-123", "user_id": "user-456",
    "order_id": "order-789", "amount": 50000, "level": "info",
    "timestamp": "2025-12-03T10:30:00Z"}
```

**참조**: 구체적 코드는 언어별 매뉴얼 참조

#### 3.4 Error Handling System

**목적**: 표준화된 예외 처리, 에러 코드 체계, 전역 핸들링

**파일 구조** (언어 무관):

```
core/errors/
├── [entry_point]    # 공개 API export
├── exceptions.*     # 예외 계층 정의
├── codes.*          # 에러 코드 체계
└── handlers.*       # 전역 핸들러
```

**구현 요소**:

```
1. 에러 코드 체계 (ErrorCode)
   ├─ 1xxx: 도메인 에러 (비즈니스 로직)
   │   ├─ 1001: ValidationError
   │   ├─ 1002: NotFoundError
   │   ├─ 1003: ConflictError
   │   └─ 1004+: 도메인 특화
   ├─ 2xxx: 외부 API 에러
   │   ├─ 2001: External API Error
   │   ├─ 2002: Rate Limit
   │   └─ 2003: Auth Failed
   └─ 9xxx: 시스템 에러
       ├─ 9001: Internal Error
       ├─ 9002: Database Error
       └─ 9003: Cache Error

2. 예외 계층
   ├─ AppError (최상위)
   │   ├─ message, code, details
   │   └─ to_dict() (API 응답)
   ├─ DomainError extends AppError
   │   ├─ ValidationError
   │   ├─ NotFoundError
   │   └─ ConflictError
   └─ ExternalError extends AppError
       └─ 외부 API별 에러

3. 전역 핸들러
   ├─ 예상된 에러 (AppError)
   │   ├─ 로깅 (warning level)
   │   ├─ HTTP 상태 코드 매핑
   │   └─ 구조화된 응답
   └─ 예상치 못한 에러
       ├─ 로깅 (error level + stack)
       ├─ 500 Internal Error
       └─ 상세 숨김 (보안)
```

**구현 체크리스트**:

```
□ 에러 코드 정의
  ├─ 1xxx, 2xxx, 9xxx 범위 할당
  ├─ 프로젝트별 도메인 코드 추가
  └─ Enum/Constant로 관리

□ AppError 기반 클래스
  ├─ 생성자: message, code, details
  ├─ to_dict(): API 응답 포맷
  └─ 로깅 친화적 구조

□ 도메인 예외 클래스
  ├─ ValidationError(message, field)
  ├─ NotFoundError(resource, identifier)
  ├─ ConflictError(message)
  └─ 도메인 특화 에러

□ 전역 핸들러 등록
  ├─ AppError → 적절한 HTTP 상태
  ├─ 로깅 (경고 vs 에러)
  ├─ 구조화 응답: {error: {code, message, details}}
  └─ 예상치 못한 에러 처리

□ HTTP 상태 매핑
  ├─ 1001 → 400 Bad Request
  ├─ 1002 → 404 Not Found
  ├─ 1003 → 409 Conflict
  ├─ 2xxx → 502 Bad Gateway
  └─ 9xxx → 500 Internal Error
```

**사용 패턴**:

```
1. 도메인 에러 발생
   if not order.items:
       raise ValidationError("주문 항목이 비어있습니다", field="items")

2. 리소스 없음
   order = find_order(order_id)
   if not order:
       raise NotFoundError("주문", order_id)

3. 전역 핸들러 등록
   app.add_exception_handler(Exception, global_exception_handler)

4. API 응답 (자동)
   {
     "error": {
       "code": "1001",
       "message": "주문 항목이 비어있습니다",
       "details": {"field": "items"}
     }
   }
```

**참조**: 구체적 코드는 언어별 매뉴얼 참조



### Part 4: 통합 검증

#### 4.1 DNA 통합 테스트

**목적**: DNA 시스템 간 연동 검증

**테스트 시나리오**:

```
1. Logging ↔ Config 연동
   ├─ 설정(Settings)에서 log_level, log_format 로드
   ├─ 로거 초기화 시 설정 반영 확인
   └─ 다양한 로그 레벨 동작 검증

2. Errors ↔ Logging 연동
   ├─ 에러 발생 시 자동 로깅
   ├─ 에러 코드, 메시지, details 포함
   └─ 로그 레벨 적절성 (warning vs error)

3. Types ↔ Errors 연동
   ├─ 타입 검증 실패 시 적절한 에러
   ├─ Money 음수 검증 → ValidationError
   └─ Email 형식 검증 → ValidationError

4. Config ↔ All Systems
   ├─ Database URL 주입
   ├─ Cache URL 주입
   ├─ External API 키 주입
   └─ 환경별 설정 격리
```

**테스트 체크리스트**:

```
□ Setup
  ├─ 테스트 환경 초기화
  ├─ DNA 시스템 설정 로드
  └─ 로깅 초기화

□ 통합 테스트
  ├─ Logging이 Config 사용 확인
  ├─ Errors가 Logging 연동 확인
  ├─ Types 검증 실패 → 에러 확인
  └─ 전체 플로우 E2E 테스트

□ 품질 기준
  ├─ 모든 테스트 통과
  ├─ 통합 커버리지 85%+
  └─ 실제 DB/Cache 사용 (Mock 최소화)
```

**참조**: 구체적 테스트 코드는 언어별 매뉴얼 참조

#### 4.2 품질 검증

**목적**: DNA 시스템 품질 게이트 통과

**검증 항목** (ADR 참조):

```
1. Type Checker (ADR-301)
   ├─ Strict 모드 실행
   ├─ 0 errors 필수
   └─ 예상 결과: "Success: no issues found"

2. Linter (ADR-302)
   ├─ 코드 스타일 검증
   ├─ 0 violations 필수
   └─ 예상 결과: "All checks passed!"

3. Formatter (ADR-302)
   ├─ 자동 코드 정렬
   └─ 일관된 스타일 적용

4. Test + Coverage (ADR-801)
   ├─ 단위 + 통합 테스트 실행
   ├─ 최소 커버리지: 95%
   └─ 예상 결과: "PASSED, Coverage 95%+"

5. 전체 검증
   ├─ CI 파이프라인 통과
   ├─ Pre-commit hooks 통과
   └─ 품질 게이트 100% 통과
```

**실행 순서**:

```
Step 1: Type Checker → 0 errors
Step 2: Linter → 0 violations
Step 3: Formatter → 자동 적용
Step 4: Tests → 95%+ coverage
Step 5: Integration → 전체 검증
```

**참조**: 언어별 명령어는 매뉴얼 참조

#### 4.3 DNA 완성도 평가 (Kent Beck 기준)

```
DNA 성숙도 레벨:

Level 0 (미완성): 0-3개 DNA 동작
Level 1 (최소):   4-6개 DNA 동작
Level 2 (양호):   7-9개 DNA 동작
Level 3 (완성):   10-11개 DNA 동작 ← 목표!

Kent Beck 수준 = Level 3 (10/11개 이상)
```

---

## 📄 구현 완료 문서 템플릿

### 05D-01_dna_implementation.md

```markdown
# DNA 시스템 구현 완료 문서

## 1. 구현 현황

### 1.1 완료된 DNA 시스템

| DNA 시스템 | 상태 | 파일 수 | 테스트 커버리지 | 담당자 |
|-----------|------|--------|---------------|-------|
| Types | ✅ 완료 | 4 | 98% | - |
| Config | ✅ 완료 | 3 | 95% | - |
| Logging | ✅ 완료 | 4 | 96% | - |
| Errors | ✅ 완료 | 4 | 97% | - |
| Database | ✅ 완료 | 5 | 94% | - |
| Cache | ✅ 완료 | 3 | 95% | - |
| Security | ⏳ 진행 중 | 2 | 80% | - |
| ... | ... | ... | ... | ... |

### 1.2 품질 메트릭

```

Type Checker: 0 errors ✅
Linter:       0 violations ✅
Tests:        45 passed, 0 failed ✅
Coverage:     96% (목표: 95%) ✅

```
## 2. 디렉토리 구조

```

core/
├── [entry_point]       # DNA 공개 API
├── logging/
│   ├── [entry_point]
│   ├── logger.*        # 285 lines
│   ├── config.*        # 45 lines
│   └── processors.*    # 62 lines
├── config/
│   ├── [entry_point]
│   ├── settings.*      # 120 lines
│   └── validators.*    # 35 lines
├── types/
│   ├── [entry_point]
│   ├── base.*          # 50 lines
│   ├── ids.*           # 40 lines
│   └── common.*        # 85 lines
├── errors/
│   ├── [entry_point]
│   ├── exceptions.*    # 95 lines
│   ├── codes.*         # 45 lines
│   └── handlers.*      # 60 lines
└── database/
    ├── [entry_point]
    ├── session.*       # 75 lines
    ├── base.*          # 55 lines
    └── mixins.*        # 40 lines

```
## 3. 공개 API

### 3.1 사용 예시 (개념)

```

# DNA 임포트

import 필요한 시스템 from core

필수 임포트:

  - Logging: get_logger, configure_logging
  - Config: get_settings
  - Types: UserId, OrderId, Money
  - Errors: NotFoundError, ValidationError
  - Database: get_session

# 초기화

configure_logging()
settings = get_settings()
logger = get_logger(module_name)

# 사용

logger.info("서비스 시작", environment=settings.environment)

database_session 사용:

  - 세션 획득
  - 트랜잭션 수행
  - 자동 커밋/롤백

```
**참조**: 구체적 코드는 언어별 매뉴얼 참조

## 4. Stage 6 전달 사항

### 4.1 Project Standards에 포함할 규칙

- [ ] 직접 출력 금지 (print/console) → get_logger() 사용
- [ ] 환경변수 직접 접근 금지 → get_settings() 사용
- [ ] 일반 Exception 금지 → AppError 계층 사용
- [ ] 직접 쿼리 문자열 금지 → ORM/쿼리빌더 사용 (ADR-501)

### 4.2 자동화 설정

- [ ] Pre-commit hooks 설정 (품질 게이트)
- [ ] CI 파이프라인에 DNA 테스트 포함
- [ ] Import 규칙 강제 (layer 경계)

```

---

## ✏️ DNA 연동 패턴 (개념)

**목적**: DNA 시스템 간 연동 방식 이해

### 패턴 1: Logging ↔ Config

**연동 개념**:

```
configure_logging() 함수:
  1. get_settings()로 설정 로드
  2. 환경별 로거 설정
     - 개발: 컬러 콘솔, DEBUG
     - 운영: JSON, WARNING
  3. 도메인 특화 컨텍스트 추가
     - trace_id, user_id, account_id 등
```

**핵심 포인트**:

- Config에서 log_level, log_format 동적 로드
- 환경 변경 시 코드 수정 불필요
- 도메인 컨텍스트 자동 포함

### 패턴 2: Errors ↔ Logging

**연동 개념**:

```
global_exception_handler():
  1. 에러 타입별 로그 레벨 결정
     - AppError → warning
     - 중요 경로 에러 → critical
     - 예상치 못한 에러 → error + stack
  2. 요청 컨텍스트 포함
     - trace_id, user_id, path
  3. 구조화 로깅
     - error_code, message, details
```

**핵심 포인트**:

- 에러 발생 = 자동 로깅
- 에러 코드로 로그 레벨 결정
- 컨텍스트 전파 (trace_id)

### 패턴 3: 전체 DNA 연동

**도메인 서비스에서 DNA 활용**:

```
OrderService.create_order():
  1. Types DNA
     - 타입 안전 파라미터 (UserId, Money)
     - ID 생성 (generate_order_id)

  2. Logging DNA
     - 컨텍스트 바인딩 (bind_context)
     - 단계별 로깅 (info/error)

  3. Errors DNA
     - 검증 실패 → ValidationError
     - 외부 API 실패 → ExternalError

  4. Database DNA
     - 세션 관리 (get_session)
     - 트랜잭션 (commit/rollback)

  5. Cache DNA
     - 시세 캐싱 (@cached decorator)

  6. Config DNA
     - 외부 API 설정 (rate_limit 등)
```

**핵심 포인트**:

- 도메인 로직에만 집중
- DNA가 횡단 관심사 처리
- 일관성 자동 보장

**참조**: 구체적 코드는 언어별 매뉴얼 참조

---

## ✅ Stage 5 완료 체크리스트

### 구조 검증

- [ ] core/ 디렉토리 생성됨
- [ ] 각 DNA 시스템 하위 디렉토리 존재
- [ ] tests/unit/core/ 테스트 디렉토리 존재
- [ ] tests/integration/core/ 통합 테스트 존재

### 필수 DNA 구현 (5개)

- [ ] **Type System**: ID 타입, 공통 값 객체 구현
- [ ] **Configuration System**: Settings 클래스, 환경별 분리
- [ ] **Observability System**: 로깅 라이브러리 (ADR-401), get_logger() 동작
- [ ] **Error Handling System**: 예외 계층, 에러 코드 정의
- [ ] **Testing System**: 테스트 프레임워크 (ADR-801), 커버리지 95%+

### 패밀리별 추가 DNA

- [ ] **Data System (DB)** (A-A-B 필수): ORM/쿼리빌더 (ADR-501) 세션 관리
- [ ] **Data System (Cache)** (A-A-B 권장): 캐시 클라이언트 (ADR-502)
- [ ] **Security System** (A-A-B 필수): 인증/인가 미들웨어

### 품질 검증

- [ ] Type Checker 0 errors (ADR-301)
- [ ] Linter 0 violations (ADR-302)
- [ ] 테스트 통과 (단위 + 통합)
- [ ] 커버리지 95%+ (ADR-801)

### 통합 검증

- [ ] DNA 간 의존성 정상 (Types → Config → Logging → Errors)
- [ ] 전체 통합 테스트 통과
- [ ] Kent Beck 수준 달성 (10/11개 이상)

### 산출물 생성

- [ ] `05D-01_dna_implementation.md` 작성
- [ ] Stage 6 전달 사항 정리

---

## 🔗 Stage 5 → Stage 6 연결

### Stage 6에 전달하는 것

| 전달 항목       | 내용                        | 용도                      |
| --------------- | --------------------------- | ------------------------- |
| 구현된 DNA 모듈 | core/                       | 프로젝트 표준의 기반      |
| 금지 규칙       | 직접 출력, 환경변수 접근 등 | PROJECT_STANDARDS.md 작성 |
| 자동화 설정     | 설정 파일, pre-commit hooks | 강제 규칙 설정            |

### Stage 6 미리보기

```
Stage 6: Project Standards
├─ PROJECT_STANDARDS.md 작성
│   - 코드 스타일 규칙
│   - DNA 사용 규칙 (금지/필수)
│   - 아키텍처 규칙
├─ 자동화 설정
│   - pre-commit hooks
│   - import-linter
│   - CI 파이프라인
└─ 강제 규칙 검증
```

---

## ⏪ 이전 Stage 검증 및 수정 프로토콜

### 검증 시점

- Stage 5 시작 전 필수 체크
- 각 DNA 시스템 구현 완료 후 청사진과 교차 검증

### 검증 대상

| Stage   | 산출물      | 검증 항목              |
| ------- | ----------- | ---------------------- |
| Stage 1 | 01C-01_*.md | 구현 수준이 NFR 만족?  |
| Stage 2 | 02C-01_*.md | 기술 제약 내에서 구현? |
| Stage 3 | 03A-*_*.md  | ADR 결정대로 구현?     |
| Stage 4 | 04B-01_*.md | DNA 청사진대로 구현?   |

### 오류 발견 시 프로토콜

```
Stage 5에서 Stage 1-4 오류 발견 시:

Step 1: 오류 발견 및 문서화
├─ 발견 위치: DNA 시스템 [N] 구현 중
├─ 오류 내용: [구체적 설명]
├─ 영향 Stage: Stage [1, 2, 3, 또는 4]
└─ 기록: 05D-01에 "발견된 이슈" 추가

Step 2: 영향 범위 파악
├─ 청사진(Stage 4) 수정 필요?
├─ ADR(Stage 3) 수정 필요?
├─ 제약(Stage 2) 재검토 필요?
└─ 재작업 예상: [X]시간

Step 3: 해당 Stage로 이동 → 수정
├─ 해당 산출물 수정
├─ 버전 업데이트
└─ 수정 검증

Step 4: 중간 Stage 전파
├─ Stage 4, 5 영향 확인
└─ 필요 시 청사진 업데이트

Step 5: Stage 5 재진행
├─ 수정된 청사진으로 구현 재검토
└─ 코드 일관성 확인

Step 6: 검증 → Stage 6 전달 ✅
```

### 흔한 오류 패턴

| 오류 유형     | 예시                        | 해결                    |
| ------------- | --------------------------- | ----------------------- |
| 청사진 불완전 | 인터페이스 정의 누락        | Stage 4 청사진 보완     |
| ADR 미반영    | 로깅 포맷 ADR과 구현 불일치 | 구현 수정 또는 ADR 갱신 |
| 의존성 오류   | 순환 의존성 발생            | Stage 4 설계 재검토     |

### 추적성

```
수정 이력: docs/revision_log.md
코드 주석: # Stage 5 구현 - ADR-XXX 참조
```

---

## 💡 핵심 원칙 요약

### DNA 구현의 3대 원칙

```
1. 표준 라이브러리 우선
────────────────────────────────
❌ 직접 구현 (89개 클래스, 1,679줄)
✅ 검증된 라이브러리 사용 (ADR 참조, 3줄)

2. 인터페이스 추상화
────────────────────────────────
Protocol 정의 → 구현체 교체 가능
테스트 시 Mock 주입 용이

3. 설정 주입
────────────────────────────────
설정 라이브러리로 환경별 분리 (ADR-402)
.env.development / .env.production
```

### 구현 순서 (의존성 기반)

```
Phase 1: 기반 (의존성 없음)
Types → Config → Logging → Errors

Phase 2: 데이터/통신
Database → Cache → Messaging

Phase 3: 품질/보안
Testing → Security → Monitoring
```

### 품질 기준 (Zero Tolerance)

```
Type Checker: 0 errors    (타입 안전성, ADR-301)
Linter:       0 violations (코드 품질, ADR-302)
Tests:        0 failures   (기능 정확성, ADR-801)
Coverage:     95%+         (테스트 충분성)
```

---

**Remember**: 

- DNA 없이 도메인 구현 = 기반 없는 건물
- 표준 라이브러리 우선 = 바퀴 재발명 금지
- 의존성 순서 준수 = Types → Config → Logging → Errors
- Kent Beck 수준 = 10/11개 DNA 동작

*DNA가 "환경"으로 구축되어야 도메인 코드가 그 위에서 안전하게 실행됩니다.*


================================================================================

📄 FILE: 06G-00_project_standards_guide.md
--------------------------------------------------------------------------------

# Stage 6: 프로젝트 표준 가이드 (Project Standards Guide)

> **목적**: DNA 시스템 사용 강제 규칙 + 자동화 설정으로 일관성 보장
>
> **버전**: v4.1 (2025-12-03)
>
> - v4.0 (2025-12-03): Gemini 연구 기반 전면 재작성, 01_DNA_METHODOLOGY_DETAILED.md 기준
> - v2.0 (2025-11-12): 입력/출력 문서 추가
> - v1.0 (2025-11-10): 초기 버전

---

## 📚 이 가이드의 위치

```
DNA 방법론 문서 체계:

Tier 1: 00_CORE_METHODOLOGY.md (전체 맥락)
           ↓
Tier 2: 01_DNA_METHODOLOGY_DETAILED.md (상세 원리)
           ↓
Tier 3: 이 문서 (Stage 6 실행 가이드) ← 지금 여기!
```

**참조 문서**:
- **원리 이해**: `01_DNA_METHODOLOGY_DETAILED.md` **Part 5.4**

---

## 📖 이 가이드의 구성

이 가이드는 **언어 무관 개념 + Python 생태계 예시**로 구성됩니다:

```
개념 (언어 무관):
├─ DNA 사용 규칙 (DO/DON'T)
├─ 품질 기준 (Zero Tolerance)
├─ 자동화 전략 (3단계 성숙도)
└─ 강제 메커니즘 (pre-commit, CI/CD)

Python 생태계 예시:
├─ 도구: Ruff, MyPy, pytest, pre-commit
├─ 설정: pyproject.toml, .pre-commit-config.yaml
└─ CI/CD: GitHub Actions

다른 언어:
└─ 해당 언어 매뉴얼 참조
    ├─ TypeScript: ESLint, TypeScript, Jest, Husky
    ├─ Rust: Clippy, rustc, Cargo test
    └─ Go: golangci-lint, go test
```

**참조**: 구체적 도구/설정은 언어별 매뉴얼 참조

---

## 🤔 왜 Project Standards가 필요한가?

### Bridge의 마지막 조각

```
Bridge(Stage 4-6)의 4대 구성요소:

┌─────────────────────────────────────────────────────┐
│  Stage 3: ADR (결정)                                │
│  "PostgreSQL을 쓰기로 했다"                          │
└─────────────────────────────────────────────────────┘
           ↓
┌─────────────────────────────────────────────────────┐
│  Stage 4: DNA 청사진 (설계)                          │
│  "src/core/database/ 구조와 API 설계"                │
└─────────────────────────────────────────────────────┘
           ↓
┌─────────────────────────────────────────────────────┐
│  Stage 5: DNA 구현 (코드)                            │
│  "get_session(), Base 클래스 구현"                   │
└─────────────────────────────────────────────────────┘
           ↓
┌─────────────────────────────────────────────────────┐
│  Stage 6: Project Standards (강제) ← 지금 여기!     │
│  "직접 SQL 금지, get_session() 필수 사용"            │
│  "위반 시 pre-commit에서 자동 차단"                  │
└─────────────────────────────────────────────────────┘
```

### 규칙만 있고 강제가 없으면?

```
❌ 강제 없는 규칙:

PROJECT_STANDARDS.md:
"print() 대신 logger를 사용하세요"

현실:
domain/orders/service.py:
    print(f"Creating order: {data}")  # 급하니까 일단...
    print("DEBUG: ", response)        # 디버깅용...

결과:
├─ 규칙 문서는 존재하지만 아무도 안 읽음
├─ 코드 리뷰에서 발견? "이번만 넘어가죠"
├─ 운영에서 print 로그가 stdout에 뒤섞임
└─ 3개월 후 "누가 print 쓴 거야?!" 😱
```

```
✅ 강제 있는 규칙:

PROJECT_STANDARDS.md:
"print() 대신 logger를 사용하세요"

자동화 (Python 예시):
pyproject.toml:
    select = ["T201"]  # T201 = print 금지

.pre-commit-config.yaml:
    - id: ruff
      args: [--fix]

결과:
$ git commit -m "Add order feature"
Ruff.....Failed
- T201: print found (domain/orders/service.py:15)

├─ 커밋 자체가 차단됨
├─ 개발자가 즉시 수정
├─ 코드 리뷰 불필요 (자동 강제)
└─ 운영 환경 100% 안전

**참조**: 다른 언어의 린터 설정은 해당 언어 매뉴얼 참조
```

### 비유: 교통 법규 vs 과속 카메라

```
교통 법규 (규칙):
"제한 속도 60km/h를 지키세요"

과속 카메라 (강제):
위반 시 자동 촬영 → 벌금 → 면허 정지

Project Standards:
├─ 규칙 = PROJECT_STANDARDS.md (교통 법규)
├─ 강제 = pre-commit hooks (과속 카메라)
├─ 처벌 = 커밋 차단 (벌금)
└─ 결과 = 100% 준수 (안전한 도로)
```

---

## 📥 입력 문서

### Stage 5에서 전달받는 것

| 파일 | 핵심 내용 | 이 Stage에서 사용 |
|------|----------|-----------------|
| `src/core/` | 구현된 DNA 모듈 | 사용 규칙 작성 |
| `05D-01_dna_implementation.md` | 구현 완료 문서 | 금지/필수 규칙 도출 |
| `03A-401~499_*.md` | DNA 시스템 ADR | 기술 선택 근거 |

---

## 📤 출력 문서

### 필수 산출물

```
docs/
├── 06D-01_project_standards.md    # THE 산출물 (규칙 문서)
└── 06D-02_automation_config.md    # 자동화 설정 문서

프로젝트 루트/
├── pyproject.toml                 # Ruff, MyPy, pytest 설정
├── .pre-commit-config.yaml        # pre-commit hooks
└── .importlinter                  # 아키텍처 의존성 규칙
```

---

## 🔧 Project Standards 3대 영역

### 영역 1: DNA 사용 규칙 (DO/DON'T)

```
각 DNA 시스템마다:

DO (필수):
├─ 어떤 API를 사용해야 하는지
├─ 어떤 패턴을 따라야 하는지
└─ 코드 예시 (언어별)

DON'T (금지):
├─ 어떤 것을 사용하면 안 되는지
├─ 왜 금지인지
└─ 린터/타입 체커 규칙 코드

**참조**: 구체적 규칙 코드는 언어별 매뉴얼 참조
  - Python: Ruff, MyPy 규칙
  - TypeScript: ESLint, TSConfig 규칙
  - Rust: Clippy lints
  - Go: golangci-lint 규칙
```

### 영역 2: 품질 기준 (Zero Tolerance)

```
절대 타협 없는 기준 (언어 무관):

린터:       0 violations
타입 체커:   0 errors
테스트:     0 failures
커버리지:   95%+

위반 시:
├─ 커밋 차단 (pre-commit hook)
├─ PR 머지 차단 (CI)
└─ 배포 차단 (CD)

**Python 예시**:
├─ 린터: Ruff
├─ 타입 체커: MyPy
├─ 테스트: pytest
└─ 커버리지: pytest-cov

**참조**: 다른 언어의 도구는 해당 언어 매뉴얼 참조
```

### 영역 3: 자동화 설정 (강제 메커니즘)

```
3단계 강제 (언어 무관 전략):

Day 1: 로컬 강제 (commit hook)
├─ 린터 (포맷팅 + 스타일)
├─ 타입 체커
└─ 빠른 테스트 (unit)

Week 2: 아키텍처 강제 (dependency checker)
├─ core → domain 금지
├─ domain → api 금지
└─ 레이어 의존성 방향 강제

Month 1+: CI/CD 파이프라인
├─ 전체 테스트 + 커버리지 게이트
├─ 보안 스캔
└─ 자동 배포

**Python 예시**:
├─ Day 1: pre-commit (Ruff, MyPy, pytest)
├─ Week 2: import-linter
└─ Month 1+: GitHub Actions

**참조**: 다른 언어의 도구/파이프라인은 해당 언어 매뉴얼 참조
```

---

## 📋 작성 단계 (Part 1-4)

### Part 1: DNA 사용 규칙 작성 (1시간)

#### Step 1: Logging 규칙

```markdown
## Logging (DNA 1)

### DO ✅

**사용 패턴 (Python 예시)**:

```python
# 올바른 사용
from core.logging import get_logger

logger = get_logger(__name__)

# 기본 로깅
logger.info("주문 생성", order_id=order_id, user_id=user_id)

# 에러 로깅
logger.error("주문 실패", error=str(e), order_id=order_id)

# 컨텍스트 바인딩
from core.logging import bind_context
bind_context(trace_id=trace_id, user_id=user_id)
```

### DON'T ❌

**금지 패턴 (Python 예시)**:

```python
# 금지 1: print() 사용
print(f"Creating order: {data}")  # ❌ Ruff T201 위반!

# 금지 2: logging 직접 사용
import logging
logger = logging.getLogger(__name__)  # ❌ 구조화 로깅 불가

# 금지 3: f-string 메시지
logger.info(f"Order {order_id} created")  # ❌ 구조화 파괴
# 올바른: logger.info("Order created", order_id=order_id)
```

### 린터 규칙 (Python - Ruff)
- `T201`: print 금지
- `G004`: f-string in logging 금지

**참조**: 다른 언어의 로깅 규칙은 해당 언어 매뉴얼 참조
```

#### Step 2: Config 규칙

```markdown
## Configuration (DNA 2)

### DO ✅

**사용 패턴 (Python 예시)**:

```python
# 올바른 사용
from core.config import get_settings

settings = get_settings()

# 설정값 접근
db_url = settings.database_url
redis_url = settings.redis_url

# 환경 확인
if settings.is_production:
    # 운영 전용 로직
```

### DON'T ❌

**금지 패턴 (Python 예시)**:

```python
# 금지 1: os.environ 직접 접근
import os
db_url = os.environ.get("DATABASE_URL")  # ❌ 타입 안전성 없음

# 금지 2: 하드코딩
db_url = "postgresql://localhost/dev"  # ❌ 환경별 분리 불가

# 금지 3: 설정 파일 직접 읽기
import json
config = json.load(open("config.json"))  # ❌ 검증 없음
```

### 의존성 규칙 (Python - import-linter)
- 커스텀 규칙으로 `os.environ` 직접 사용 감지

**참조**: 다른 언어의 설정 관리 규칙은 해당 언어 매뉴얼 참조
```

#### Step 3: Types 규칙

```markdown
## Types (DNA 3)

### DO ✅

**사용 패턴 (Python 예시)**:

```python
# 올바른 사용
from core.types import UserId, OrderId, Money

def create_order(
    user_id: UserId,
    amount: Money,
) -> OrderId:
    ...

# 값 객체 사용
price = Money(amount=Decimal("50000"), currency="KRW")
```

### DON'T ❌

**금지 패턴 (Python 예시)**:

```python
# 금지 1: Any 타입
def process(data: Any) -> Any:  # ❌ 타입 안전성 없음
    ...

# 금지 2: Dict[str, Any]
def create_order(data: Dict[str, Any]):  # ❌ TypedDict 사용
    ...

# 금지 3: 타입 힌트 누락
def create_order(user_id, amount):  # ❌ MyPy strict 위반
    ...
```

### 타입 체커 규칙 (Python - MyPy)
- `strict = true`: 모든 함수에 타입 힌트 필수
- `warn_return_any = true`: Any 반환 경고
- `disallow_any_explicit = true`: 명시적 Any 금지

**참조**: 다른 언어의 타입 규칙은 해당 언어 매뉴얼 참조
```

#### Step 4: Errors 규칙

```markdown
## Error Handling (DNA 4)

### DO ✅

**사용 패턴 (Python 예시)**:

```python
# 올바른 사용
from core.errors import ValidationError, NotFoundError, KISAPIError

# 도메인 에러
if not items:
    raise ValidationError("주문 항목이 비어있습니다", field="items")

# 리소스 없음
if not order:
    raise NotFoundError("Order", order_id)

# 외부 API 에러
if response.status_code != 200:
    raise KISAPIError("KIS API 호출 실패", status_code=response.status_code)
```

### DON'T ❌

**금지 패턴 (Python 예시)**:

```python
# 금지 1: 일반 Exception
raise Exception("Something went wrong")  # ❌ 에러 코드 없음

# 금지 2: except: pass
try:
    ...
except:  # ❌ 모든 에러 삼킴
    pass

# 금지 3: bare except
try:
    ...
except Exception:  # ❌ 너무 광범위
    logger.error("Error")

# 올바른: 구체적 예외 처리
try:
    ...
except ValidationError as e:
    logger.warning("검증 실패", error=e.message)
    raise
except KISAPIError as e:
    logger.error("외부 API 실패", error=e.message)
    raise
```

### 린터 규칙 (Python - Ruff)
- `E722`: bare except 금지
- `B001`: assert 대신 raise 사용

**참조**: 다른 언어의 에러 처리 규칙은 해당 언어 매뉴얼 참조
```

#### Step 5: Database 규칙

```markdown
## Database (DNA 5)

### DO ✅

**사용 패턴 (Python 예시)**:

```python
# 올바른 사용
from core.database import get_session

# 세션 사용 (컨텍스트 매니저)
async with get_session() as session:
    order = Order(user_id=user_id, amount=amount)
    session.add(order)
    await session.commit()

# 쿼리
async with get_session() as session:
    result = await session.execute(
        select(Order).where(Order.user_id == user_id)
    )
    orders = result.scalars().all()
```

### DON'T ❌

**금지 패턴 (Python 예시)**:

```python
# 금지 1: 직접 SQL 문자열
cursor.execute(f"SELECT * FROM orders WHERE id = {order_id}")  # ❌ SQL Injection!

# 금지 2: 세션 수동 관리
session = Session()
try:
    ...
finally:
    session.close()  # ❌ 컨텍스트 매니저 사용

# 금지 3: 트랜잭션 없이 여러 쓰기
session.add(order)
session.commit()
session.add(payment)
session.commit()  # ❌ 원자성 위반
```

### 보안 규칙 (Python - Ruff)
- `S608`: SQL Injection 가능 코드 감지

**참조**: 다른 언어의 데이터베이스 규칙은 해당 언어 매뉴얼 참조
```



### Part 2: 품질 기준 설정 (30분)

#### Zero Tolerance 기준

```markdown
## 품질 기준 (Zero Tolerance)

### 정적 분석 (언어 무관 기준)

| 도구 유형 | 기준 | 위반 시 |
|----------|-----|--------|
| 린터 | 0 violations | 커밋 차단 |
| 타입 체커 | 0 errors | 커밋 차단 |
| 테스트 | 0 failures | 머지 차단 |
| 커버리지 | 95%+ | 머지 차단 |

**Python 예시**: Ruff (린터), MyPy (타입 체커), pytest (테스트)

### 린터 규칙 (Python - Ruff)

```toml
[tool.ruff]
line-length = 88
target-version = "py312"

select = [
    "E",      # pycodestyle errors
    "F",      # pyflakes
    "I",      # isort
    "T201",   # print 금지
    "G004",   # f-string in logging 금지
    "B",      # bugbear
    "S",      # security
    "E722",   # bare except 금지
]

ignore = [
    "E501",   # line too long (formatter가 처리)
]
```

### 타입 체커 규칙 (Python - MyPy)

```toml
[tool.mypy]
python_version = "3.12"
strict = true
warn_return_any = true
warn_unused_ignores = true
disallow_untyped_defs = true
disallow_any_explicit = true

[[tool.mypy.overrides]]
module = "tests.*"
disallow_untyped_defs = false
```

### 테스트 규칙 (Python - pytest)

```toml
[tool.pytest.ini_options]
asyncio_mode = "auto"
addopts = """
    --cov=src
    --cov-fail-under=95
    --cov-report=term-missing
    -q
"""
testpaths = ["tests"]
```

**참조**: 다른 언어의 품질 기준 설정은 해당 언어 매뉴얼 참조
  - TypeScript: ESLint, TSConfig, Jest
  - Rust: Clippy, rustc, Cargo test
  - Go: golangci-lint, go test
```

### Part 3: 자동화 설정 (1시간)

#### Step 1: Commit Hook 설정

**개념 (언어 무관)**:
- 커밋 전에 자동으로 실행되는 검증 스크립트
- 린터, 타입 체커, 빠른 테스트 실행
- 위반 시 커밋 차단

**Python 예시 (.pre-commit-config.yaml)**:

```yaml
# .pre-commit-config.yaml

repos:
  # Ruff (린팅 + 포맷팅)
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.8.0
    hooks:
      - id: ruff
        args: [--fix, --exit-non-zero-on-fix]
      - id: ruff-format

  # MyPy (타입 체크)
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.13.0
    hooks:
      - id: mypy
        additional_dependencies:
          - pydantic>=2.0
          - pydantic-settings>=2.0
        args: [--strict]

  # pytest (로컬 테스트)
  - repo: local
    hooks:
      - id: pytest-unit
        name: pytest unit tests
        entry: pytest tests/unit -q --no-cov
        language: system
        pass_filenames: false
        always_run: true

  # import-linter (아키텍처 검증)
  - repo: local
    hooks:
      - id: import-linter
        name: import-linter
        entry: lint-imports
        language: system
        pass_filenames: false
        always_run: true
```

**참조**: 다른 언어의 commit hook 설정은 해당 언어 매뉴얼 참조
  - TypeScript: Husky + lint-staged
  - Rust: cargo-husky
  - Go: pre-commit with golangci-lint
```

#### Step 2: 아키텍처 의존성 검증 설정

**개념 (언어 무관)**:
- 레이어 간 의존성 방향 강제
- 역방향 의존성 차단
- Clean Architecture 레이어 순서 보장

**Python 예시 (.importlinter)**:

```ini
# .importlinter

[importlinter]
root_package = src

[importlinter:contract:core-independence]
name = Core는 Domain/API에 의존하지 않음
type = forbidden
source_modules =
    src.core
forbidden_modules =
    src.domain
    src.api

[importlinter:contract:domain-independence]
name = Domain은 API에 의존하지 않음
type = forbidden
source_modules =
    src.domain
forbidden_modules =
    src.api

[importlinter:contract:layers]
name = Clean Architecture 레이어
type = layers
layers =
    src.api
    src.domain
    src.core
```

**의존성 방향 (언어 무관 규칙)**:
```
허용:
api → domain → core

금지:
core → domain (역방향!)
domain → api (역방향!)
core → api (건너뛰기!)
```

**참조**: 다른 언어의 의존성 검증 도구는 해당 언어 매뉴얼 참조
  - TypeScript: dependency-cruiser, eslint-plugin-import
  - Rust: cargo-modules, cargo-deny
  - Go: go-mod-outdated, go list
```

#### Step 3: CI 파이프라인 설정

**개념 (언어 무관)**:
- PR 머지 전 자동 검증
- 전체 테스트 + 커버리지 체크
- 보안 스캔 (선택)
- 배포 게이트

**Python 예시 (GitHub Actions)**:

```yaml
# .github/workflows/ci.yml

name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  quality:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install uv
        run: pip install uv

      - name: Install dependencies
        run: uv sync

      - name: Ruff (lint)
        run: uv run ruff check src tests

      - name: Ruff (format)
        run: uv run ruff format --check src tests

      - name: MyPy
        run: uv run mypy src --strict

      - name: import-linter
        run: uv run lint-imports

      - name: pytest
        run: uv run pytest --cov=src --cov-fail-under=95

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          fail_ci_if_error: true
```

**참조**: 다른 언어/플랫폼의 CI 설정은 해당 언어 매뉴얼 참조
  - TypeScript: GitHub Actions with Node.js
  - Rust: GitHub Actions with Cargo
  - Go: GitHub Actions with Go
  - GitLab CI, CircleCI, Jenkins 등
```

### Part 4: 자동화 성숙도 로드맵 (30분)

#### Day 1: 로컬 강제 (Commit Hook)

**개념**: 개발자 로컬에서 즉시 검증

**Python 예시**:
```bash
# pre-commit 설치
uv add --dev pre-commit
pre-commit install

# 첫 검증
pre-commit run --all-files
```

**이 시점의 강제 (언어 무관)**:
- ✅ 린터 (포맷팅 + 스타일)
- ✅ 타입 체커
- ✅ 빠른 테스트 (unit)

#### Week 2: 아키텍처 강제 (Dependency Check)

**개념**: 레이어 간 의존성 방향 검증

**Python 예시**:
```bash
# import-linter 설치
uv add --dev import-linter

# 검증
lint-imports
```

**이 시점의 강제 (언어 무관)**:
- ✅ Day 1 모든 것
- ✅ 레이어 의존성 (core ← domain ← api)
- ✅ 역방향 의존성 차단

#### Month 1+: CI/CD 파이프라인

**개념**: PR 머지 전 전체 검증 + 배포 자동화

**Python 예시**:
```bash
# GitHub Actions 설정
mkdir -p .github/workflows
cp templates/ci.yml .github/workflows/
```

**이 시점의 강제 (언어 무관)**:
- ✅ Week 2 모든 것
- ✅ PR 머지 게이트
- ✅ 커버리지 리포트
- ✅ 배포 파이프라인

**참조**: 다른 언어의 자동화 로드맵은 해당 언어 매뉴얼 참조

---

## 📄 PROJECT_STANDARDS.md 템플릿

> **참고**: 이 템플릿은 Python 예시입니다. 다른 언어는 해당 언어 매뉴얼의 템플릿을 참조하세요.

### 06D-01_project_standards.md (Python)

```markdown
# Project Standards

> **프로젝트**: [프로젝트명]
> **버전**: v1.0
> **작성일**: YYYY-MM-DD
> **기반 ADR**: 03A-401 ~ 03A-411 (DNA 시스템)
> **언어**: Python 3.12+

---

## 1. 코드 스타일

### 1.1 포맷팅
- **도구**: Ruff formatter
- **줄 길이**: 88자
- **들여쓰기**: 4 spaces
- **인용부호**: 큰따옴표 (")

### 1.2 네이밍
| 대상 | 규칙 | 예시 |
|------|-----|------|
| 클래스 | PascalCase | `OrderService` |
| 함수/변수 | snake_case | `create_order` |
| 상수 | UPPER_SNAKE_CASE | `MAX_RETRY_COUNT` |
| 비공개 | _prefix | `_internal_method` |

### 1.3 Import 순서
```python
# 1. 표준 라이브러리
import os
from datetime import datetime

# 2. 서드파티
from fastapi import FastAPI
from pydantic import BaseModel

# 3. 로컬 (core → domain → api 순)
from core.logging import get_logger
from domain.orders import OrderService
```

---

## 2. DNA 시스템 사용 규칙

### 2.1 Logging

**DO ✅**
```python
from core.logging import get_logger
logger = get_logger(__name__)
logger.info("주문 생성", order_id=order_id)
```

**DON'T ❌**
```python
print("debug")                    # T201 위반
import logging                    # 직접 사용 금지
logger.info(f"Order {id}")        # G004 위반
```

### 2.2 Configuration

**DO ✅**
```python
from core.config import get_settings
settings = get_settings()
db_url = settings.database_url
```

**DON'T ❌**
```python
import os
os.environ.get("DB_URL")          # 타입 안전성 없음
db_url = "postgresql://..."       # 하드코딩 금지
```

### 2.3 Types

**DO ✅**
```python
from core.types import UserId, OrderId, Money

def create_order(user_id: UserId, amount: Money) -> OrderId:
    ...
```

**DON'T ❌**
```python
def create_order(user_id, amount):  # 타입 힌트 누락
    ...

def process(data: Any) -> Any:      # Any 금지
    ...
```

### 2.4 Error Handling

**DO ✅**
```python
from core.errors import ValidationError, NotFoundError

if not items:
    raise ValidationError("항목 필요", field="items")
```

**DON'T ❌**
```python
raise Exception("error")           # 일반 Exception 금지
except:                            # bare except 금지
    pass
```

### 2.5 Database

**DO ✅**
```python
from core.database import get_session

async with get_session() as session:
    session.add(order)
    await session.commit()
```

**DON'T ❌**
```python
cursor.execute(f"SELECT * WHERE id = {id}")  # SQL Injection!
session = Session()                           # 수동 관리 금지
```

---

## 3. 품질 기준

### 3.1 Zero Tolerance

| 항목 | 기준 | 검증 명령어 |
|------|-----|-----------|
| Ruff | 0 violations | `ruff check src tests` |
| MyPy | 0 errors | `mypy src --strict` |
| pytest | 0 failures | `pytest tests` |
| Coverage | 95%+ | `pytest --cov-fail-under=95` |

### 3.2 커밋 전 필수

```bash
# 모든 검증 통과 필수
pre-commit run --all-files
```

위반 시 커밋 차단됨.

---

## 4. 아키텍처 규칙

### 4.1 레이어 구조

```
src/
├── core/      # DNA 시스템 (공통 인프라)
├── domain/    # 비즈니스 로직
└── api/       # HTTP 인터페이스
```

### 4.2 의존성 방향

```
허용: api → domain → core
금지: core → domain, domain → api
```

### 4.3 import-linter로 강제

```bash
# 검증
lint-imports

# 위반 시
FAILED: Core는 Domain/API에 의존하지 않음
  src.core.database imports src.domain.orders
```

---

## 5. Git 규칙

### 5.1 커밋 메시지

```
<type>(<scope>): <subject>

feat(orders): 주문 생성 API 추가
fix(auth): 토큰 만료 처리 수정
refactor(core): 로깅 설정 개선
test(orders): 주문 서비스 테스트 추가
docs(readme): 설치 가이드 업데이트
```

### 5.2 브랜치 전략

```
main         ← 운영 (보호됨)
develop      ← 개발 통합
feature/*    ← 기능 개발
fix/*        ← 버그 수정
```

### 5.3 PR 규칙

- [ ] 모든 CI 통과
- [ ] 리뷰어 1명 이상 승인
- [ ] 커버리지 유지 또는 증가

---

## 6. 참조

- ADR: `docs/adr/03A-401~411_*.md`
- DNA 구현: `src/core/`
- 자동화 설정: `pyproject.toml`, `.pre-commit-config.yaml`
```



---

## ✏️ 작성 예시: 주식 거래 플랫폼

> **참고**: 이 예시들은 Python 생태계 기반입니다. 다른 언어는 해당 언어 매뉴얼의 예시를 참조하세요.

### 예시 1: DNA 사용 규칙 (Logging 상세) - Python

```markdown
## 2.1 Logging

> **ADR 참조**: ADR-401 (structlog 선택)

### 목적
모든 로그는 JSON 구조화 형식으로, trace_id를 포함하여 추적 가능해야 함.

### DO ✅ (필수 사용법)

```python
# 1. 로거 초기화
from core.logging import get_logger, bind_context

logger = get_logger(__name__)

# 2. 요청 시작 시 컨텍스트 바인딩
@app.middleware("http")
async def logging_middleware(request: Request, call_next):
    bind_context(
        trace_id=request.headers.get("X-Trace-ID", str(uuid4())[:8]),
        user_id=getattr(request.state, "user_id", "anonymous"),
    )
    return await call_next(request)

# 3. 비즈니스 로직에서 로깅
async def create_order(self, data: CreateOrderRequest) -> OrderId:
    logger.info("주문 생성 시작", symbol=data.symbol, quantity=data.quantity)
    
    try:
        order = await self._process_order(data)
        logger.info("주문 생성 완료", order_id=str(order.id))
        return order.id
    except KISAPIError as e:
        logger.error("KIS API 실패", error=str(e), symbol=data.symbol)
        raise
```

### DON'T ❌ (금지 사항)

```python
# 금지 1: print() 사용
# Ruff T201 위반 → 커밋 차단
print(f"Order created: {order_id}")

# 금지 2: logging 직접 사용
# 구조화 로깅 불가, trace_id 누락
import logging
logging.info("Order created")

# 금지 3: f-string 메시지
# Ruff G004 위반 → 검색/필터링 어려움
logger.info(f"Order {order_id} created by {user_id}")
# 올바른: logger.info("Order created", order_id=order_id, user_id=user_id)

# 금지 4: 예외 정보 누락
try:
    ...
except Exception:
    logger.error("실패")  # ❌ 예외 정보 없음
# 올바른: logger.exception("실패", exc_info=True)
```

### 검증 방법

```bash
# Ruff로 print 검사
ruff check src --select=T201,G004

# 결과 (위반 시)
src/domain/orders/service.py:45:5: T201 `print` found
src/domain/orders/service.py:52:9: G004 Logging statement uses f-string
```

### 로그 출력 예시

```json
{
  "event": "주문 생성 완료",
  "trace_id": "abc12345",
  "user_id": "user-789",
  "order_id": "order-456",
  "timestamp": "2025-12-03T10:30:00Z",
  "level": "info",
  "logger": "domain.orders.service"
}
```
```

### 예시 2: 자동화 설정 (전체) - Python

```markdown
## 자동화 설정 (Python)

### pyproject.toml (완전판)

```toml
[project]
name = "stock-trading-platform"
version = "0.1.0"
requires-python = ">=3.12"

dependencies = [
    "fastapi>=0.115.0",
    "pydantic>=2.11.0",
    "pydantic-settings>=2.6.0",
    "structlog>=24.1.0",
    "sqlalchemy>=2.0.0",
    "redis>=5.0.0",
    "httpx>=0.27.0",
    "uvloop>=0.21.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.3.0",
    "pytest-cov>=6.0.0",
    "pytest-asyncio>=0.24.0",
    "ruff>=0.8.0",
    "mypy>=1.13.0",
    "pre-commit>=4.0.0",
    "import-linter>=2.0.0",
]

[tool.ruff]
line-length = 88
target-version = "py312"

select = [
    "E",      # pycodestyle errors
    "F",      # pyflakes
    "I",      # isort
    "T201",   # print 금지
    "G004",   # f-string in logging 금지
    "B",      # bugbear
    "S",      # security (SQL injection 등)
    "E722",   # bare except 금지
    "UP",     # pyupgrade
]

[tool.ruff.format]
quote-style = "double"

[tool.mypy]
python_version = "3.12"
strict = true
warn_return_any = true
warn_unused_ignores = true
disallow_untyped_defs = true

[[tool.mypy.overrides]]
module = "tests.*"
disallow_untyped_defs = false

[tool.pytest.ini_options]
asyncio_mode = "auto"
addopts = "--cov=src --cov-fail-under=95 --cov-report=term-missing -q"
testpaths = ["tests"]

[tool.coverage.run]
source = ["src"]
omit = ["tests/*", "*/__init__.py"]

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "if TYPE_CHECKING:",
    "raise NotImplementedError",
]
```

### .pre-commit-config.yaml (완전판)

```yaml
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.8.0
    hooks:
      - id: ruff
        args: [--fix, --exit-non-zero-on-fix]
      - id: ruff-format

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.13.0
    hooks:
      - id: mypy
        additional_dependencies:
          - pydantic>=2.0
          - pydantic-settings>=2.0
          - sqlalchemy>=2.0
        args: [--strict]
        pass_filenames: false
        entry: mypy src

  - repo: local
    hooks:
      - id: pytest-unit
        name: pytest unit tests
        entry: pytest tests/unit -q --no-cov
        language: system
        pass_filenames: false
        always_run: true
        stages: [pre-commit]

      - id: import-linter
        name: import-linter
        entry: lint-imports
        language: system
        pass_filenames: false
        always_run: true
```

### .importlinter (완전판)

```ini
[importlinter]
root_package = src

[importlinter:contract:core-independence]
name = Core는 Domain/API에 의존하지 않음
type = forbidden
source_modules =
    src.core
forbidden_modules =
    src.domain
    src.api

[importlinter:contract:domain-independence]
name = Domain은 API에 의존하지 않음
type = forbidden
source_modules =
    src.domain
forbidden_modules =
    src.api

[importlinter:contract:clean-layers]
name = Clean Architecture 레이어 순서
type = layers
layers =
    src.api
    src.domain
    src.core
```
```

### 예시 3: CI 파이프라인 - Python (GitHub Actions)

```yaml
# .github/workflows/ci.yml

name: CI Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

env:
  PYTHON_VERSION: '3.12'

jobs:
  lint:
    name: Lint & Format
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install uv
        run: pip install uv
      
      - name: Install dependencies
        run: uv sync --dev
      
      - name: Ruff lint
        run: uv run ruff check src tests
      
      - name: Ruff format
        run: uv run ruff format --check src tests

  type-check:
    name: Type Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install uv
        run: pip install uv
      
      - name: Install dependencies
        run: uv sync --dev
      
      - name: MyPy
        run: uv run mypy src --strict

  architecture:
    name: Architecture Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install uv
        run: pip install uv
      
      - name: Install dependencies
        run: uv sync --dev
      
      - name: import-linter
        run: uv run lint-imports

  test:
    name: Test & Coverage
    runs-on: ubuntu-latest
    needs: [lint, type-check, architecture]
    
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7
        ports:
          - 6379:6379
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install uv
        run: pip install uv
      
      - name: Install dependencies
        run: uv sync --dev
      
      - name: Run tests
        run: uv run pytest --cov=src --cov-fail-under=95 --cov-report=xml
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test
          REDIS_URL: redis://localhost:6379
      
      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          files: coverage.xml
          fail_ci_if_error: true
```

---

## ✅ Stage 6 완료 체크리스트

### DNA 사용 규칙

- [ ] Logging DO/DON'T 작성
- [ ] Config DO/DON'T 작성
- [ ] Types DO/DON'T 작성
- [ ] Errors DO/DON'T 작성
- [ ] Database DO/DON'T 작성 (패밀리별)

### 품질 기준

- [ ] Zero Tolerance 기준 명시 (Ruff 0, MyPy 0, Coverage 95%)
- [ ] pyproject.toml [tool.ruff] 설정
- [ ] pyproject.toml [tool.mypy] 설정
- [ ] pyproject.toml [tool.pytest] 설정

### 자동화 설정

- [ ] .pre-commit-config.yaml 작성
- [ ] pre-commit install 실행
- [ ] .importlinter 설정
- [ ] lint-imports 검증

### CI/CD (선택)

- [ ] GitHub Actions workflow 작성
- [ ] PR 머지 게이트 설정
- [ ] 커버리지 리포트 설정

### 산출물 생성

- [ ] `06D-01_project_standards.md` 작성
- [ ] `06D-02_automation_config.md` 작성 (선택)
- [ ] 모든 설정 파일 프로젝트 루트에 배치

### 검증

- [ ] `pre-commit run --all-files` 통과
- [ ] `lint-imports` 통과
- [ ] 기존 코드 모두 규칙 준수 확인

---

## 🔗 Stage 6 → Stage 7 연결

### Stage 7에 전달하는 것

| 전달 항목 | 내용 | 용도 |
|----------|------|------|
| PROJECT_STANDARDS.md | DNA 사용 규칙 | 도메인 코드 작성 기준 |
| 자동화 설정 | pre-commit, CI | 품질 강제 |
| 아키텍처 규칙 | import-linter | 의존성 방향 강제 |

### Bridge 완료!

```
Bridge(Stage 4-6) 완료:

Stage 4: DNA 청사진 ✅
  └─ 무엇을 만들지 설계

Stage 5: DNA 구현 ✅
  └─ 실제 코드 작성

Stage 6: Project Standards ✅ ← 지금 여기!
  └─ 강제 규칙 + 자동화

결과:
├─ src/core/ DNA 모듈 완성
├─ PROJECT_STANDARDS.md 규칙 문서
├─ pre-commit, import-linter 자동화
└─ CI 파이프라인 (선택)

이제 도메인 코드를 안전하게 작성할 수 있는 "환경" 완성!
```

### Stage 7 미리보기

```
Stage 7: Project Blueprint
├─ 도메인 모델 설계 (Entity, Value Object, Aggregate)
├─ API 설계 (엔드포인트, 요청/응답)
├─ 데이터베이스 스키마
└─ DNA 환경 위에서 도메인 상세 설계
```

---

## ⏪ 이전 Stage 검증 및 수정 프로토콜

### 검증 시점
- Stage 6 시작 전 필수 체크 (Bridge 완성 직전!)
- 자동화 설정 전 DNA 구현과 교차 검증

### 검증 대상

| Stage | 산출물 | 검증 항목 |
|-------|--------|----------|
| Stage 1 | 01C-01_*.md | 표준이 NFR 우선순위 반영? |
| Stage 2 | 02C-01_*.md | 표준이 기술 제약 반영? |
| Stage 3 | 03A-*_*.md | 표준이 ADR 결정 반영? |
| Stage 4 | 04B-01_*.md | 표준이 DNA 청사진 반영? |
| Stage 5 | 05D-01_*.md | 구현된 DNA와 표준 일치? |

### 오류 발견 시 프로토콜 (Bridge 완성 전 마지막 검증!)

```
Stage 6에서 Stage 1-5 오류 발견 시:

Step 1: 오류 발견 및 문서화
├─ 발견 위치: 표준 [섹션] 작성 중
├─ 오류 내용: [구체적 설명]
├─ 영향 Stage: Stage [1-5]
└─ 기록: 06D-01에 "발견된 이슈" 추가

⚠️ Stage 6은 Bridge 완성 직전!
├─ 여기서 오류 수정 = 비용 최소
├─ Stage 7 이후 발견 = 비용 급증
└─ 철저한 검증 필수!

Step 2: 영향 범위 파악
├─ DNA 구현(Stage 5) 수정 필요?
├─ 청사진(Stage 4) 수정 필요?
├─ ADR(Stage 3) 수정 필요?
└─ 재작업 예상: [X]시간

Step 3: 해당 Stage로 이동 → 수정

Step 4: 중간 Stage 전파 (Stage 4-5)

Step 5: Stage 6 재진행
├─ 수정된 DNA로 표준 재검토
└─ 자동화 설정 재검증

Step 6: Bridge 완성 검증 → Stage 7 전달 ✅
```

### 흔한 오류 패턴

| 오류 유형 | 예시 | 해결 |
|----------|------|------|
| DNA-표준 불일치 | 로깅 함수명 불일치 | Stage 5 구현 또는 표준 수정 |
| ADR 미반영 | 코드 스타일 ADR과 표준 불일치 | 표준 수정 |
| 자동화 불가 | 규칙은 있으나 검증 방법 없음 | 규칙 재정의 또는 커스텀 린터 |

### 추적성

```
수정 이력: docs/revision_log.md
표준 참조: PROJECT_STANDARDS.md에 ADR 링크 포함
```

---

## 💡 핵심 원칙 요약

### Project Standards의 3대 영역

```
1. DNA 사용 규칙 (DO/DON'T)
────────────────────────────────
각 DNA 시스템마다:
├─ DO: 필수 사용법 + 코드 예시
├─ DON'T: 금지 사항 + 이유
└─ Ruff/MyPy 규칙 코드

2. 품질 기준 (Zero Tolerance)
────────────────────────────────
절대 타협 없는 기준:
├─ Ruff: 0 violations
├─ MyPy: 0 errors
├─ pytest: 0 failures
└─ Coverage: 95%+

3. 자동화 설정 (강제 메커니즘)
────────────────────────────────
3단계 강제:
├─ Day 1: pre-commit (로컬)
├─ Week 2: import-linter (아키텍처)
└─ Month 1+: CI/CD (파이프라인)
```

### 규칙 vs 강제

```
규칙만 있으면:
├─ 문서는 존재하지만 아무도 안 읽음
├─ 코드 리뷰에서 "이번만 넘어가죠"
└─ 3개월 후 "누가 이렇게 한 거야?!" 😱

규칙 + 강제:
├─ 커밋 자체가 차단됨
├─ 개발자가 즉시 수정
├─ 코드 리뷰 불필요 (자동 강제)
└─ 운영 환경 100% 안전 ✅
```

### 자동화 성숙도 로드맵

```
Day 1: pre-commit
├─ Ruff (린팅 + 포맷팅)
├─ MyPy (타입 체크)
└─ 기본 테스트

Week 2: import-linter
├─ 레이어 의존성 강제
└─ 역방향 의존성 차단

Month 1+: CI/CD
├─ PR 머지 게이트
├─ 커버리지 리포트
└─ 배포 파이프라인
```

---

**Remember**: 
- 규칙 없는 자동화 = 무엇을 강제할지 모름
- 자동화 없는 규칙 = 아무도 안 지킴
- 둘 다 있어야 = 100% 품질 보장
- Bridge 완료 = 도메인 코드 작성 환경 완성!

*Stage 6으로 Bridge(Stage 4-6)가 완료됩니다. 이제 Stage 7부터 도메인 코드를 안전하게 작성할 수 있습니다.*


================================================================================

📄 FILE: 07G-00_blueprint_guide.md
--------------------------------------------------------------------------------

# Stage 7: 프로젝트 블루프린트 가이드 (Project Blueprint Guide)

> **목적**: 모든 ADR을 통합하여 도메인 전체 설계도 작성 (코드 작성 직전 단계)
>
> **버전**: v4.1 (2025-12-03)
>
> - v4.0 (2025-12-03): Gemini 연구 기반 전면 재작성, 01_DNA_METHODOLOGY_DETAILED.md 기준
> - v2.0 (2025-11-12): 입력/출력 문서 추가
> - v1.0 (2025-11-10): 초기 버전

---

## 📚 이 가이드의 위치

```
DNA 방법론 문서 체계:

Tier 1: 00_CORE_METHODOLOGY.md (전체 맥락)
           ↓
Tier 2: 01_DNA_METHODOLOGY_DETAILED.md (상세 원리)
           ↓
Tier 3: 이 문서 (Stage 7 실행 가이드) ← 지금 여기!
```

**참조 문서**:
- **원리 이해**: `01_DNA_METHODOLOGY_DETAILED.md` **Part 6.1**

---

## 🤔 왜 Project Blueprint가 필요한가?

### ADR vs Blueprint

```
ADR (Stage 3):
├─ "무엇을" 결정했는지
├─ "왜" 그렇게 결정했는지
├─ 개별 결정 단위 (하나의 주제)
└─ 예: "PostgreSQL을 선택한다"

Blueprint (Stage 7):
├─ "어떻게" 구현할 것인지
├─ 모든 ADR을 통합한 전체 그림
├─ 구체적인 구현 명세
└─ 예: "users 테이블 스키마, orders API 엔드포인트..."

관계:
ADR-001 (PostgreSQL) ─┐
ADR-002 (JWT 인증)   ─┼──→ Blueprint (전체 설계도)
ADR-003 (KIS API)    ─┘
```

### Blueprint 없이 구현하면?

```
❌ ADR만 보고 구현:

개발자 A: "ADR에 PostgreSQL 쓴다고 했으니 테이블 만들자"
  → users 테이블: id, name, email

개발자 B: "나도 users 테이블 필요한데..."
  → users 테이블: user_id, username, email_address

결과:
├─ 테이블 스키마 불일치
├─ 필드명 혼란 (id vs user_id, name vs username)
├─ 나중에 대규모 마이그레이션 필요
└─ "처음부터 설계했으면..." 😱
```

```
✅ Blueprint 기반 구현:

07B-01_project_blueprint.md:
────────────────────────────────
## 3. 도메인 모델

### 3.1 User 엔티티
| 필드 | 타입 | 설명 |
|------|------|------|
| id | UUID | PK, core.types.UserId |
| email | str | Unique, EmailStr |
| created_at | datetime | UTC |
| updated_at | datetime | UTC |

참조: ADR-003 (PostgreSQL), PROJECT_STANDARDS.md Ln 45-60

개발자 A, B 모두:
  → 동일한 스키마 구현
  → 동일한 타입 사용 (UserId)
  → 일관된 코드베이스 ✅
```

### 비유: 건축 설계도

```
ADR = 건축 결정:
├─ "콘크리트 구조로 한다" (ADR-001)
├─ "3층 건물로 한다" (ADR-002)
└─ "지하 주차장을 둔다" (ADR-003)

Blueprint = 건축 설계도:
├─ 1층 평면도: 로비, 회의실, 화장실 위치
├─ 2층 평면도: 사무실 배치
├─ 3층 평면도: 임원실, 서버실
├─ 배관도: 수도, 전기, 통신
├─ 구조도: 기둥, 보, 벽체 위치
└─ 모든 치수, 자재 명시

→ 설계도 없이 "콘크리트로 3층 짓자"만 있으면?
  시공자마다 다르게 해석해서 건물이 엉망!
```

---

## 📥 입력 문서

### Stage 3-6에서 전달받는 것

| 파일 | 핵심 내용 | 이 Stage에서 사용 |
|------|----------|-----------------|
| `03A-*_*.md` | 모든 ADR (DNA + 도메인) | 결정 사항 통합 |
| `06D-01_project_standards.md` | 프로젝트 표준 | 규칙 참조 |
| `01C-01_*.md` | 패밀리 분류 | 시스템 특성 확인 |
| `02C-01_*.md` | NFR 우선순위 | 품질 속성 확인 |

---

## 📤 출력 문서

### 필수 산출물

```
docs/
├── 07B-01_project_blueprint.md    # THE 산출물 (전체 설계도)
└── 07S-01_domain_diagrams/        # 도메인별 다이어그램 (선택)
    ├── system_architecture.md
    ├── data_flow.md
    └── entity_relationship.md
```

---

## 🔧 Blueprint 9대 섹션

### 섹션 구조

```
07B-01_project_blueprint.md
────────────────────────────────

1. 시스템 개요        ← 무엇을 만드는가?
2. 아키텍처 구조      ← 전체 구조는?
3. 도메인 모델        ← 핵심 객체는?
4. API 설계          ← 외부 인터페이스는?
5. 데이터베이스 설계   ← 데이터 저장은?
6. 외부 연동          ← 외부 시스템은?
7. 에러 처리          ← 실패 시 대응은?
8. 보안              ← 인증/인가는?
9. 다음 단계          ← Stage 8 연결
```

---

## 📋 작성 단계 (Part 1-4)

### Part 1: 시스템 개요 + 아키텍처 (1시간)

#### 섹션 1: 시스템 개요

```markdown
## 1. 시스템 개요

### 1.1 목적
주식 자동매매 플랫폼 - 사용자가 정의한 전략에 따라 KIS API를 통해 자동으로 주식을 매매

### 1.2 범위
- 포함: 주문 관리, 포트폴리오 조회, 전략 실행, 알림
- 제외: 백테스팅, 리스크 관리 (v2.0 예정)

### 1.3 핵심 기능
| 기능 | 설명 | 우선순위 |
|------|------|---------|
| 주문 생성 | 매수/매도 주문 | P0 |
| 주문 조회 | 주문 상태 확인 | P0 |
| 포트폴리오 | 보유 종목 조회 | P0 |
| 전략 실행 | 자동매매 전략 | P1 |
| 알림 | 체결 알림 | P1 |

### 1.4 패밀리 분류
- **패밀리**: A-A-B (CRUD/트랜잭션)
- **근거**: 금융 거래 → 강한 일관성 필수
- **참조**: 01C-01_family_classification.md
```

#### 섹션 2: 아키텍처 구조

```markdown
## 2. 아키텍처 구조

### 2.1 레이어 구조

```
┌─────────────────────────────────────────────────────────┐
│                    Presentation Layer                    │
│              (API Framework + WebSocket)                 │
├─────────────────────────────────────────────────────────┤
│                    Application Layer                     │
│                (Use Cases / Services)                    │
├─────────────────────────────────────────────────────────┤
│                      Domain Layer                        │
│             (Entities, Value Objects, Events)            │
├─────────────────────────────────────────────────────────┤
│                   Infrastructure Layer                   │
│     (Database, External APIs, Cache, Messaging)         │
├─────────────────────────────────────────────────────────┤
│                      Core Layer                          │
│        (DNA Systems - Logging, Config, Types...)         │
└─────────────────────────────────────────────────────────┘
```

### 2.2 의존성 방향

```
Presentation → Application → Domain ← Infrastructure
                               ↑
                             Core
```

- **규칙**: 안쪽으로만 의존 (Domain이 중심)
- **강제**: import-linter (Stage 6 설정)
- **참조**: ADR-004 하이브리드 아키텍처

### 2.3 컴포넌트 구조

```
src/
├── core/           # DNA 시스템 (Stage 5 완료)
├── domain/         # 도메인 레이어
│   ├── orders/     # 주문 도메인
│   ├── portfolio/  # 포트폴리오 도메인
│   └── strategy/   # 전략 도메인
├── application/    # 애플리케이션 레이어
│   ├── orders/     # 주문 유스케이스
│   ├── portfolio/  # 포트폴리오 유스케이스
│   └── strategy/   # 전략 유스케이스
├── infrastructure/ # 인프라 레이어
│   ├── database/   # 리포지토리 구현
│   ├── external/   # 외부 API 클라이언트
│   └── messaging/  # 이벤트 발행
└── api/            # 프레젠테이션 레이어
    ├── routes/     # API 라우터
    ├── schemas/    # 요청/응답 스키마
    └── middleware/ # 미들웨어
```
```

### Part 2: 도메인 모델 설계 (2시간)

#### 섹션 3: 도메인 모델

```markdown
## 3. 도메인 모델

### 3.1 엔티티 (Entities)

#### User 엔티티
| 필드 | 타입 | 설명 | 제약 |
|------|------|------|------|
| id | UserId (UUID) | PK | core.types.UserId |
| email | EmailStr | 로그인 이메일 | Unique |
| hashed_password | str | bcrypt 해시 | - |
| is_active | bool | 활성 상태 | Default: True |
| created_at | datetime | 생성 시간 | UTC |
| updated_at | datetime | 수정 시간 | UTC |

**참조**: PROJECT_STANDARDS.md (네이밍 규칙)

#### Order 엔티티 (Aggregate Root)
| 필드 | 타입 | 설명 | 제약 |
|------|------|------|------|
| id | OrderId (UUID) | PK | core.types.OrderId |
| user_id | UserId | FK → users | Not Null |
| symbol | str | 종목 코드 | 6자리 |
| side | OrderSide | 매수/매도 | Enum |
| order_type | OrderType | 지정가/시장가 | Enum |
| quantity | int | 주문 수량 | > 0 |
| price | Money | 주문 가격 | >= 0 |
| status | OrderStatus | 주문 상태 | Enum |
| kis_order_id | str | KIS 주문번호 | Nullable |
| created_at | datetime | 생성 시간 | UTC |
| updated_at | datetime | 수정 시간 | UTC |

**도메인 규칙**:
- 시장가 주문 시 price = 0
- status 전이: pending → submitted → filled/cancelled
- 취소는 pending/submitted 상태에서만 가능

**참조**: ADR-101 주문 도메인

#### Portfolio 엔티티
| 필드 | 타입 | 설명 | 제약 |
|------|------|------|------|
| id | PortfolioId (UUID) | PK | - |
| user_id | UserId | FK → users | Unique |
| total_value | Money | 총 평가액 | >= 0 |
| cash_balance | Money | 현금 잔고 | >= 0 |
| updated_at | datetime | 갱신 시간 | UTC |

### 3.2 값 객체 (Value Objects)

#### Money
```
Value Object: Money
├─ amount: Decimal (>= 0)
├─ currency: String (ISO 4217, 기본값: "KRW")
└─ 연산: add, subtract (동일 통화만)
```

**참조**: core/types/ 디렉토리 (Stage 5 구현)

#### OrderSide
```
Enum: OrderSide
├─ BUY = "buy"
└─ SELL = "sell"
```

#### OrderStatus
```
Enum: OrderStatus
├─ PENDING = "pending"           # 생성됨
├─ SUBMITTED = "submitted"       # 거래소 제출됨
├─ FILLED = "filled"             # 체결됨
├─ PARTIALLY_FILLED = "partial"  # 부분 체결
├─ CANCELLED = "cancelled"       # 취소됨
└─ REJECTED = "rejected"         # 거부됨
```

### 3.3 집계 (Aggregates)

#### Order Aggregate
```
Order (Root)
├─ OrderId
├─ UserId (참조)
├─ Money (가격)
├─ OrderStatus
└─ 도메인 메서드
   ├─ submit(): pending → submitted
   ├─ fill(): submitted → filled
   └─ cancel(): pending/submitted → cancelled
```

**불변 규칙**:
- Order는 항상 유효한 상태 전이만 허용
- 취소된 주문은 다시 활성화 불가
- filled 상태에서 수정 불가

### 3.4 도메인 이벤트

| 이벤트 | 발행 시점 | 페이로드 |
|-------|---------|---------|
| OrderCreated | 주문 생성 시 | order_id, user_id, symbol |
| OrderSubmitted | KIS 제출 성공 시 | order_id, kis_order_id |
| OrderFilled | 체결 완료 시 | order_id, filled_price, filled_at |
| OrderCancelled | 취소 완료 시 | order_id, reason |
```



### Part 3: API + 데이터베이스 설계 (2시간)

#### 섹션 4: API 설계

```markdown
## 4. API 설계

### 4.1 엔드포인트 목록

#### Orders API
| Method | Path | 설명 | 인증 |
|--------|------|------|-----|
| POST | /api/v1/orders | 주문 생성 | Required |
| GET | /api/v1/orders | 주문 목록 조회 | Required |
| GET | /api/v1/orders/{id} | 주문 상세 조회 | Required |
| DELETE | /api/v1/orders/{id} | 주문 취소 | Required |

#### Portfolio API
| Method | Path | 설명 | 인증 |
|--------|------|------|-----|
| GET | /api/v1/portfolio | 포트폴리오 조회 | Required |
| GET | /api/v1/portfolio/positions | 보유 종목 조회 | Required |

#### Auth API
| Method | Path | 설명 | 인증 |
|--------|------|------|-----|
| POST | /api/v1/auth/login | 로그인 | - |
| POST | /api/v1/auth/refresh | 토큰 갱신 | Required |

**참조**: ADR-101 API 버저닝

### 4.2 요청/응답 스키마

#### POST /api/v1/orders - 주문 생성

**Request**:
```
CreateOrderRequest:
├─ symbol: String (6자리 숫자, 종목 코드)
├─ side: OrderSide (BUY | SELL)
├─ order_type: OrderType (MARKET | LIMIT)
├─ quantity: Integer (> 0)
└─ price: Decimal? (>= 0, 지정가 주문 시 필수)

검증 규칙:
└─ order_type == LIMIT → price 필수
```

**Response** (201 Created):
```
OrderResponse:
├─ id: UUID
├─ symbol: String
├─ side: OrderSide
├─ order_type: OrderType
├─ quantity: Integer
├─ price: Decimal?
├─ status: OrderStatus
└─ created_at: DateTime

CreateOrderResponse:
├─ order: OrderResponse
└─ message: String ("주문이 생성되었습니다")
```

**Error Responses**:
| Status | Error Code | 설명 |
|--------|-----------|------|
| 400 | 1001 | 검증 오류 (잘못된 종목 코드 등) |
| 401 | 9401 | 인증 필요 |
| 422 | 1002 | 처리 불가 (잔고 부족 등) |
| 502 | 2001 | KIS API 오류 |

**참조**: core/errors/codes.py (Stage 5 구현)

### 4.3 인증 흐름

```
1. 로그인 요청
   POST /api/v1/auth/login
   Body: { "email": "...", "password": "..." }

2. 토큰 발급
   Response: { "access_token": "...", "refresh_token": "...", "expires_in": 3600 }

3. API 요청
   Header: Authorization: Bearer {access_token}

4. 토큰 만료 시
   POST /api/v1/auth/refresh
   Header: Authorization: Bearer {refresh_token}
```

**참조**: ADR-011 보안 (JWT)
```

#### 섹션 5: 데이터베이스 설계

```markdown
## 5. 데이터베이스 설계

### 5.1 테이블 스키마

#### users 테이블
```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) NOT NULL UNIQUE,
    hashed_password VARCHAR(255) NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 인덱스
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);
```

#### orders 테이블
```sql
CREATE TABLE orders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    symbol VARCHAR(10) NOT NULL,
    side VARCHAR(10) NOT NULL,  -- buy, sell
    order_type VARCHAR(20) NOT NULL,  -- limit, market
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    price DECIMAL(15, 2),
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    kis_order_id VARCHAR(50),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 인덱스
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_created_at ON orders(created_at DESC);
CREATE INDEX idx_orders_symbol ON orders(symbol);

-- 복합 인덱스 (자주 사용되는 쿼리)
CREATE INDEX idx_orders_user_status ON orders(user_id, status);
```

#### portfolios 테이블
```sql
CREATE TABLE portfolios (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL UNIQUE REFERENCES users(id),
    total_value DECIMAL(15, 2) NOT NULL DEFAULT 0,
    cash_balance DECIMAL(15, 2) NOT NULL DEFAULT 0,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 인덱스
CREATE INDEX idx_portfolios_user_id ON portfolios(user_id);
```

#### positions 테이블 (보유 종목)
```sql
CREATE TABLE positions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    portfolio_id UUID NOT NULL REFERENCES portfolios(id),
    symbol VARCHAR(10) NOT NULL,
    quantity INTEGER NOT NULL CHECK (quantity >= 0),
    avg_price DECIMAL(15, 2) NOT NULL,
    current_price DECIMAL(15, 2),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(portfolio_id, symbol)
);

-- 인덱스
CREATE INDEX idx_positions_portfolio_id ON positions(portfolio_id);
CREATE INDEX idx_positions_symbol ON positions(symbol);
```

### 5.2 ERD (Entity Relationship Diagram)

```
┌─────────────┐       ┌─────────────┐
│   users     │       │   orders    │
├─────────────┤       ├─────────────┤
│ id (PK)     │───────│ user_id (FK)│
│ email       │   1:N │ symbol      │
│ ...         │       │ status      │
└─────────────┘       └─────────────┘
      │
      │ 1:1
      ▼
┌─────────────┐       ┌─────────────┐
│ portfolios  │       │ positions   │
├─────────────┤       ├─────────────┤
│ id (PK)     │───────│portfolio_id │
│ user_id (FK)│   1:N │ symbol      │
│ total_value │       │ quantity    │
└─────────────┘       └─────────────┘
```

### 5.3 마이그레이션 전략

```
Alembic 사용:

migrations/
├── versions/
│   ├── 001_create_users.py
│   ├── 002_create_orders.py
│   ├── 003_create_portfolios.py
│   └── 004_create_positions.py
└── env.py

명령어:
# 마이그레이션 생성
alembic revision --autogenerate -m "create users table"

# 마이그레이션 적용
alembic upgrade head

# 롤백
alembic downgrade -1
```

**참조**: ADR-003 PostgreSQL
```

### Part 4: 외부 연동 + 에러/보안 (1시간)

#### 섹션 6: 외부 연동

```markdown
## 6. 외부 연동

### 6.1 KIS API 연동

#### 인증 흐름
```
1. OAuth 토큰 발급
   POST https://openapi.koreainvestment.com:9443/oauth2/tokenP
   Body: { "grant_type": "client_credentials", "appkey": "...", "appsecret": "..." }

2. 토큰 저장
   - Redis에 캐시 (TTL: 23시간)
   - 만료 1시간 전 자동 갱신

3. API 호출
   Header: authorization: Bearer {access_token}
           appkey: {appkey}
           appsecret: {appsecret}
```

#### 주문 API
| 기능 | 엔드포인트 | Method |
|------|----------|--------|
| 주문 | /uapi/domestic-stock/v1/trading/order-cash | POST |
| 정정 | /uapi/domestic-stock/v1/trading/order-rvsecncl | POST |
| 취소 | /uapi/domestic-stock/v1/trading/order-rvsecncl | POST |
| 체결 조회 | /uapi/domestic-stock/v1/trading/inquire-daily-ccld | GET |

#### Rate Limiting
```
제한: 초당 20회

대응 전략:
├─ Rate Limiter: 15회/초 (5회 여유)
├─ 요청 큐잉: 초과 시 대기열
├─ 벌크 최적화: 가능한 배치 조회
└─ 참조: ADR-001 KIS API 제한
```

#### 에러 처리
| KIS 코드 | 의미 | 대응 |
|---------|------|------|
| EGW00001 | 토큰 만료 | 자동 갱신 후 재시도 |
| EGW00002 | 권한 없음 | KISAPIError 발생 |
| APBK0013 | 잔고 부족 | ValidationError 변환 |

**참조**: core/external/kis_client.py
```

#### 섹션 7: 에러 처리

```markdown
## 7. 에러 처리

### 7.1 에러 코드 체계

```
1xxx: 도메인 에러 (비즈니스 로직)
├─ 1001: 검증 오류
├─ 1002: 리소스 없음
├─ 1003: 상태 충돌
├─ 1004: 잔고 부족
└─ 1005: 주문 취소 불가

2xxx: 외부 API 에러
├─ 2001: KIS API 오류
├─ 2002: KIS Rate Limit
└─ 2003: KIS 인증 실패

9xxx: 시스템 에러
├─ 9001: 내부 서버 오류
├─ 9002: 데이터베이스 오류
└─ 9003: 캐시 오류
```

### 7.2 에러 응답 형식

```json
{
  "error": {
    "code": "1002",
    "message": "주문을 찾을 수 없습니다",
    "details": {
      "resource": "Order",
      "identifier": "550e8400-e29b-41d4-a716-446655440000"
    }
  }
}
```

### 7.3 재시도 전략

| 에러 유형 | 재시도 | 전략 |
|----------|-------|------|
| 네트워크 오류 | 예 | Exponential backoff (1s, 2s, 4s) |
| Rate Limit | 예 | 고정 대기 (1s) |
| 인증 오류 | 예 | 토큰 갱신 후 1회 |
| 비즈니스 오류 | 아니오 | 즉시 실패 반환 |

**참조**: core/errors/exceptions.py (Stage 5 구현)
```

#### 섹션 8: 보안

```markdown
## 8. 보안

### 8.1 인증 (Authentication)

#### JWT 구조
```json
// Access Token (1시간)
{
  "sub": "user-uuid",
  "email": "user@example.com",
  "exp": 1699999999,
  "iat": 1699996399,
  "type": "access"
}

// Refresh Token (7일)
{
  "sub": "user-uuid",
  "exp": 1700599999,
  "iat": 1699996399,
  "type": "refresh"
}
```

#### 토큰 저장
- Access Token: 클라이언트 메모리 (XSS 방지)
- Refresh Token: HttpOnly Cookie (CSRF 방지)

### 8.2 인가 (Authorization)

#### RBAC (Role-Based Access Control)
| Role | 권한 |
|------|-----|
| user | 본인 주문 CRUD, 본인 포트폴리오 조회 |
| admin | 모든 사용자 조회, 시스템 설정 |

#### 리소스 소유권 검증
```
주문 조회 시 소유권 검증 (의사코드):

order = repository.get(order_id)
IF order.user_id != current_user.id:
    THROW ForbiddenError("접근 권한이 없습니다")
```

### 8.3 데이터 보호

| 데이터 | 보호 방법 |
|-------|---------|
| 비밀번호 | bcrypt 해시 (cost=12) |
| API 키 | 환경 변수, 절대 로깅 금지 |
| 개인정보 | 로그 마스킹 (이메일 앞 3자만) |

**참조**: ADR-011 보안
```

#### 섹션 9: 다음 단계

```markdown
## 9. 다음 단계

### Stage 8 (Task Breakdown) 전달 사항

| 섹션 | Task 분해 대상 |
|------|--------------|
| 3. 도메인 모델 | User, Order, Portfolio 엔티티 구현 |
| 4. API 설계 | Orders, Portfolio, Auth API 구현 |
| 5. 데이터베이스 | 테이블 생성, 마이그레이션 |
| 6. 외부 연동 | KIS 클라이언트 구현 |

### 예상 Task 수

```
도메인 레이어:     5-8 Tasks
애플리케이션 레이어: 4-6 Tasks
인프라 레이어:     3-5 Tasks
API 레이어:       4-6 Tasks
────────────────────────────
총:              16-25 Tasks
```

### Stage 8 작업 방향

```
Blueprint 섹션 → Tasks:

섹션 3 (도메인 모델):
├─ Task: User 엔티티 + 테스트
├─ Task: Order 엔티티 + Aggregate 로직 + 테스트
├─ Task: Portfolio 엔티티 + Position + 테스트
└─ Task: 값 객체 + 열거형 + 테스트

섹션 4 (API):
├─ Task: Orders API 엔드포인트
├─ Task: Portfolio API 엔드포인트
├─ Task: Auth API 엔드포인트
└─ Task: 미들웨어 (인증, 로깅)
```
```



---

## 📄 Blueprint 템플릿

### 07B-01_project_blueprint.md

```markdown
# Project Blueprint

> **프로젝트**: [프로젝트명]
> **버전**: v1.0
> **작성일**: YYYY-MM-DD
> **패밀리**: [A-A-B / B-C-A / ...]

---

## 1. 시스템 개요

### 1.1 목적
[시스템이 해결하는 문제와 목표]

### 1.2 범위
- **포함**: [v1.0 범위]
- **제외**: [향후 버전 범위]

### 1.3 핵심 기능
| 기능 | 설명 | 우선순위 |
|------|------|---------|
| [기능1] | [설명] | P0 |
| [기능2] | [설명] | P1 |

### 1.4 참조
- 패밀리 분류: 01C-01_*.md
- NFR 우선순위: 02C-01_*.md

---

## 2. 아키텍처 구조

### 2.1 레이어 구조
[다이어그램]

### 2.2 의존성 방향
[의존성 규칙]

### 2.3 컴포넌트 구조
```
src/
├── core/           # DNA 시스템
├── domain/         # 도메인 레이어
├── application/    # 애플리케이션 레이어
├── infrastructure/ # 인프라 레이어
└── api/            # 프레젠테이션 레이어
```

### 2.4 참조
- 아키텍처 ADR: ADR-004

---

## 3. 도메인 모델

### 3.1 엔티티

#### [엔티티명]
| 필드 | 타입 | 설명 | 제약 |
|------|------|------|------|
| id | [타입] | PK | [제약] |

**도메인 규칙**:
- [규칙1]
- [규칙2]

### 3.2 값 객체
```
Value Object: [ValueObject]
├─ [필드1]: [타입]
└─ [필드2]: [타입]
```

### 3.3 집계 (Aggregates)
```
[AggregateRoot] (Root)
├─ [필드1]
├─ [필드2]
└─ 도메인 메서드
   ├─ [메서드1]()
   └─ [메서드2]()
```

### 3.4 도메인 이벤트
| 이벤트 | 발행 시점 | 페이로드 |
|-------|---------|---------|
| [이벤트명] | [시점] | [필드들] |

---

## 4. API 설계

### 4.1 엔드포인트 목록
| Method | Path | 설명 | 인증 |
|--------|------|------|-----|
| [METHOD] | [PATH] | [설명] | [Required/-] |

### 4.2 요청/응답 스키마

#### [엔드포인트명]
**Request**:
```
[RequestSchema]:
├─ [필드1]: [타입]
└─ [필드2]: [타입]
```

**Response**:
```
[ResponseSchema]:
├─ [필드1]: [타입]
└─ [필드2]: [타입]
```

### 4.3 참조
- API ADR: ADR-101

---

## 5. 데이터베이스 설계

### 5.1 테이블 스키마

#### [테이블명]
```sql
CREATE TABLE [table_name] (
    id UUID PRIMARY KEY,
    [field] [type] [constraints],
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 인덱스
CREATE INDEX idx_[name] ON [table]([column]);
```

### 5.2 ERD
[다이어그램]

### 5.3 참조
- 데이터베이스 ADR: ADR-003

---

## 6. 외부 연동

### 6.1 [외부 시스템명]

#### 인증 흐름
[인증 방법]

#### API 목록
| 기능 | 엔드포인트 | Method |
|------|----------|--------|
| [기능] | [URL] | [METHOD] |

#### Rate Limiting
[제한 및 대응 전략]

### 6.2 참조
- 외부 연동 ADR: ADR-001

---

## 7. 에러 처리

### 7.1 에러 코드 체계
```
1xxx: 도메인 에러
2xxx: 외부 API 에러
9xxx: 시스템 에러
```

### 7.2 에러 응답 형식
```json
{
  "error": {
    "code": "[코드]",
    "message": "[메시지]",
    "details": {}
  }
}
```

### 7.3 재시도 전략
| 에러 유형 | 재시도 | 전략 |
|----------|-------|------|
| [유형] | [예/아니오] | [전략] |

---

## 8. 보안

### 8.1 인증 (Authentication)
[JWT / OAuth / 등]

### 8.2 인가 (Authorization)
[RBAC / ABAC / 등]

### 8.3 데이터 보호
| 데이터 | 보호 방법 |
|-------|---------|
| [데이터] | [방법] |

### 8.4 참조
- 보안 ADR: ADR-011

---

## 9. 다음 단계

### Stage 8 전달 사항
- 도메인 모델 → 엔티티 구현 Tasks
- API 설계 → 엔드포인트 구현 Tasks
- 데이터베이스 → 마이그레이션 Tasks
```

---

## ✏️ 작성 예시: 주식 거래 플랫폼 (요약)

### 예시: 도메인 모델 섹션

```markdown
## 3. 도메인 모델

### 3.1 Order 엔티티 (Aggregate Root)

| 필드 | 타입 | 설명 | 제약 |
|------|------|------|------|
| id | OrderId (UUID) | PK | core.types.OrderId |
| user_id | UserId | FK → users | Not Null |
| symbol | str | 종목 코드 | 6자리 정규식 |
| side | OrderSide | 매수/매도 | Enum: buy, sell |
| order_type | OrderType | 주문 유형 | Enum: limit, market |
| quantity | int | 수량 | > 0 |
| price | Money | 가격 | >= 0, 시장가는 None |
| status | OrderStatus | 상태 | Enum |
| kis_order_id | str | KIS 주문번호 | Nullable |
| created_at | datetime | 생성 시간 | UTC |
| updated_at | datetime | 수정 시간 | UTC |

**도메인 규칙**:
1. 시장가 주문 시 price = None
2. status 전이 규칙:
   - pending → submitted (KIS 제출 시)
   - submitted → filled (체결 시)
   - submitted → cancelled (취소 시)
   - pending → cancelled (취소 시)
3. filled 또는 cancelled 상태에서 수정 불가
4. 취소는 pending/submitted 상태에서만 가능

**Aggregate 메서드** (의사코드):
```
Order:
  submit(external_order_id):
    PRE: status == PENDING
    POST: status = SUBMITTED, emit OrderSubmitted
    
  fill(filled_price, filled_at):
    PRE: status == SUBMITTED
    POST: status = FILLED, emit OrderFilled
    
  cancel(reason):
    PRE: status IN (PENDING, SUBMITTED)
    POST: status = CANCELLED, emit OrderCancelled
```

**참조**:
- ADR-101: 주문 도메인 설계
- core/types: UserId, OrderId, Money
- PROJECT_STANDARDS.md: 네이밍 규칙
- **언어별 구현**: docs/manuals/ 참조
```

### 예시: API 설계 섹션

```markdown
## 4. API 설계

### 4.2 POST /api/v1/orders - 주문 생성

**Request Schema**:
```
CreateOrderRequest:
├─ symbol: String (6자리 숫자, 종목 코드)
│   └─ pattern: "^[0-9]{6}$"
├─ side: OrderSide (BUY | SELL)
├─ order_type: OrderType (MARKET | LIMIT)
├─ quantity: Integer (> 0)
└─ price: Decimal? (>= 0, 시장가는 null)

검증 규칙:
├─ order_type == LIMIT → price 필수
└─ order_type == MARKET → price null 필수
```

**예시 요청**:
```json
{
    "symbol": "005930",
    "side": "buy",
    "order_type": "limit",
    "quantity": 10,
    "price": 70000
}
```

**Response Schema** (201 Created):
```
OrderResponse:
├─ id: UUID
├─ symbol: String
├─ side: OrderSide
├─ order_type: OrderType
├─ quantity: Integer
├─ price: Decimal?
├─ status: OrderStatus
├─ external_order_id: String?
├─ created_at: DateTime
└─ updated_at: DateTime

CreateOrderResponse:
├─ order: OrderResponse
└─ message: String
```

**예시 응답**:
```json
{
    "order": {
        "id": "550e8400-e29b-41d4-a716-446655440000",
        "symbol": "005930",
        "side": "buy",
        "order_type": "limit",
        "quantity": 10,
        "price": 70000,
        "status": "pending",
        "external_order_id": null,
        "created_at": "2025-12-03T10:30:00Z",
        "updated_at": "2025-12-03T10:30:00Z"
    },
    "message": "주문이 생성되었습니다"
}
```

**Error Responses**:
```json
// 400 Bad Request - 검증 오류
{
    "error": {
        "code": "1001",
        "message": "종목 코드 형식이 올바르지 않습니다",
        "details": {
            "field": "symbol",
            "value": "12345",
            "expected": "6자리 숫자"
        }
    }
}

// 422 Unprocessable Entity - 잔고 부족
{
    "error": {
        "code": "1004",
        "message": "잔고가 부족합니다",
        "details": {
            "required": 700000,
            "available": 500000
        }
    }
}

// 502 Bad Gateway - 외부 API 오류
{
    "error": {
        "code": "2001",
        "message": "외부 API 호출에 실패했습니다",
        "details": {
            "external_code": "EGW00001",
            "external_message": "토큰이 만료되었습니다"
        }
    }
}
```

**라우터 구현 가이드** (의사코드):
```
ENDPOINT POST /api/v1/orders
  INPUT: CreateOrderRequest, current_user (인증됨)
  OUTPUT: CreateOrderResponse (201 Created)
  
  STEPS:
    1. 로깅: "주문 생성 요청", user_id, symbol, side
    2. 서비스 호출: order_service.create_order(...)
    3. 로깅: "주문 생성 완료", order_id
    4. 응답 반환
    
  에러 처리:
    ├─ ValidationError → 400
    ├─ InsufficientBalanceError → 422
    └─ ExternalAPIError → 502
```

**언어별 구현 예시**: docs/manuals/ 참조
```

---

## ✅ Stage 7 완료 체크리스트

### 시스템 개요 (섹션 1)

- [ ] 목적 명확히 작성
- [ ] 범위 (포함/제외) 정의
- [ ] 핵심 기능 + 우선순위 (P0/P1/P2)
- [ ] 패밀리 분류 참조

### 아키텍처 구조 (섹션 2)

- [ ] 레이어 다이어그램
- [ ] 의존성 방향 규칙
- [ ] 컴포넌트 구조 (디렉토리)
- [ ] 아키텍처 ADR 참조

### 도메인 모델 (섹션 3)

- [ ] 모든 엔티티 정의 (필드, 타입, 제약)
- [ ] 도메인 규칙 명시
- [ ] 값 객체 정의
- [ ] Aggregate 경계 + 메서드
- [ ] 도메인 이벤트 목록

### API 설계 (섹션 4)

- [ ] 엔드포인트 목록 (Method, Path, 인증)
- [ ] 요청/응답 스키마 (타입 검증 포함)
- [ ] 에러 응답 형식
- [ ] 인증 흐름

### 데이터베이스 설계 (섹션 5)

- [ ] 테이블 스키마 (SQL)
- [ ] 인덱스 전략
- [ ] ERD
- [ ] 마이그레이션 전략

### 외부 연동 (섹션 6)

- [ ] 외부 시스템 인증 흐름
- [ ] API 목록
- [ ] Rate Limiting 대응
- [ ] 에러 처리 매핑

### 에러 처리 (섹션 7)

- [ ] 에러 코드 체계
- [ ] 에러 응답 형식
- [ ] 재시도 전략

### 보안 (섹션 8)

- [ ] 인증 방식 (JWT 구조)
- [ ] 인가 방식 (RBAC/ABAC)
- [ ] 데이터 보호 방법

### 산출물 생성

- [ ] `07B-01_project_blueprint.md` 작성
- [ ] Stage 8 전달 사항 정리

---

## 🔗 Stage 7 → Stage 8 연결

### Stage 8에 전달하는 것

| 전달 항목 | 내용 | 용도 |
|----------|------|------|
| Blueprint 섹션 3 | 도메인 모델 | 엔티티 구현 Tasks |
| Blueprint 섹션 4 | API 설계 | 엔드포인트 구현 Tasks |
| Blueprint 섹션 5 | 데이터베이스 | 마이그레이션 Tasks |
| Blueprint 섹션 6 | 외부 연동 | 클라이언트 구현 Tasks |

### Stage 8 미리보기

```
Stage 8: Task Breakdown

목표: Blueprint를 AI가 한 세션에 완료할 수 있는 크기로 분해

분해 기준:
├─ 체크리스트: 100-150줄 범위
├─ 예상 시간: 2-4시간
├─ 컨텍스트: 80-90K 토큰 이내
└─ 독립적 테스트 가능

예상 Task 수:
├─ 도메인 레이어: 5-8 Tasks
├─ 애플리케이션 레이어: 4-6 Tasks
├─ 인프라 레이어: 3-5 Tasks
└─ API 레이어: 4-6 Tasks
────────────────────────────────
총: 16-25 Tasks
```

---

## ⏪ 이전 Stage 검증 및 수정 프로토콜 (가장 Critical!)

### 왜 Stage 7이 가장 Critical한가?

```
Stage 7 = 통합의 정점 (Integration Apex)
────────────────────────────────────────────

Stage 1-6의 모든 결과물이 여기서 통합:
├─ Stage 1: 패밀리, NFR → Blueprint 전체 방향
├─ Stage 2: 제약, 충돌 → 기술 선택 반영
├─ Stage 3: ADR → 모든 결정 참조
├─ Stage 4: DNA 청사진 → 기반 시스템 참조
├─ Stage 5: DNA 구현 → core/ 모듈 참조
└─ Stage 6: 표준 → 규칙 준수 확인

⚠️ Stage 7에서 오류 미발견 시:
├─ Stage 8: 잘못된 Task 분해
├─ Stage 9: 잘못된 코드 구현
└─ 전체 재작업 필요 (10시간+)

✅ Stage 7에서 오류 수정 시:
├─ Blueprint만 수정 (2-3시간)
├─ Stage 8-9 정상 진행
└─ 비용 최소화
```

### 검증 시점
- Stage 7 시작 전 필수 체크 (모든 Stage!)
- 각 섹션 작성 완료 후 ADR과 교차 검증
- 전체 Blueprint 완료 후 최종 검증

### 검증 대상 (전체 Stage!)

| Stage | 산출물 | 검증 항목 |
|-------|--------|----------|
| Stage 1 | 01C-01_*.md | 패밀리 특성이 Blueprint에 반영? |
| Stage 1 | 01C-01_*.md | NFR 우선순위가 API/DB 설계에 반영? |
| Stage 2 | 02C-01_*.md | 기술 제약이 기술 선택에 반영? |
| Stage 2 | 02C-01_*.md | 충돌 해결이 트레이드오프로 반영? |
| Stage 3 | 03A-*_*.md | 모든 ADR이 Blueprint에 참조/반영? |
| Stage 4 | 04B-01_*.md | DNA 청사진이 core/ 참조로 반영? |
| Stage 5 | 05D-01_*.md | DNA 구현이 사용 예시로 반영? |
| Stage 6 | 06D-01_*.md | 표준 규칙이 코드 예시에 준수? |

### 오류 발견 시 프로토콜 (6단계)

```
Stage 7에서 Stage 1-6 오류 발견 시:

Step 1: 오류 발견 및 문서화
├─ 발견 위치: Blueprint 섹션 [N]
├─ 오류 내용: [구체적 설명]
├─ 영향 Stage: Stage [1-6]
├─ 심각도: [Critical/Major/Minor]
└─ 기록: 07B-01에 "발견된 이슈" 섹션 추가

Step 2: 영향 범위 파악 (가장 중요!)
├─ 직접 영향: Stage [N]
├─ 간접 영향: Stage [N+1] ~ Stage 6
├─ Blueprint 영향 섹션: [해당 섹션 번호]
├─ 재작업 예상 시간: [X]시간
└─ 기록: 영향 범위 문서화

Step 3: 해당 Stage로 이동 → 수정
├─ Stage [N] 산출물 수정
├─ 수정 이력 기록
├─ 버전 업데이트 (v1.0 → v1.1)
└─ 수정 완료 검증

Step 4: 중간 Stage 전파 (N+1 ~ 6)
├─ 각 Stage 산출물 영향 확인
├─ 필요 시 연쇄 수정
├─ 수정 이력 기록
└─ 일관성 검증

Step 5: Stage 7 재진행
├─ 수정된 입력으로 Blueprint 해당 섹션 재작성
├─ 전체 Blueprint 일관성 검토
└─ 9대 섹션 교차 검증

Step 6: 재진행 결과 검증
├─ 오류가 해결되었는지 확인
├─ 새로운 문제 발생 여부 확인
├─ 최종 승인
└─ Stage 8 전달 ✅
```

### 섹션별 흔한 오류 패턴

| 섹션 | 오류 유형 | 영향 Stage | 해결 |
|------|----------|-----------|------|
| 섹션 2 (아키텍처) | 레이어 정의 불일치 | Stage 4 | DNA 청사진 수정 |
| 섹션 3 (도메인) | 엔티티 필드 ADR 불일치 | Stage 3 | ADR 수정 또는 도메인 수정 |
| 섹션 4 (API) | NFR 성능 요구 미반영 | Stage 1 | NFR 현실화 또는 API 최적화 |
| 섹션 5 (DB) | 기술 제약 미반영 | Stage 2 | DB 기술 재선택 |
| 섹션 6 (외부 연동) | ADR 누락 (Rate Limit 등) | Stage 3 | ADR 추가 |
| 섹션 7 (에러) | 에러 코드 표준 불일치 | Stage 6 | 표준 수정 |
| 섹션 8 (보안) | 인증 ADR 미반영 | Stage 3 | ADR 확인 후 반영 |

### 추적성 (Critical!)

```
수정 이력 파일: docs/revision_log.md

예시:
────────────────────────────────────────────
## 2025-12-03 (Stage 7 Blueprint 작성 중)

### Issue #003: Order 취소 API 누락
- **발견 Stage**: Stage 7 Blueprint 섹션 4
- **영향 Stage**: Stage 3 ADR
- **오류**: Order 취소 기능 ADR 없음
- **수정**: ADR-017 "Order 취소 정책" 추가
- **영향 범위**: 
  - Stage 3: ADR-017 추가
  - Stage 7: 섹션 4에 DELETE /orders/{id} 추가
- **수정자**: Jason
- **검증**: AI 검증 완료
────────────────────────────────────────────

Blueprint 참조:
각 섹션에 관련 ADR 명시적 참조:
"참조: ADR-101 (Order 엔티티 설계)"
"참조: ADR-017 (Order 취소 정책)"
```

---

## 💡 핵심 원칙 요약

### Blueprint의 목적

```
ADR (Stage 3):
├─ "무엇을" 결정했는지
├─ "왜" 그렇게 결정했는지
└─ 개별 결정 단위

Blueprint (Stage 7):
├─ "어떻게" 구현할 것인지
├─ 모든 ADR을 통합한 전체 그림
├─ 구체적인 구현 명세
└─ 코드 작성 직전 단계

관계: 여러 ADR → 하나의 Blueprint
```

### 9대 섹션

```
1. 시스템 개요        ← 무엇을 만드는가?
2. 아키텍처 구조      ← 전체 구조는?
3. 도메인 모델        ← 핵심 객체는? (가장 중요!)
4. API 설계          ← 외부 인터페이스는?
5. 데이터베이스 설계   ← 데이터 저장은?
6. 외부 연동          ← 외부 시스템은?
7. 에러 처리          ← 실패 시 대응은?
8. 보안              ← 인증/인가는?
9. 다음 단계          ← Stage 8 연결
```

### SoT (Skeleton-of-Thought) 적용

```
Step 1: 목차 (뼈대) 생성
────────────────────────────────
9대 섹션 목차 먼저 작성

Step 2: 각 섹션 병렬 확장
────────────────────────────────
세션 1: 1-3 섹션 작성 (개요, 아키텍처, 도메인)
세션 2: 4-6 섹션 작성 (API, DB, 외부 연동)
세션 3: 7-9 섹션 작성 (에러, 보안, 다음 단계)

Step 3: 전체 일관성 검토
────────────────────────────────
├─ ADR 참조 확인
├─ PROJECT_STANDARDS 참조 확인
└─ 섹션 간 모순 확인
```

---

**Remember**: 
- ADR은 "결정", Blueprint는 "설계도"
- Blueprint 없이 구현 = 개발자마다 다른 해석
- 9대 섹션으로 모든 측면 커버
- Stage 8에서 실행 가능한 Task로 분해

*Blueprint는 모든 ADR을 통합하여 "코드 작성 직전 단계"의 완전한 설계도입니다.*


================================================================================

📄 FILE: 08G-00_task_breakdown_guide.md
--------------------------------------------------------------------------------

# Stage 8: 작업 분해 가이드 (Task Breakdown Guide)

> **목적**: Blueprint를 AI가 한 세션에 완료할 수 있는 크기로 분해
>
> **버전**: v4.1 (2025-12-03)
>
> - v4.0 (2025-12-03): Gemini 연구 기반 전면 재작성, 01_DNA_METHODOLOGY_DETAILED.md 기준
> - v2.0 (2025-11-12): 입력/출력 문서 추가
> - v1.0 (2025-11-10): 초기 버전

---

## 📚 이 가이드의 위치

```
DNA 방법론 문서 체계:

Tier 1: 00_CORE_METHODOLOGY.md (전체 맥락)
           ↓
Tier 2: 01_DNA_METHODOLOGY_DETAILED.md (상세 원리)
           ↓
Tier 3: 이 문서 (Stage 8 실행 가이드) ← 지금 여기!
```

**참조 문서**:
- **원리 이해**: `01_DNA_METHODOLOGY_DETAILED.md` Part 6.2

---

## 🎯 DNA 핵심 원칙 1: AI 최적 크기

### Stage 8이 DNA 방법론의 변환점인 이유

```
Stage 1-7: 인간 중심 (Human-Driven)
────────────────────────────────────
├─ 패밀리 분류, NFR, ADR, Blueprint
├─ 문서 크기 제한 없음
├─ 인간의 이해와 의사결정 중심
└─ 컨텍스트 = 인간의 기억력

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Stage 8: 변환점 (Transformation Point) ← 여기!
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Stage 8-9: AI 중심 (AI-Driven)
────────────────────────────────────
├─ Task Breakdown, 9-Step Checklist
├─ AI 컨텍스트 한계 고려 필수!
├─ AI가 100% 성공할 수 있는 크기
└─ 컨텍스트 = 모델별 안전 범위
```

### 80-90K 토큰 = 100-150줄 체크리스트

```
왜 이 크기인가?

AI 컨텍스트 윈도우 (예: 200K 토큰)
├─ 시스템 프롬프트: ~30K 토큰
├─ 대화 히스토리: ~20K 토큰
├─ 참조 문서 (Blueprint, Standards): ~50K 토큰
├─ 체크리스트 + 코드: ~20K 토큰
└─ 응답 생성 여유: ~80K 토큰 ← 실제 작업 공간!

체크리스트 → 토큰 변환:
├─ 1줄 ≈ 10-15 토큰 (평균)
├─ 100줄 ≈ 1,000-1,500 토큰
├─ 150줄 ≈ 1,500-2,250 토큰
└─ 코드 예시 포함 시 x2-3배

결론:
├─ 체크리스트: 100-150줄 (1,500-2,000 토큰)
├─ 참조 코드: 200-300줄 (3,000-4,500 토큰)
├─ 생성할 코드: 100-200줄 (1,500-3,000 토큰)
└─ 총: ~10K 토큰 = 여유 있게 처리 가능 ✅
```

### 크기 판단 공식

```
FUNCTION is_optimal_task_size(task):
    """Task 크기가 AI 최적인지 판단"""
    
    # 1. 체크리스트 줄 수
    checklist_lines = estimate_checklist_lines(task)
    IF NOT (80 <= checklist_lines <= 180):
        RETURN False  # 80줄 미만 = 너무 작음, 180줄 초과 = 너무 큼
    
    # 2. 참조 문서 크기
    reference_tokens = estimate_reference_tokens(task)
    IF reference_tokens > 50,000:
        RETURN False  # 참조 문서가 너무 많음
    
    # 3. 예상 생성 코드
    code_lines = estimate_code_lines(task)
    IF code_lines > 300:
        RETURN False  # 생성할 코드가 너무 많음
    
    # 4. 테스트 포함 여부
    IF NOT task.includes_tests:
        RETURN False  # 테스트 없는 Task는 불완전
    
    RETURN True

# 적용 예시
is_optimal_task_size(Task("User 엔티티 + 테스트"))  # True (120줄)
is_optimal_task_size(Task("전체 도메인 구현"))      # False (500줄+)
is_optimal_task_size(Task("Enum 하나 추가"))       # False (30줄)
```

### 크기가 맞지 않을 때

| 상황 | 증상 | 해결책 |
|------|------|--------|
| **너무 큼** | 180줄 초과, 4시간+ | 분할 (기능별, 레이어별) |
| **너무 작음** | 80줄 미만, 1시간- | 합치기 (관련 기능끼리) |
| **참조 과다** | Blueprint 전체 필요 | 필요 섹션만 발췌 |
| **의존성 복잡** | 3개+ Task 선행 필요 | 의존성 재설계 |

---

## 🤔 왜 Task Breakdown이 필요한가?

### Blueprint vs Task

```
Blueprint (Stage 7):
├─ 전체 시스템 설계도 (1,000+ 줄)
├─ 모든 도메인, API, DB 설계
├─ AI가 한 번에 처리 불가능!
└─ 컨텍스트 한계 (200K 토큰)

Task (Stage 8):
├─ 하나의 집중된 작업 (2-4시간)
├─ 체크리스트: 100-150줄
├─ AI가 완벽하게 처리 가능!
└─ 독립적 테스트 가능
```

### Task 없이 구현하면?

```
❌ Blueprint 전체를 한 번에:

AI: "Blueprint 보고 전체 구현할게요!"

Session 1:
├─ Order 엔티티 구현 시작
├─ ...중간에 User 필요해서 User도 구현
├─ ...DB 연결도 필요해서 추가
├─ 컨텍스트 80% 소진 😰
└─ "나머지는 다음에..."

Session 2:
├─ "이전 세션에서 뭘 했더라?" 🤔
├─ 중복 코드 작성
├─ 스타일 불일치
└─ 테스트 누락

결과:
├─ 일관성 없는 코드
├─ 테스트 커버리지 50% 미만
├─ "처음부터 다시 해야 하나..." 😱
```

```
✅ Task 단위로 분해 후 구현:

08T-01_task_breakdown.md:
────────────────────────────────
Task 001: User 엔티티 + 테스트 (2h)
Task 002: Order 엔티티 + Aggregate (3h)
Task 003: 값 객체 + 열거형 (1.5h)
...

Session 1: Task 001
├─ 목표: User 엔티티만 집중
├─ 입력: Blueprint Section 3.1
├─ 출력: src/domain/user + tests/
├─ 완료! ✅ (타입 체커 0, 린터 0, Coverage 95%)

Session 2: Task 002
├─ 목표: Order 엔티티만 집중
├─ 입력: Blueprint Section 3.1, Task 001 완료
├─ 출력: src/domain/order.py + tests/
├─ 완료! ✅

결과:
├─ 각 Task 100% 완료
├─ 일관된 품질
├─ 전체 커버리지 95%+
└─ "레고 블럭처럼 조립 완료!" 🎉
```

### 비유: 이사 짐 싸기

```
❌ 한 번에 이사:
"모든 짐을 한 박스에!"
→ 박스 터짐, 물건 파손, 찾기 어려움

✅ 체계적 포장:
박스 1: 주방용품 (그릇, 컵)
박스 2: 서재 (책, 문구)
박스 3: 침실 (침구, 옷)
→ 분류 명확, 찾기 쉬움, 안전

Task = 라벨 붙은 이사 박스!
├─ 내용물 명확 (목표)
├─ 크기 적절 (2-4시간)
├─ 독립적 운반 (의존성 최소)
└─ 쉽게 확인 (테스트)
```

---

## 📥 입력 문서

### Stage 7에서 전달받는 것

| 파일 | 핵심 내용 | 이 Stage에서 사용 |
|------|----------|-----------------|
| `07B-01_project_blueprint.md` | 전체 설계도 (9개 섹션) | Task 분해 대상 |
| `06D-01_project_standards.md` | 프로젝트 표준 | Task별 표준 적용 |

---

## 📤 출력 문서

### 필수 산출물

```
docs/
└── 08T-01_task_breakdown.md    # THE 산출물 (작업 분해 목록)
```

---

## 🎯 좋은 Task의 4가지 조건

### 조건 1: 적절한 크기

```
체크리스트 기준:
├─ 100-150줄 범위 (120줄 내외 권장)
├─ 예상 시간: 2-4시간
├─ 컨텍스트: 80-90K 토큰 이내
└─ 💡 숫자는 참고! 작업을 완전하게 설명하는 게 우선

크기 판단 기준:
┌─────────────────┬─────────────┬─────────────┐
│ 구분            │ 너무 작음   │ 적절        │ 너무 큼     │
├─────────────────┼─────────────┼─────────────┼─────────────┤
│ 체크리스트      │ 50줄 미만   │ 100-150줄   │ 200줄 초과  │
│ 예상 시간       │ 1시간 미만  │ 2-4시간     │ 5시간 초과  │
│ 파일 수         │ 1개 미만    │ 1-3개       │ 5개 초과    │
│ 테스트 수       │ 2개 미만    │ 5-15개      │ 20개 초과   │
└─────────────────┴─────────────┴─────────────┴─────────────┘
```

### 조건 2: 독립성

```
좋은 Task:
├─ 다른 Task 없이 테스트 가능
├─ 명확한 입력/출력
├─ 자체 완결적
└─ 롤백 가능 (실패해도 다른 Task 영향 없음)

나쁜 Task:
├─ "Order 만들려면 User 먼저 해야 하고..."
├─ "이건 다음 Task에서 마무리할게요"
├─ "테스트는 통합 테스트로 한 번에..."
└─ 얽힌 의존성 = 실패의 도미노
```

### 조건 3: 검증 가능

```
좋은 Task:
├─ 테스트 작성 가능
├─ 성공/실패 판단 명확
├─ 품질 기준 적용 가능
│   ├─ 타입 체커 0 errors
│   ├─ 린터 0 violations
│   └─ Coverage 95%+
└─ "이 Task 완료 = 이 기능 작동"

나쁜 Task:
├─ "일단 코드 짜고 나중에 테스트"
├─ "완료 조건: 대충 돌아가면 됨"
├─ 품질 검증 불가
└─ "되는 것 같은데...?" 🤔
```

### 조건 4: 가치 있음

```
좋은 Task:
├─ 완료 시 실제 기능 동작
├─ 데모 가능
├─ 진행 상황 확인 가능
└─ "Task 5개 완료 = 25% 진행"

나쁜 Task:
├─ "설정 파일만 만들기" (가치 없음)
├─ "나중에 쓸 유틸리티 함수" (당장 불필요)
├─ 완료해도 아무것도 작동 안 함
└─ "Task 5개 했는데 뭐가 된 거지?"
```

---

## 🔄 DNA 핵심 원칙 2: 완전해질 때까지 반복

### "부족함이 없어질 때까지"의 의미

```
Task Breakdown의 목표:
├─ AI가 체크리스트만 보고 100% 완료 가능
├─ 추가 질문 없이 독립 실행 가능
├─ 모호함, 누락, 불완전함 = 0
└─ "완전한" Task만 Stage 9로 전달

완전하지 않은 Task의 증상:
❌ "Blueprint 참조"만 있고 구체적 내용 없음
❌ "적절히 구현"같은 모호한 표현
❌ 입력/출력 중 하나라도 누락
❌ 완료 조건이 주관적
❌ 테스트 케이스 미정의
```

### 3단계 검증 프로토콜

```
모든 Task는 3단계 검증을 통과해야 함:

┌─────────────────────────────────────────────────────────┐
│ 검증 1: 크기 (Size Check)                               │
├─────────────────────────────────────────────────────────┤
│ □ 체크리스트 예상 줄 수: 80-180줄?                        │
│ □ 예상 시간: 2-4시간?                                    │
│ □ 생성 파일 수: 1-4개?                                   │
│ □ 테스트 케이스 수: 3-15개?                              │
│                                                         │
│ 실패 시 → 분할 또는 합치기                                │
└─────────────────────────────────────────────────────────┘
            ↓ 통과
┌─────────────────────────────────────────────────────────┐
│ 검증 2: 의존성 (Dependency Check)                       │
├─────────────────────────────────────────────────────────┤
│ □ 선행 Task 명확히 정의?                                 │
│ □ 순환 의존성 없음?                                      │
│ □ 병렬 실행 가능 Task 식별?                              │
│ □ 핵심 경로 계산 가능?                                   │
│                                                         │
│ 실패 시 → 의존성 재설계                                   │
└─────────────────────────────────────────────────────────┘
            ↓ 통과
┌─────────────────────────────────────────────────────────┐
│ 검증 3: 완전성 (Completeness Check)                     │
├─────────────────────────────────────────────────────────┤
│ □ 목표: 한 문장으로 명확?                                 │
│ □ 입력: 모든 참조 문서/코드 명시?                         │
│ □ 출력: 생성될 파일 경로 명시?                            │
│ □ 제약: MUST/MUST NOT 명시?                             │
│ □ 완료 조건: 측정 가능? (타입 체커 0, 린터 0, Coverage 95%) │
│ □ 테스트: 구체적 케이스 3개 이상?                         │
│                                                         │
│ 실패 시 → Task 상세 보완 후 재검증                        │
└─────────────────────────────────────────────────────────┘
            ↓ 통과
        Stage 9로 전달 ✅
```

### 재작업 사례: "주문 도메인" Task

```
1차 시도 (불완전):
────────────────────────────────────
Task: 주문 도메인 구현
목표: Order 관련 기능 구현
입력: Blueprint
출력: 주문 관련 파일들

검증 1 실패: 크기 불명확 (몇 줄? 몇 시간?)
검증 3 실패: 목표 모호, 출력 불명확

2차 시도 (분할 후에도 불완전):
────────────────────────────────────
Task 002: Order 엔티티 구현
목표: Order 클래스 작성
입력: Blueprint Section 3.1
출력: src/domain/order.py

검증 3 실패: 테스트 누락, 완료 조건 주관적

3차 시도 (완전!):
────────────────────────────────────
Task 002: Order 엔티티 + Aggregate + 테스트
목표: Order Aggregate Root 구현 (엔티티 + 상태 전이 + 도메인 이벤트)
입력: 
  - Blueprint Section 3.1 (Order 필드)
  - Blueprint Section 3.3 (Aggregate 규칙)
  - core/types (OrderId, Money, OrderStatus)
출력:
  - src/domain/entities/order.py
  - tests/unit/domain/test_order.py
제약:
  - MUST: 상태 전이 로직 (pending → submitted → filled)
  - MUST: 도메인 이벤트 발행
  - MUST NOT: DB 접근 코드
완료 조건:
  - 타입 체커 0 errors
  - 린터 0 violations  
  - Coverage 95%+
  - 상태 전이 테스트 4개 포함
테스트 케이스:
  - test_order_creation
  - test_order_submit_success
  - test_order_submit_invalid_state
  - test_order_fill_success
  - test_order_cancel_success
  - test_order_cancel_already_filled

검증 1 통과: 120줄, 3시간, 2파일, 6테스트 ✅
검증 2 통과: 의존성 없음 ✅
검증 3 통과: 모든 항목 명시 ✅

→ Stage 9로 전달!
```

---

## 📋 작성 단계 (Part 1-4)

### Part 1: Blueprint 섹션별 Task 도출 (1시간)

#### Step 1: Blueprint 9개 섹션 → Task 후보

```
Blueprint 섹션 → Task 후보:

섹션 3 (도메인 모델):
├─ Task: User 엔티티 + 테스트
├─ Task: Order 엔티티 + Aggregate + 테스트
├─ Task: Portfolio + Position 엔티티 + 테스트
└─ Task: 값 객체 + 열거형 + 테스트

섹션 4 (API):
├─ Task: Orders API 엔드포인트 (CRUD)
├─ Task: Portfolio API 엔드포인트
├─ Task: Auth API 엔드포인트
└─ Task: 미들웨어 (인증, 로깅, 에러 처리)

섹션 5 (데이터베이스):
├─ Task: 마이그레이션 (users, orders 테이블)
├─ Task: 마이그레이션 (portfolios, positions 테이블)
└─ Task: 리포지토리 구현

섹션 6 (외부 연동):
├─ Task: KIS API 클라이언트 (인증)
├─ Task: KIS API 클라이언트 (주문)
└─ Task: Rate Limiter + 재시도 로직
```

#### Step 2: Task 크기 검증

```
# 각 Task 크기 검증

FUNCTION validate_task_size(task):
    """Task 크기가 적절한지 검증"""
    
    # 체크리스트 예상 줄 수
    checklist_lines = estimate_checklist_lines(task)
    IF checklist_lines < 80:
        RETURN "너무 작음 - 다른 Task와 합치기"
    IF checklist_lines > 180:
        RETURN "너무 큼 - 분할 필요"
    
    # 예상 시간
    estimated_hours = estimate_hours(task)
    IF estimated_hours < 1.5:
        RETURN "너무 작음"
    IF estimated_hours > 5:
        RETURN "너무 큼"
    
    RETURN "적절함 ✅"

# 예시
validate_task_size("User 엔티티 + 테스트")  # → "적절함 ✅" (2시간)
validate_task_size("전체 API 구현")          # → "너무 큼" (20시간)
validate_task_size("Enum 하나 추가")         # → "너무 작음" (20분)
```

### Part 2: RDoLT 적용 - 난이도별 분류 (30분)

#### RDoLT: Recursive Decomposition of Logical Thoughts

```
난이도 3단계:

Level 1 - Easy (기본 기능):
────────────────────────────────
├─ 단순 CRUD
├─ 기본 모델 정의
├─ 단순 API 엔드포인트
├─ 명확한 로직
└─ 의존성 없음 또는 최소

예: Task 001 (User 엔티티), Task 003 (값 객체)

Level 2 - Intermediate (상호작용):
────────────────────────────────
├─ 엔티티 간 관계
├─ 트랜잭션 로직
├─ 서비스 계층 통합
├─ 검증 로직
└─ Easy Task에 의존

예: Task 005 (주문 생성 서비스), Task 007 (API 엔드포인트)

Level 3 - Final (엣지 케이스):
────────────────────────────────
├─ 에러 처리 고도화
├─ 동시성 제어
├─ 성능 최적화
├─ 보안 검증
├─ 예외 상황 처리
└─ Intermediate Task에 의존

예: Task 015 (주문 동시성 처리), Task 016 (KIS API 연동)

작업 순서:
Easy → Intermediate → Final
(기반 먼저, 복잡한 것 나중)
```

#### 분류 예시

```
주식 거래 플랫폼 Task 분류:

Phase 1: Easy (기반)
────────────────────────────────
001. User 엔티티 + 테스트         [2h] [의존성: 없음]
002. Order 엔티티 + Aggregate     [3h] [의존성: 없음]
003. Portfolio 엔티티 + Position  [2.5h] [의존성: 없음]
004. 값 객체 + 열거형             [1.5h] [의존성: 없음]
005. 마이그레이션 (users, orders) [2h] [의존성: 001, 002]

Phase 2: Intermediate (상호작용)
────────────────────────────────
006. User 리포지토리              [2h] [의존성: 001, 005]
007. Order 리포지토리             [2.5h] [의존성: 002, 005]
008. 주문 생성 서비스             [4h] [의존성: 007, 004]
009. 주문 조회 서비스             [2h] [의존성: 007]
010. Auth API (로그인, 토큰)      [3h] [의존성: 006]
011. Orders API (CRUD)           [3.5h] [의존성: 008, 009]

Phase 3: Final (엣지 케이스)
────────────────────────────────
012. 인증 미들웨어 + 권한 검증     [3h] [의존성: 010]
013. KIS API 클라이언트 (인증)    [3h] [의존성: 없음]
014. KIS API 클라이언트 (주문)    [4h] [의존성: 013, 008]
015. 주문 동시성 처리             [4h] [의존성: 008, 014]
016. Rate Limiter + 재시도       [3h] [의존성: 013]
017. 전체 통합 테스트             [3h] [의존성: 모든 Task]
```

### Part 3: 의존성 다이어그램 작성 (30분)

#### 의존성 시각화

```
의존성 다이어그램:

Phase 1 (Easy):
┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐
│ 001 │  │ 002 │  │ 003 │  │ 004 │
│User │  │Order│  │Port.│  │Value│
└──┬──┘  └──┬──┘  └──┬──┘  └──┬──┘
   │        │        │        │
   └────────┼────────┼────────┘
            │        │
            ▼        │
         ┌─────┐     │
         │ 005 │     │
         │Migr.│     │
         └──┬──┘     │
            │        │
Phase 2:    ▼        ▼
         ┌─────┐  ┌─────┐
         │ 006 │  │ 007 │
         │U.Rep│  │O.Rep│
         └──┬──┘  └──┬──┘
            │        │
            ▼        ▼
         ┌─────┐  ┌─────┐
         │ 010 │  │ 008 │──→ ┌─────┐
         │Auth │  │O.Svc│    │ 009 │
         └──┬──┘  └──┬──┘    │O.Qry│
            │        │       └─────┘
Phase 3:    ▼        ▼
         ┌─────┐  ┌─────┐  ┌─────┐
         │ 012 │  │ 014 │  │ 015 │
         │Auth │  │KIS  │  │Conc.│
         │Midw.│  │Order│  └─────┘
         └─────┘  └──┬──┘
                     │
                  ┌──┴──┐
                  │ 013 │
                  │KIS  │
                  │Auth │
                  └─────┘
```

#### 핵심 경로 (Critical Path)

```
핵심 경로: 전체 일정을 결정하는 최장 경로

001 (User, 2h)
  ↓
005 (Migration, 2h)
  ↓
006 (User Repo, 2h)
  ↓
010 (Auth API, 3h)
  ↓
012 (Auth Middleware, 3h)
────────────────────────
총: 12시간 (최소 4일)

병렬 실행 가능:
├─ 002, 003, 004는 001과 동시에
├─ 007, 008, 009는 005 이후 006과 병렬
└─ 013, 016은 독립적으로 언제든지
```

### Part 4: Task 상세 정의 (1시간)

#### 각 Task 상세 작성

```markdown
## Task 001: User 엔티티 + 테스트

### 메타 정보
- **ID**: 001
- **난이도**: Easy (Level 1)
- **예상 시간**: 2시간
- **의존성**: 없음

### 목표
User 엔티티 클래스 구현 및 단위 테스트 작성

### 입력
- Blueprint Section 3.1 (User 엔티티)
- PROJECT_STANDARDS.md (네이밍 규칙)
- core/types (UserId, EmailStr)

### 출력
- `src/domain/entities/user.py`
- `tests/unit/domain/test_user.py`
- 커버리지 95%+

### 제약
- MUST: 검증 라이브러리 사용 (타입 안전 모델)
- MUST: UserId (UUID) 타입 사용
- MUST: created_at, updated_at UTC 시간
- MUST NOT: ORM 직접 사용 (Infrastructure 레이어)

### 완료 조건
- [ ] 타입 체커 0 errors
- [ ] 린터 0 violations
- [ ] 테스트 프레임워크 통과
- [ ] Coverage 95%+

---

## Task 002: Order 엔티티 + Aggregate + 테스트

### 메타 정보
- **ID**: 002
- **난이도**: Easy (Level 1)
- **예상 시간**: 3시간
- **의존성**: 없음 (Task 001과 병렬 가능)

### 목표
Order Aggregate Root 구현 (엔티티 + 도메인 로직 + 테스트)

### 입력
- Blueprint Section 3.1 (Order 엔티티)
- Blueprint Section 3.3 (Aggregate)
- core/types (OrderId, Money, OrderStatus)

### 출력
- `src/domain/entities/order.py`
- `tests/unit/domain/test_order.py`
- 커버리지 95%+

### 제약
- MUST: Aggregate Root 패턴 적용
- MUST: 상태 전이 로직 (pending → submitted → filled)
- MUST: 도메인 이벤트 발행 (OrderCreated, OrderSubmitted)
- MUST NOT: 데이터베이스 접근 코드

### 완료 조건
- [ ] 타입 체커 0 errors
- [ ] 린터 0 violations
- [ ] 테스트 프레임워크 통과
- [ ] 상태 전이 테스트 포함
- [ ] Coverage 95%+
```



---

## 📄 Task Breakdown 템플릿

### 08T-01_task_breakdown.md

```markdown
# Task Breakdown

> **프로젝트**: [프로젝트명]
> **버전**: v1.0
> **작성일**: YYYY-MM-DD
> **Blueprint 참조**: 07B-01_project_blueprint.md

---

## 개요

| 항목 | 값 |
|------|---|
| 총 Task 수 | [N]개 |
| 예상 총 시간 | [X]시간 |
| 예상 세션 수 | [Y]세션 (Task당 1세션) |
| 핵심 경로 | Task 001 → 005 → 008 → 014 |

---

## Phase 1: Easy (기반)

> 의존성 없음, 병렬 실행 가능

| ID | Task | 예상 | 의존성 | Blueprint 참조 |
|----|------|------|--------|---------------|
| 001 | [Task명] | [X]h | 없음 | Section 3.1 |
| 002 | [Task명] | [X]h | 없음 | Section 3.1 |
| ... | ... | ... | ... | ... |

---

## Phase 2: Intermediate (상호작용)

> Phase 1 완료 후 진행

| ID | Task | 예상 | 의존성 | Blueprint 참조 |
|----|------|------|--------|---------------|
| 006 | [Task명] | [X]h | 001, 005 | Section 4.2 |
| 007 | [Task명] | [X]h | 002, 005 | Section 4.2 |
| ... | ... | ... | ... | ... |

---

## Phase 3: Final (엣지 케이스)

> Phase 2 완료 후 진행

| ID | Task | 예상 | 의존성 | Blueprint 참조 |
|----|------|------|--------|---------------|
| 012 | [Task명] | [X]h | 010 | Section 8.1 |
| 015 | [Task명] | [X]h | 008, 014 | Section 6.1 |
| ... | ... | ... | ... | ... |

---

## 의존성 다이어그램

```
Phase 1:
┌─────┐  ┌─────┐  ┌─────┐
│ 001 │  │ 002 │  │ 003 │
└──┬──┘  └──┬──┘  └──┬──┘
   │        │        │
   └────────┼────────┘
            ▼
         ┌─────┐
         │ 005 │
         └──┬──┘
            │
Phase 2:    ▼
         ┌─────┐
         │ 008 │
         └──┬──┘
            │
Phase 3:    ▼
         ┌─────┐
         │ 014 │
         └─────┘
```

---

## Task 상세

### Task 001: [Task명]

#### 메타 정보
- **ID**: 001
- **난이도**: Easy
- **예상 시간**: [X]시간
- **의존성**: 없음

#### 목표
[한 문장으로 명확하게]

#### 입력
- Blueprint Section [X.X]
- PROJECT_STANDARDS.md
- [추가 참조]

#### 출력
- `[파일 경로]`
- `[테스트 파일 경로]`
- 커버리지 95%+

#### 제약
- MUST: [필수 사항]
- MUST NOT: [금지 사항]

#### 완료 조건
- [ ] 타입 체커 0 errors
- [ ] 린터 0 violations
- [ ] 테스트 프레임워크 통과
- [ ] Coverage 95%+

---

### Task 002: [Task명]

[같은 형식으로 반복...]

---

## 우선순위 및 일정

### 핵심 경로 (Critical Path)

```
001 → 005 → 008 → 014 → 017
 2h    2h    4h    4h    3h = 15시간 (최소 4일)
```

### 병렬 실행 가능

```
Day 1: 001, 002, 003, 004 (병렬)
Day 2: 005, 013 (병렬)
Day 3: 006, 007 (병렬)
Day 4: 008, 009, 010 (병렬)
Day 5: 011, 012, 016 (병렬)
Day 6: 014, 015 (병렬)
Day 7: 017 (통합)
```

---

## 다음 단계

→ Stage 9: 각 Task마다 9-Step Checklist 작성
→ 체크리스트 파일: `09L-001_*.md`, `09L-002_*.md`, ...
```

---

## ✏️ 작성 예시: 주식 거래 플랫폼

### 예시 1: 전체 Task Breakdown

```markdown
# Task Breakdown - 주식 거래 플랫폼

> **프로젝트**: Stock Trading Platform
> **버전**: v1.0
> **작성일**: 2025-12-03
> **Blueprint 참조**: 07B-01_project_blueprint.md

---

## 개요

| 항목 | 값 |
|------|---|
| 총 Task 수 | 17개 |
| 예상 총 시간 | 48시간 |
| 예상 세션 수 | 17세션 |
| 핵심 경로 | 001 → 005 → 006 → 010 → 012 (12h) |

---

## Phase 1: Easy (기반)

> 의존성 없음, 병렬 실행 가능

| ID | Task | 예상 | 의존성 | Blueprint 참조 |
|----|------|------|--------|---------------|
| 001 | User 엔티티 + 테스트 | 2h | 없음 | Section 3.1 |
| 002 | Order 엔티티 + Aggregate | 3h | 없음 | Section 3.1, 3.3 |
| 003 | Portfolio + Position 엔티티 | 2.5h | 없음 | Section 3.1 |
| 004 | 값 객체 + 열거형 | 1.5h | 없음 | Section 3.2 |
| 005 | 마이그레이션 (users, orders) | 2h | 001, 002 | Section 5.1 |

**Phase 1 소계**: 11시간

---

## Phase 2: Intermediate (상호작용)

> Phase 1 완료 후 진행

| ID | Task | 예상 | 의존성 | Blueprint 참조 |
|----|------|------|--------|---------------|
| 006 | User 리포지토리 | 2h | 001, 005 | Section 5.1 |
| 007 | Order 리포지토리 | 2.5h | 002, 005 | Section 5.1 |
| 008 | 주문 생성 서비스 | 4h | 004, 007 | Section 4.2 |
| 009 | 주문 조회 서비스 | 2h | 007 | Section 4.2 |
| 010 | Auth API (로그인, 토큰) | 3h | 006 | Section 4.1, 8.1 |
| 011 | Orders API (CRUD) | 3.5h | 008, 009 | Section 4.1 |

**Phase 2 소계**: 17시간

---

## Phase 3: Final (엣지 케이스)

> Phase 2 완료 후 진행

| ID | Task | 예상 | 의존성 | Blueprint 참조 |
|----|------|------|--------|---------------|
| 012 | 인증 미들웨어 + 권한 검증 | 3h | 010 | Section 8.2 |
| 013 | KIS API 클라이언트 (인증) | 3h | 없음 | Section 6.1 |
| 014 | KIS API 클라이언트 (주문) | 4h | 008, 013 | Section 6.1 |
| 015 | 주문 동시성 처리 | 4h | 008, 014 | Section 6.1 |
| 016 | Rate Limiter + 재시도 | 3h | 013 | Section 6.1 |
| 017 | 전체 통합 테스트 | 3h | 모든 Task | - |

**Phase 3 소계**: 20시간

---

## 의존성 다이어그램

```
Phase 1 (Easy):
┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐
│ 001 │  │ 002 │  │ 003 │  │ 004 │
│User │  │Order│  │Port.│  │Value│
│ 2h  │  │ 3h  │  │2.5h │  │1.5h │
└──┬──┘  └──┬──┘  └──┬──┘  └──┬──┘
   │        │        │        │
   └────┬───┴────────┘        │
        │                     │
        ▼                     │
     ┌─────┐                  │
     │ 005 │                  │
     │Migr.│                  │
     │ 2h  │                  │
     └──┬──┘                  │
        │                     │
        ├──────────────┬──────┘
        │              │
Phase 2 ▼              ▼
     ┌─────┐        ┌─────┐
     │ 006 │        │ 007 │
     │U.Rep│        │O.Rep│
     │ 2h  │        │2.5h │
     └──┬──┘        └──┬──┘
        │              │
        ▼              ▼
     ┌─────┐        ┌─────┐───→ ┌─────┐
     │ 010 │        │ 008 │     │ 009 │
     │Auth │        │O.Svc│     │O.Qry│
     │ 3h  │        │ 4h  │     │ 2h  │
     └──┬──┘        └──┬──┘     └──┬──┘
        │              │           │
        │              └─────┬─────┘
Phase 3 ▼                    ▼
     ┌─────┐              ┌─────┐
     │ 012 │              │ 011 │
     │Auth │              │Order│
     │Midw.│              │ API │
     │ 3h  │              │3.5h │
     └─────┘              └─────┘

                ┌─────┐
                │ 013 │ ← 독립 (Phase 3 시작 가능)
                │KIS  │
                │Auth │
                │ 3h  │
                └──┬──┘
                   │
        ┌──────────┼──────────┐
        │          │          │
        ▼          ▼          ▼
     ┌─────┐    ┌─────┐    ┌─────┐
     │ 014 │    │ 015 │    │ 016 │
     │KIS  │    │Conc.│    │Rate │
     │Order│    │ 4h  │    │Limit│
     │ 4h  │    └─────┘    │ 3h  │
     └─────┘               └─────┘
                   │
                   ▼
                ┌─────┐
                │ 017 │
                │Integ│
                │Test │
                │ 3h  │
                └─────┘
```

---

## 우선순위 및 일정

### 핵심 경로 (Critical Path)

```
001 (2h) → 005 (2h) → 006 (2h) → 010 (3h) → 012 (3h)
─────────────────────────────────────────────────────
총: 12시간 = 최소 3일 (하루 4시간 기준)
```

### 병렬 실행 계획

```
Day 1: 
├─ 001 User 엔티티 (2h)
├─ 002 Order 엔티티 (3h) ← 병렬
├─ 003 Portfolio 엔티티 (2.5h) ← 병렬
└─ 004 값 객체 (1.5h) ← 병렬

Day 2:
├─ 005 마이그레이션 (2h)
└─ 013 KIS API 인증 (3h) ← 병렬 (독립)

Day 3:
├─ 006 User 리포지토리 (2h)
├─ 007 Order 리포지토리 (2.5h) ← 병렬
└─ 016 Rate Limiter (3h) ← 병렬 (013 의존)

Day 4:
├─ 008 주문 생성 서비스 (4h)
├─ 009 주문 조회 서비스 (2h) ← 병렬
└─ 010 Auth API (3h) ← 병렬

Day 5:
├─ 011 Orders API (3.5h)
├─ 012 인증 미들웨어 (3h) ← 병렬
└─ 014 KIS API 주문 (4h) ← 병렬

Day 6:
├─ 015 주문 동시성 처리 (4h)
└─ 017 전체 통합 테스트 (3h)
```

**총 예상**: 6일 (하루 4-5시간, 2-3세션)
```

### 예시 2: 개별 Task 상세

```markdown
## Task 008: 주문 생성 서비스

### 메타 정보
- **ID**: 008
- **난이도**: Intermediate (Level 2)
- **예상 시간**: 4시간
- **의존성**: 004 (값 객체), 007 (Order 리포지토리)

### 목표
주문 생성 유스케이스 구현 - 검증, 생성, 이벤트 발행

### 입력
- Blueprint Section 4.2 (POST /api/v1/orders)
- Blueprint Section 3.3 (Order Aggregate)
- PROJECT_STANDARDS.md (서비스 레이어 규칙)
- core/logging, core/errors

### 출력
```
src/application/orders/
├── __init__.py
├── commands.py          # CreateOrderCommand
├── services.py          # OrderService.create_order()
└── exceptions.py        # OrderCreationError

tests/unit/application/orders/
├── __init__.py
└── test_order_service.py
```

### 제약
- MUST: CreateOrderCommand (타입 안전 모델) 사용
- MUST: Order Aggregate 도메인 규칙 적용
- MUST: OrderCreated 이벤트 발행
- MUST: 잔고 검증 포함
- MUST: 트랜잭션 경계 명확히
- MUST NOT: 직접 DB 접근 (리포지토리 사용)
- MUST NOT: API 레이어 의존

### 핵심 로직 (의사코드)

```
CLASS OrderService:
    CONSTRUCTOR(order_repo, portfolio_repo, event_publisher, logger)
    
    METHOD create_order(command: CreateOrderCommand) -> Order:
        """주문 생성"""
        logger.info("주문 생성 시작", user_id=command.user_id)
        
        # 1. 잔고 검증
        portfolio = portfolio_repo.get_by_user_id(command.user_id)
        IF NOT portfolio.has_sufficient_balance(command.total_amount):
            THROW InsufficientBalanceError(
                required=command.total_amount,
                available=portfolio.cash_balance
            )
        
        # 2. Order Aggregate 생성
        order = Order.create(
            user_id=command.user_id,
            symbol=command.symbol,
            side=command.side,
            order_type=command.order_type,
            quantity=command.quantity,
            price=command.price
        )
        
        # 3. 저장
        order_repo.save(order)
        
        # 4. 이벤트 발행
        FOR EACH event IN order.domain_events:
            event_publisher.publish(event)
        
        logger.info("주문 생성 완료", order_id=order.id)
        RETURN order
```

**언어별 구현 예시**: docs/manuals/ 참조

### 테스트 케이스 (설계)

```
테스트 클래스: OrderServiceTest

1. test_create_order_success: 정상 주문 생성
   Given: 유효한 CreateOrderCommand (symbol, side, order_type, quantity, price)
   When: service.create_order(command) 호출
   Then: 
     - order.status == PENDING
     - order.symbol == 입력값
     - OrderCreated 이벤트 발행됨

2. test_create_order_insufficient_balance: 잔고 부족 시 실패
   Given: portfolio.cash_balance = 100,000원, 필요 금액 = 7,000,000원
   When: service.create_order(command) 호출
   Then: InsufficientBalanceError 발생

3. test_create_order_market_type_no_price: 시장가 주문은 가격 없음
   Given: order_type=MARKET, price=null
   When: service.create_order(command) 호출
   Then: order.price == null

4. test_create_order_limit_type_requires_price: 지정가 주문은 가격 필수
   Given: order_type=LIMIT, price=null
   When: service.create_order(command) 호출
   Then: ValidationError 발생
```

**언어별 테스트 구현**: docs/manuals/ 참조

### 완료 조건
- [ ] 타입 체커 0 errors
- [ ] 린터 0 violations
- [ ] 테스트 프레임워크 통과 (4개 테스트 케이스)
- [ ] Coverage 95%+
- [ ] 잔고 검증 로직 작동
- [ ] 도메인 이벤트 발행
- [ ] 로깅 (INFO: 시작/완료, ERROR: 실패)
```



---

## ✅ Stage 8 완료 체크리스트

### Blueprint 분석

- [ ] Blueprint 9개 섹션 검토
- [ ] 각 섹션에서 Task 후보 도출
- [ ] Task 크기 검증 (100-150줄 체크리스트)

### Task 분류 (RDoLT)

- [ ] Phase 1 (Easy) Task 정의
- [ ] Phase 2 (Intermediate) Task 정의
- [ ] Phase 3 (Final) Task 정의
- [ ] 각 Task 난이도 적절성 확인

### 의존성 분석

- [ ] 각 Task 의존성 명시
- [ ] 의존성 다이어그램 작성
- [ ] 핵심 경로 (Critical Path) 식별
- [ ] 병렬 실행 가능 Task 식별

### Task 상세 정의

- [ ] 각 Task 메타 정보 (ID, 난이도, 예상 시간)
- [ ] 각 Task 목표 (한 문장)
- [ ] 각 Task 입력/출력 명시
- [ ] 각 Task 제약 (MUST/MUST NOT)
- [ ] 각 Task 완료 조건 (타입 체커 0, 린터 0, Coverage 95%)

### 일정 계획

- [ ] 핵심 경로 시간 계산
- [ ] 병렬 실행 계획
- [ ] 일별 Task 배치

### 산출물

- [ ] `08T-01_task_breakdown.md` 작성
- [ ] Stage 9 전달 준비

---

## 🔗 Stage 8 → Stage 9 연결

### Stage 9에 전달하는 것

| 전달 항목 | 내용 | 용도 |
|----------|------|------|
| Task 목록 | 001~017 (17개) | 체크리스트 작성 대상 |
| Task 상세 | 목표, 입출력, 제약 | 체크리스트 내용 |
| 의존성 | Task 간 관계 | 작업 순서 |

### Stage 9 미리보기

```
Stage 9: 9-Step Checklist + 구현

목표: 각 Task마다 TDD 기반 9-Step 체크리스트 작성

9-Step 구조:
────────────────────────────────
Step 1: 목표 이해 📖
Step 2: 테스트 작성 🧪 (TDD - Red)
Step 3: 구현 🔨 (TDD - Green)
Step 4: 정적 검증 🔍 (린터, 타입 체커)
Step 5: 리팩토링 ✨ (TDD - Refactor)
Step 6: 커버리지 📊 (95%+)
Step 7: 통합 확인 🔗
Step 8: 문서화 📝
Step 9: 완료 확인 ✅

체크리스트 파일:
├─ 09L-001_user_entity.md
├─ 09L-002_order_entity.md
├─ 09L-003_portfolio_entity.md
├─ ...
└─ 09L-017_integration_test.md
```

### 체크리스트 크기 예상

```
각 Task별 체크리스트:

Task 001 (User 엔티티):
├─ Step 1: 10줄
├─ Step 2: 30줄 (테스트 코드)
├─ Step 3: 25줄 (구현 코드)
├─ Step 4: 5줄 (명령어)
├─ Step 5: 10줄
├─ Step 6: 5줄
├─ Step 7: 5줄
├─ Step 8: 5줄
└─ Step 9: 5줄
────────────────────────────
총: ~100줄 ✅

Task 008 (주문 생성 서비스):
├─ Step 1: 15줄
├─ Step 2: 50줄 (테스트 코드)
├─ Step 3: 40줄 (구현 코드)
├─ Step 4: 5줄
├─ Step 5: 15줄
├─ Step 6: 5줄
├─ Step 7: 10줄
├─ Step 8: 5줄
└─ Step 9: 5줄
────────────────────────────
총: ~150줄 ✅
```

---

## 💡 핵심 원칙 요약

### 좋은 Task의 4가지 조건

```
1. 적절한 크기:
   ├─ 체크리스트: 100-150줄
   ├─ 예상 시간: 2-4시간
   └─ 컨텍스트: 80-90K 토큰 이내

2. 독립성:
   ├─ 다른 Task 없이 테스트 가능
   ├─ 자체 완결적
   └─ 롤백 가능

3. 검증 가능:
   ├─ Type Check 0 errors
   ├─ Lint 0 violations
   └─ Coverage 95%+

4. 가치 있음:
   ├─ 완료 시 실제 기능 작동
   └─ 진행 상황 확인 가능
```

### RDoLT 적용

```
Level 1 - Easy (기반):
├─ 단순 모델, 기본 CRUD
├─ 의존성 없음
└─ 예: User 엔티티, 값 객체

Level 2 - Intermediate (상호작용):
├─ 엔티티 간 관계, 서비스
├─ Easy Task에 의존
└─ 예: 주문 생성 서비스, API

Level 3 - Final (엣지 케이스):
├─ 동시성, 외부 연동, 보안
├─ Intermediate Task에 의존
└─ 예: KIS API 연동, 동시성 처리

순서: Easy → Intermediate → Final
```

### Task Breakdown 작성 흐름

```
Blueprint (1,000+ 줄)
        ↓
    섹션별 분석
        ↓
    Task 후보 도출
        ↓
    크기 검증 (100-150줄?)
        ↓
    RDoLT 분류 (Easy/Intermediate/Final)
        ↓
    의존성 분석
        ↓
    핵심 경로 계산
        ↓
    병렬 실행 계획
        ↓
    Task 상세 정의
        ↓
08T-01_task_breakdown.md (16-25 Tasks)
        ↓
    Stage 9: 체크리스트
```

---

## 🎯 Task 크기 판단 가이드

### 크기가 적절한지 확인하는 질문

```
1. 체크리스트 예상 줄 수?
   - 80줄 미만 → 너무 작음 (합치기)
   - 80-180줄 → 적절 ✅
   - 180줄 초과 → 너무 큼 (분할)

2. 예상 시간?
   - 1.5시간 미만 → 너무 작음
   - 2-4시간 → 적절 ✅
   - 5시간 초과 → 너무 큼

3. 생성되는 파일 수?
   - 0개 → 가치 없음
   - 1-3개 → 적절 ✅
   - 5개 초과 → 너무 큼

4. 테스트 케이스 수?
   - 2개 미만 → 너무 작음
   - 5-15개 → 적절 ✅
   - 20개 초과 → 너무 큼

5. 독립적으로 테스트 가능?
   - Yes → 적절 ✅
   - No → 분할 또는 의존성 재검토
```

### 분할 패턴

```
너무 큰 Task 분할 예시:

❌ "Order 도메인 전체 구현" (20시간)
    ↓ 분할
✅ Task 002: Order 엔티티 + Aggregate (3h)
✅ Task 007: Order 리포지토리 (2.5h)
✅ Task 008: 주문 생성 서비스 (4h)
✅ Task 009: 주문 조회 서비스 (2h)
✅ Task 011: Orders API (3.5h)

분할 기준:
├─ 레이어별 분할 (Domain → Application → API)
├─ 기능별 분할 (생성 → 조회 → 수정 → 삭제)
└─ 의존성별 분할 (기반 → 활용)
```

### 합치기 패턴

```
너무 작은 Task 합치기 예시:

❌ Task A: "OrderStatus Enum 정의" (20분)
❌ Task B: "OrderType Enum 정의" (20분)
❌ Task C: "Money 값 객체 정의" (30분)
    ↓ 합치기
✅ Task 004: 값 객체 + 열거형 (1.5h)

합치기 기준:
├─ 같은 레이어
├─ 같은 도메인
├─ 의존성 없음 (서로 독립)
└─ 총 시간 2-4시간 범위
```

---

## 🧩 DNA 핵심 원칙 3: 기능별 분해 + 연결부 + 조립

### 레이어별 vs 기능별 분해

```
❌ 레이어별 분해 (Anti-pattern):
────────────────────────────────────
Task 001: 모든 엔티티 (Domain Layer)
Task 002: 모든 리포지토리 (Infrastructure Layer)
Task 003: 모든 서비스 (Application Layer)
Task 004: 모든 API (Presentation Layer)

문제점:
├─ Task 001 완료해도 "작동하는 기능" 없음
├─ Task 004까지 가야 첫 기능 작동
├─ 중간 검증 불가
├─ 실패 시 전체 재작업
└─ "레고 블럭만 있고 조립된 것 없음"

✅ 기능별 분해 (Best Practice):
────────────────────────────────────
Task 001: User 기능 (Entity + Repo + Service + API)
Task 002: Order 생성 기능 (Entity + Repo + Service + API)
Task 003: Order 조회 기능 (Repo + Service + API)
Task 004: Order 취소 기능 (Service + API)

장점:
├─ Task 001 완료 = User 기능 작동!
├─ 각 Task 완료 시 데모 가능
├─ 중간 검증 가능
├─ 실패 시 해당 기능만 재작업
└─ "조립된 레고 작품이 하나씩 완성"
```

### 기능별 분해 비교표

| 관점 | 레이어별 분해 | 기능별 분해 |
|------|-------------|-----------|
| **Task 완료 시** | 레이어 일부 완성 | 기능 완성 (End-to-End) |
| **테스트** | 단위 테스트만 | 단위 + 통합 테스트 |
| **데모** | 불가능 | 가능 (API 호출 가능) |
| **실패 영향** | 전체 지연 | 해당 기능만 지연 |
| **병렬화** | 어려움 | 쉬움 (기능별 독립) |
| **진행 측정** | 모호함 | 명확함 ("3/10 기능 완료") |

### 연결부 (Interface) 설계

```
기능별 분해 시 연결부가 핵심!

❌ 연결부 없이 분해:
Task 001: User 기능 (UserService 직접 구현)
Task 002: Order 기능 (UserService 필요... 어떻게?)

✅ 연결부 먼저 정의:
Task 000: 인터페이스 정의 (연결부)
├─ IUserRepository
├─ IOrderRepository
├─ IUserService
└─ IOrderService

Task 001: User 기능 (IUserRepository, IUserService 구현)
Task 002: Order 기능 (IUserService 주입받아 사용)
```

### 연결부 설계 방법

```
domain/interfaces/ (Task 000에서 정의)

Interface: IUserRepository
├─ get_by_id(user_id) → User?
├─ get_by_email(email) → User?
└─ save(user) → void

Interface: IOrderRepository
├─ get_by_id(order_id) → Order?
├─ get_by_user_id(user_id) → List<Order>
└─ save(order) → void

Interface: IUserService
├─ get_user(user_id) → User
└─ create_user(command) → User

Interface: IOrderService
├─ create_order(command) → Order
└─ get_order(order_id) → Order

* 언어별 구현: docs/manuals/ 참조
  - Python: Protocol/ABC
  - TypeScript: interface
  - Java: interface
  - Go: implicit interface
```

### 조립 전략

```
조립 순서 (기능별 분해 후):

Phase 1: 연결부 정의 (Task 000)
────────────────────────────────────
├─ 모든 인터페이스 정의
├─ 타입 힌트만 있는 빈 껍데기
├─ 예상 시간: 1-2시간
└─ 이후 모든 Task가 이 인터페이스 사용

Phase 2: 핵심 기능 (Task 001-005)
────────────────────────────────────
├─ 각 기능별 End-to-End 구현
├─ 인터페이스 구현체 작성
├─ Mock으로 다른 기능 대체
└─ 각 Task 완료 시 해당 기능 작동

Phase 3: 연결 (Task 006-008)
────────────────────────────────────
├─ Mock → 실제 구현체 교체
├─ 기능 간 통합 테스트
├─ E2E 테스트 추가
└─ 전체 시스템 작동 확인
```

### 조립 예시: 주문 생성 기능

```
Task 002: Order 생성 기능 (의사코드)

1. 인터페이스 사용 (Task 000에서 정의된 것):
   - IOrderRepository
   - IUserRepository

2. 서비스 구현:
   CLASS OrderService:
     CONSTRUCTOR(order_repo: IOrderRepository, user_repo: IUserRepository)
     
     METHOD create_order(command):
       // User 검증 (IUserRepository 사용)
       user = user_repo.get_by_id(command.user_id)
       IF NOT user:
         THROW UserNotFoundError
       
       // Order 생성
       order = Order.create(...)
       
       // 저장 (IOrderRepository 사용)
       order_repo.save(order)
       RETURN order

3. 테스트 (Mock 사용):
   TEST create_order:
     // Mock 리포지토리
     user_repo = Mock(IUserRepository)
     user_repo.get_by_id → returns User(...)
     
     order_repo = Mock(IOrderRepository)
     
     service = OrderService(order_repo, user_repo)
     order = service.create_order(command)
     
     ASSERT order.status == PENDING
     ASSERT order_repo.save called once
```

### 수정된 Task Breakdown 예시 (기능별)

```
# 기존 (레이어별) → 수정 (기능별)

기존:
├─ Task 001: User 엔티티
├─ Task 002: Order 엔티티
├─ Task 003: Portfolio 엔티티
├─ Task 004: 값 객체
├─ Task 005: 마이그레이션
├─ Task 006: User 리포지토리
├─ Task 007: Order 리포지토리
├─ Task 008: 주문 생성 서비스
├─ Task 009: 주문 조회 서비스
├─ Task 010: Auth API
├─ Task 011: Orders API
...

수정:
├─ Task 000: 인터페이스 정의 (모든 Protocol)     [1.5h]
├─ Task 001: User 기능 (Entity→Repo→Service→API) [4h]
├─ Task 002: Auth 기능 (Login, Token, Refresh)   [3h]
├─ Task 003: Order 생성 기능 (E2E)               [4h]
├─ Task 004: Order 조회 기능 (E2E)               [2.5h]
├─ Task 005: Order 취소 기능 (E2E)               [2.5h]
├─ Task 006: Portfolio 기능 (E2E)                [3h]
├─ Task 007: KIS 연동 기능 (E2E)                 [4h]
├─ Task 008: 기능 간 통합                        [3h]
└─ Task 009: E2E 테스트                          [2.5h]

총: 30시간 (10 Tasks) vs 48시간 (17 Tasks)
효율성: 37.5% 향상!
```

---

## ⏪ DNA 핵심 원칙 4: 역방향 수정 프로토콜

### 이전 Stage 오류 발견 시나리오

```
Stage 8 작업 중 발견할 수 있는 오류:

시나리오 1: Blueprint 불완전
────────────────────────────────────
"Task 분해하려는데 Blueprint에 Order 취소 API가 없네?"
→ Stage 7 Blueprint 수정 필요

시나리오 2: ADR 누락
────────────────────────────────────
"외부 결제 API 연동이 필요한데 ADR에 결정 안 되어 있네?"
→ Stage 3 ADR 추가 필요

시나리오 3: NFR 재검토
────────────────────────────────────
"Task 분해하니까 실시간 요구사항이 더 중요했네?"
→ Stage 2 NFR 우선순위 수정 필요

시나리오 4: 패밀리 재분류
────────────────────────────────────
"협업 기능이 핵심인데 CRUD 패밀리로 분류했었네?"
→ Stage 1 패밀리 재분류 필요 (드뭄)
```

### 6단계 수정 프로토콜

```
Stage 8에서 이전 Stage 오류 발견 시:

Step 1: 오류 발견 및 문서화
────────────────────────────────────
├─ 발견 위치: Stage 8 Task Breakdown
├─ 오류 내용: [구체적 설명]
├─ 영향 받는 Stage: Stage [N]
└─ 기록: 08T-01_task_breakdown.md에 "발견된 이슈" 섹션 추가

Step 2: 영향 범위 파악
────────────────────────────────────
├─ 직접 영향: Stage [N]
├─ 간접 영향: Stage [N+1] ~ Stage 7
├─ 재작업 예상 시간: [X]시간
└─ 기록: 영향 범위 문서화

Step 3: 해당 Stage로 이동 → 수정
────────────────────────────────────
├─ Stage [N] 산출물 수정
├─ 수정 이력 기록
├─ 버전 업데이트 (v1.0 → v1.1)
└─ 수정 완료 검증

Step 4: 중간 Stage 전파 (N+1 ~ 7)
────────────────────────────────────
├─ 각 Stage 산출물 영향 확인
├─ 필요 시 수정
├─ 수정 이력 기록
└─ 일관성 검증

Step 5: Stage 8 재진행
────────────────────────────────────
├─ 수정된 입력으로 Task Breakdown 재작성
├─ 3단계 검증 프로토콜 재실행
└─ 완전성 확인

Step 6: 재진행 결과 검증
────────────────────────────────────
├─ 오류가 해결되었는지 확인
├─ 새로운 문제 발생 여부 확인
├─ 최종 승인
└─ Stage 9 전달
```

### 추적성 (Traceability)

```
수정 이력 관리:

파일: docs/revision_log.md
────────────────────────────────────
# Revision Log

## 2025-12-03 (Stage 8 작업 중 발견)

### Issue #001: Order 취소 API 누락
- **발견 Stage**: Stage 8 Task Breakdown
- **영향 Stage**: Stage 7 Blueprint
- **수정 내용**: Section 4.1에 DELETE /orders/{id} 추가
- **영향 범위**: Stage 8 Task 목록에 "Order 취소 기능" 추가
- **수정자**: Jason
- **검증**: AI 검증 완료

### Issue #002: 외부 결제 API ADR 누락
- **발견 Stage**: Stage 8 Task Breakdown
- **영향 Stage**: Stage 3 ADR
- **수정 내용**: ADR-015 "외부 결제 API 연동" 추가
- **영향 범위**: 
  - Stage 4: DNA Blueprint에 결제 관련 DNA 추가
  - Stage 7: Blueprint Section 6 외부 연동 추가
  - Stage 8: Task 목록에 결제 기능 추가
- **수정자**: Jason
- **검증**: AI 검증 완료
```

### 예시: Stage 7 작성 중 Stage 3 ADR 오류 발견

```
상황:
Stage 7 Blueprint 작성 중 "KIS API Rate Limiting" 결정이
ADR에 없음을 발견

6단계 프로토콜 적용:

Step 1: 오류 문서화
├─ 발견: Stage 7 Blueprint Section 6.1 작성 중
├─ 오류: KIS API Rate Limiting 전략 ADR 없음
├─ 영향: Stage 3
└─ 기록: 07B-01에 "발견된 이슈" 추가

Step 2: 영향 범위
├─ 직접: Stage 3 (ADR 추가 필요)
├─ 간접: Stage 4-6 (영향 없음, DNA 변경 불필요)
├─ 재작업: 2시간
└─ 기록 완료

Step 3: Stage 3 수정
├─ ADR-016 "KIS API Rate Limiting" 작성
├─ 결정: 초당 15회 제한, 재시도 전략
├─ 버전: v1.0
└─ 검증 완료

Step 4: 중간 Stage 전파
├─ Stage 4-6: 변경 불필요 확인
└─ 스킵

Step 5: Stage 7 재진행
├─ Blueprint Section 6.1 Rate Limiting 추가
├─ ADR-016 참조 추가
└─ 완료

Step 6: 검증
├─ Rate Limiting 설계 완료 확인
├─ 새로운 문제 없음
└─ Stage 8 전달 가능 ✅
```

---

**Remember**: 
- Blueprint는 전체 그림, Task는 레고 블럭
- 좋은 Task = 적절한 크기 + 독립성 + 검증 가능 + 가치
- RDoLT: Easy → Intermediate → Final 순서
- 핵심 경로 파악 = 일정 예측 가능
- Stage 9에서 각 Task마다 9-Step 체크리스트 작성

*Task Breakdown은 "AI가 100% 성공할 수 있는 작업 단위"를 만드는 과정입니다.*


================================================================================

📄 FILE: 09G-00_checklist_guide.md
--------------------------------------------------------------------------------

# Stage9: 작업 체크리스트 작성 가이드(9-Step Checklist)

> **목적**: Stage 9 - TDD 기반 9-Step Checklist로 모든 기능 구현, 0 violations, 95%+ coverage 보장
>
> **버전**: v4.1 (2025-12-03)
> - v2.0: Stage 9 범위 명시, 입력/출력 문서 추가

---

## 🌐 언어 중립성 안내

이 가이드는 **언어 무관 개념 + Python 생태계 예시**로 구성됩니다:

```
개념 (언어 무관):
├─ 9-Step TDD Checklist 구조
├─ 코드 스켈레톤 작성 원칙
├─ 테스트 케이스 설계 방법
└─ 품질 검증 기준 (0 violations, 95%+ coverage)

예시 (Python 생태계):
├─ pytest, Ruff, MyPy 명령어
├─ Pydantic, structlog 코드
└─ Python 문법 스켈레톤

다른 언어:
└─ 해당 언어 매뉴얼 참조
```

**언어별 도구 대응표**:

| 언어       | Linter        | Type Checker | Test Framework | Coverage     |
|-----------|---------------|--------------|----------------|--------------|
| Python    | ruff          | mypy         | pytest         | pytest-cov   |
| TypeScript| eslint        | tsc          | jest           | jest         |
| Rust      | clippy        | rustc        | cargo test     | tarpaulin    |
| Go        | golangci-lint | go vet       | go test        | go test      |
| Java      | checkstyle    | javac        | junit          | jacoco       |

**적용 방법**: 예시의 도구 이름만 해당 언어 도구로 교체하면 됩니다.

```

---

## 📚 이 가이드의 위치

```
DNA 방법론 문서 체계:

Tier 1: 00_CORE_METHODOLOGY.md (전체 맥락)
           ↓
Tier 2: 01_DNA_METHODOLOGY_DETAILED.md (상세 원리)
           ↓
Tier 3: 이 문서 (Stage 8 실행 가이드) ← 지금 여기!
```

**참조 문서**:

- **원리 이해**: `01_DNA_METHODOLOGY_DETAILED.md` **Part 6.3**

---

## 📥 입력 문서 (Stage 8에서 받은 것)

#### 1. **`08T-01_task_breakdown.md`** (필수)
- 작업 목록 (Task 001~N)
- **활용**: 각 Task마다 Checklist 생성

#### 2. **`06D-01_project_standards.md`** (참고)
- 프로젝트 표준
- **활용**: Checklist에 표준 반영

---

## 📤 출력 문서 (이 Stage에서 생성해야 할 문서)

### 필수 문서

각 Task마다 1개씩 Checklist 생성:

#### 1. **`09L-01_task_001_checklist.md`**
#### 2. **`09L-02_task_002_checklist.md`**
#### 3. **`09L-03_task_003_checklist.md`**
...

**내용** (TDD 9-Step):
```markdown
# Task 001 Checklist: Order Entity 구현

## Step 1: 목표 이해 ✅
- [ ] Task 문서 읽기 (08T-01 Task 001)
- [ ] ADR-116 읽기
- [ ] 표준 확인 (Naming, Validation)
- [ ] 성공 기준 명확히

## Step 2: 테스트 작성 ✅
- [ ] `tests/test_order_entity.*` 생성
- [ ] 실패하는 테스트 작성
- [ ] Test 실행 → RED 확인

## Step 3: 구현 ✅
- [ ] `src/domains/order/models.*` 생성
- [ ] Order 클래스 작성
- [ ] Test 실행 → GREEN 확인

## Step 4: 정적 검증 ✅
- [ ] Lint (0 violations)
- [ ] Type Check (0 errors)

## Step 5: 단위 테스트 실행 ✅
- [ ] Test tests/test_order_entity.*
- [ ] coverage report (95%+)

## Step 6: 리팩토링 ✅
- [ ] 중복 코드 제거
- [ ] 명명 개선
- [ ] 테스트 재실행

## Step 7: 종합 테스트 ✅
- [ ] 통합 테스트 (필요시)
- [ ] E2E 테스트 (필요시)

## Step 8: 문서화 ✅
- [ ] Docstring 작성
- [ ] README 업데이트 (필요시)

## Step 9: 커밋 ✅
- [ ] git add .
- [ ] git commit -m "..."
- [ ] PR 생성 (필요시)
```

**특징**:
- AI가 체크박스 하나씩 완료
- 0 violations 보장
- 95%+ coverage 보장

---

## 🔄 다음 Stage로 전달되는 것

Stage 9 → 구현:
- ✅ 작업별 체크리스트
- ✅ TDD 9-Step 실행 가이드
- ✅ 품질 보장 메커니즘

구현 단계에서는:
- Checklist를 따라 단계별 구현
- 모든 검증 통과 확인
- 완성된 코드 + 테스트 + 문서

---

## 🎯 DNA 핵심 원칙 1: AI 최적 크기와 Stage 9

### Stage 9 = AI 실행의 최종 단계

```
DNA 방법론 흐름에서 Stage 9의 위치:
────────────────────────────────────────────────────────

Stage 1-7: Human-Driven (인간 중심)
├─ 패밀리 분류, NFR, ADR, Blueprint
├─ 문서 크기 제한 없음
└─ 인간의 이해와 의사결정 중심

Stage 8: 변환점 (Transformation Point)
├─ Blueprint → Task 분해
├─ AI 컨텍스트 한계 고려 시작
└─ Task 크기: 2-4시간, 체크리스트 100-150줄

Stage 9: AI 실행 (AI Execution) ← 여기!
────────────────────────────────────────────────────────
├─ Task → 9-Step Checklist
├─ AI가 직접 실행하는 최종 산출물
├─ 체크리스트가 AI의 "작업 지시서"
└─ 완전해야 AI가 100% 성공!
```

### 왜 체크리스트는 100-150줄인가?

```
체크리스트 크기의 과학적 근거:
────────────────────────────────────────────────────────

AI 컨텍스트 윈도우 (예: 200K 토큰)
├─ 시스템 프롬프트: ~30K 토큰
├─ 대화 히스토리: ~20K 토큰
├─ Task 문서 + Blueprint 참조: ~30K 토큰
├─ Checklist: ~15K 토큰 (100-150줄)
├─ 생성할 코드: ~20K 토큰
└─ 응답 생성 여유: ~85K 토큰 ✅

체크리스트 줄 수 → 토큰 변환:
├─ 체크리스트 1줄 ≈ 10-15 토큰
├─ 코드 스켈레톤 포함 시 ≈ 20 토큰/줄
├─ 100줄 = ~1,500 토큰
├─ 150줄 = ~2,500 토큰
└─ 코드 예시 포함 시 ~5,000-10,000 토큰

결론:
├─ 100줄: 간단한 Task (Entity, 값 객체)
├─ 120줄: 표준 Task (Service, Repository)
├─ 150줄: 복잡한 Task (외부 연동, 동시성)
└─ 180줄+: 분할 필요! ⚠️
```

### 체크리스트 크기 판단 공식

```
FUNCTION is_optimal_checklist_size(checklist):
    """Checklist 크기가 AI 최적인지 판단"""
    
    // 1. 줄 수 검증
    total_lines = checklist.count_lines()
    IF NOT (80 <= total_lines <= 180):
        RETURN FALSE
    
    // 2. 9-Step 완전성
    IF checklist.steps.length != 9:
        RETURN FALSE
    
    // 3. 코드 스켈레톤 포함
    code_skeleton_lines = checklist.count_code_lines()
    IF code_skeleton_lines < 20:  // 최소 스켈레톤
        RETURN FALSE
    IF code_skeleton_lines > 100:  // 너무 많음
        RETURN FALSE
    
    // 4. 테스트 케이스 포함
    test_cases = checklist.count_test_cases()
    IF NOT (3 <= test_cases <= 10):
        RETURN FALSE
    
    RETURN TRUE
```

### 크기별 체크리스트 예시

| Task 유형 | 예상 줄 수 | 코드 스켈레톤 | 테스트 케이스 |
|----------|----------|------------|------------|
| Entity (단순) | 80-100줄 | 20-30줄 | 3-5개 |
| Service (표준) | 100-130줄 | 30-50줄 | 5-8개 |
| API Endpoint | 110-140줄 | 40-60줄 | 5-8개 |
| 외부 연동 | 130-160줄 | 50-70줄 | 6-10개 |
| 동시성 처리 | 140-180줄 | 60-80줄 | 8-12개 |

---

## 🔄 DNA 핵심 원칙 2: 완전해질 때까지 반복 (Checklist 관점)

### "완전한 Checklist"란?

```
완전한 Checklist의 조건:
────────────────────────────────────────────────────────

AI가 Checklist만 보고 100% Task 완료 가능:
├─ 추가 질문 없음 (모든 정보 포함)
├─ 외부 문서 참조 불필요 (인라인 복사)
├─ 모호함 0 (구체적 명령어)
├─ 누락 0 (9-Step 모두 완전)
└─ 불완전함 0 (검증 가능한 완료 조건)

반대로, 불완전한 Checklist:
├─ ❌ "PROJECT_STANDARDS.md 참조하세요"
├─ ❌ "적절히 구현하세요"
├─ ❌ "필요한 테스트 작성"
├─ ❌ Step 3만 상세하고 나머지 간략
└─ → AI 실패 → 재작업 → 시간 낭비!
```

### 3단계 검증 프로토콜 (Checklist용)

```
┌─────────────────────────────────────────────────────────┐
│ 검증 1: 크기                                           │
├─────────────────────────────────────────────────────────┤
│ □ 총 줄 수: 80-180줄 범위?                              │
│ □ 코드 스켈레톤: 20-100줄?                              │
│ □ 테스트 케이스: 3-10개?                                │
│ □ 자주 하는 실수: 3-5개?                                │
│                                                         │
│ 실패 시 → 분할 (너무 큼) 또는 보완 (너무 작음)           │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ 검증 2: 자급자족성                                      │
├─────────────────────────────────────────────────────────┤
│ □ 외부 문서 참조 없음? (인라인 복사?)                    │
│ □ 프로젝트 표준 인라인?                                 │
│ □ ADR 핵심 내용 인라인?                                 │
│ □ 모든 명령어 복사-붙여넣기 가능?                        │
│                                                         │
│ 실패 시 → 필요한 내용 인라인 복사                        │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ 검증 3: 실행 가능성                                     │
├─────────────────────────────────────────────────────────┤
│ □ Step 1: 입출력 명확?                                  │
│ □ Step 2: 테스트 케이스 구체적? (코드 포함?)             │
│ □ Step 3: 구현 스켈레톤 있음? (복붙 아닌 가이드)         │
│ □ Step 4-5: 검증 명령어 복사 가능?                      │
│ □ Step 6-9: 완료 조건 측정 가능?                        │
│                                                         │
│ 실패 시 → 해당 Step 보완                                │
└─────────────────────────────────────────────────────────┘
                        ↓
          모든 검증 통과 → AI 실행 준비 완료! ✅
```

### Checklist 완전성 체크리스트

```
Checklist 완전성 검증:
────────────────────────────────────────────────────────

Step별 완전성:

□ Step 1 (목표 이해):
  ├─ Task 목표가 명확히 복사됨?
  ├─ 입출력이 구체적으로 정의됨?
  └─ 성공 기준이 측정 가능?

□ Step 2 (테스트 작성):
  ├─ 테스트 케이스 3개 이상?
  ├─ Given-When-Then 구조?
  ├─ 실제 코드 스켈레톤 포함?
  └─ 성공/실패/엣지 케이스 모두?

□ Step 3 (구현):
  ├─ 프로젝트 표준 인라인?
  ├─ 구현 스켈레톤 (복붙 아닌 가이드)?
  ├─ 자주 하는 실수 ❌/✅?
  └─ 파일 경로 명확?

□ Step 4 (정적 검증):
  ├─ Lint 명령어 복사 가능?
  ├─ Type Check 명령어 복사 가능?
  └─ 예상 출력 명시?

□ Step 5 (테스트 실행):
  ├─ Test 명령어 복사 가능?
  ├─ coverage 명령어 포함?
  └─ 95%+ 기준 명시?

□ Step 6-9 (마무리):
  ├─ 리팩토링 체크리스트?
  ├─ 문서화 범위?
  └─ 커밋 메시지 형식?

모두 ✅ → 완전한 Checklist!
하나라도 ❌ → 보완 필요
```

### 재작업 사례: "JWT 토큰 생성" Checklist

```
❌ 1차 시도 (불완전):
────────────────────────────────────────────────────────

## Step 3: 구현
- create_token 함수 구현
- PROJECT_STANDARDS.md 참조

문제점:
├─ 외부 문서 참조 (자급자족 X)
├─ 구현 스켈레톤 없음
├─ 어떤 라이브러리? 어떤 알고리즘?
└─ AI가 추측해야 함 → 실패 가능성 높음

검증 결과: 검증 2 실패 (자급자족성 X)
────────────────────────────────────────────────────────

🔄 2차 시도 (보완):
────────────────────────────────────────────────────────

## Step 3: 구현

### 3.1 프로젝트 표준 (인라인)

#### 로깅 (PROJECT_STANDARDS Line 12-25)
- logger.info("event_name", key=value) 형식
- print() 금지

#### 설정 (PROJECT_STANDARDS Line 30-45)
- config.get_secret("JWT_SECRET_KEY") 사용
- 하드코딩 금지

### 3.2 구현 스켈레톤

```
// src/auth/token.* (언어별 확장자)

FUNCTION create_token(user_id: String) -> String:
    """JWT 토큰 생성.
    
    Args:
        user_id: 사용자 ID
    Returns:
        JWT 토큰 (1시간 유효)
    """
    payload = {
        "user_id": user_id,
        "exp": now() + 1_hour
    }
    secret_key = config.get_secret("JWT_SECRET_KEY")
    token = jwt.encode(payload, secret_key, algorithm="HS256")
    logger.info("token_created", user_id=user_id)
    RETURN token

// 언어별 구현 예시: docs/manuals/ 참조
```

### 3.3 자주 하는 실수

❌ exp를 초 단위로 제공:
payload["exp"] = 3600

✅ datetime으로 제공:
payload["exp"] = now() + 1_hour

검증 결과: 모든 검증 통과! ✅
────────────────────────────────────────────────────────
```

---

## 🧩 DNA 핵심 원칙 3: 기능별 구조 + 연결부 명시 (Stage 9 관점)

### Stage 9에서 "기능별"의 의미

```
Stage 8 (Task Breakdown):
├─ 레이어별 X → 기능별 O
├─ Task 완료 = 기능 완료 (E2E)
└─ 예: Task 001 = User 기능 전체

Stage 9 (Checklist):
────────────────────────────────────────────────────────
├─ 9-Step으로 기능 구현
├─ 각 Step이 "기능의 일부"
├─ Step 완료 = 검증 가능한 진행
└─ 연결부 (Interface) 명시!

핵심 차이:
├─ Stage 8: "어떤 기능을 만들까?" (What)
└─ Stage 9: "그 기능을 어떻게 만들까?" (How)
```

### 연결부 (Interface) 명시의 중요성

```
Checklist에서 연결부가 중요한 이유:
────────────────────────────────────────────────────────

Task가 다른 Task에 의존할 때:
├─ Task 001: User 엔티티
├─ Task 005: Order 생성 서비스 (User 필요!)
└─ Task 005 Checklist에 User 인터페이스 명시 필수!

예시 - Task 005 Checklist:

## Step 1: 목표 이해

### 의존성 (다른 Task에서 제공)

**User 인터페이스 (Task 001 완료 후 사용 가능)**:
```
// 이 인터페이스는 Task 001에서 구현됨
// Task 005에서는 이 인터페이스만 알면 됨

Entity: User
├─ id: UserId
├─ email: String
└─ created_at: DateTime

Interface: IUserRepository
└─ find_by_id(user_id) → User?
```

### 이 Task의 출력 (다른 Task에 제공)

**OrderService 인터페이스**:
```
// Task 005에서 구현할 것
// Task 010 (주문 조회)에서 사용할 것

Interface: IOrderService
└─ create_order(user_id, items) → Order
```

이렇게 하면:
├─ Task 001 미완료 → Mock으로 테스트 가능
├─ Task 005 완료 → 실제 User 연결
└─ AI가 의존성을 명확히 이해
```

### Mock 사용 전략

```
Mock을 활용한 독립적 Checklist:
────────────────────────────────────────────────────────

## Step 2: 테스트 작성

### 의존성 Mock

// tests/test_order_service.* (언어별 확장자)

FIXTURE mock_user_repository:
    """User 의존성 Mock (Task 001 미완료 시 사용)"""
    repo = Mock(IUserRepository)
    repo.find_by_id → returns User(
        id="user-123",
        email="test@example.com",
        created_at=now()
    )
    RETURN repo

TEST create_order_success(mock_user_repository):
    // Given
    service = OrderService(user_repo=mock_user_repository)
    
    // When
    order = service.create_order(
        user_id="user-123",
        items=[OrderItem(product_id="prod-1", quantity=2)]
    )
    
    // Then
    ASSERT order.user_id == "user-123"
    ASSERT mock_user_repository.find_by_id called once

장점:
├─ Task 001 미완료해도 Task 005 테스트 가능
├─ 병렬 작업 가능
├─ 인터페이스 계약 명확
└─ 나중에 Mock → 실제 구현체 교체만!
```

### Checklist 연결부 섹션 템플릿

```markdown
## Step 1: 목표 이해

### 1.1 Task 목표
{Task 문서에서 복사}

### 1.2 의존성 (다른 Task에서 제공받는 것)

| Task ID | 제공 인터페이스 | 상태 |
|---------|---------------|------|
| Task 001 | IUserRepository | ✅ 완료 / 🔄 Mock 사용 |
| Task 003 | Money 값 객체 | ✅ 완료 |

**인터페이스 정의** (Task 미완료 시 Mock용):
```python
class IUserRepository(Protocol):
    def find_by_id(self, user_id: UserId) -> User | None: ...
```

### 1.3 이 Task의 출력 (다른 Task에 제공할 것)

| 제공 인터페이스 | 사용할 Task |
|---------------|------------|
| IOrderService | Task 010, 015 |

**인터페이스 정의**:
```python
class IOrderService(Protocol):
    def create_order(...) -> Order: ...
```
```

---

## 1. 개요

### 목적
**Task 문서 (100줄) → 9-Step Checklist (실행 가능한 작업 지시서)**

Task 문서는 "무엇을" 만들지 정의하고, Checklist는 "어떻게" 만들지 실행 단계를 제공합니다.

### Checklist의 역할
```
Task 문서 (설계도)
    ↓
Checklist (작업 지시서)
    ↓
AI 에이전트 실행 (구현)
    ↓
완성된 코드 + 테스트 + 문서
```

### 완성 기준
- ✅ **실행 가능성**: AI가 이 Checklist만으로 Task를 완수할 수 있어야 함
- ✅ **자급자족성**: Task 문서 + Checklist만 있으면 Blueprint 없이도 작업 가능
- ✅ **검증 가능성**: 각 Step의 완료 여부를 명확히 확인 가능

---

## 2. 정보 밀도 균형점 ⚖️

### 2-1. 왜 500 lines인가?

**너무 많으면 (1,400+ lines)**:
```markdown
❌ 전체 구현 코드 400 lines 포함
❌ 전체 테스트 코드 200 lines 포함
❌ 모든 에러 처리, 엣지 케이스 포함
→ Agent가 읽기 부담스러움
→ 복붙만 하게 되어 TDD 불가능
```

**너무 적으면 (200 lines)**:
```markdown
❌ "Task 문서 Section 7 참조하세요"
❌ "PROJECT_STANDARDS.md 읽어보세요"
→ Agent가 문서 왕복하며 읽어야 함
→ 집중력 분산, 비효율적
```

**균형점 (500 lines)**: ✅
```markdown
✅ 구현 스켈레톤 (40 lines) - 핵심 로직 구조만
✅ 테스트 스켈레톤 (30 lines/케이스) - Given-When-Then + 기본 assert
✅ 자주 하는 실수 (15 lines/패턴) - ❌/✅ Before/After
✅ 프로젝트 표준 인라인 (30 lines) - 이 Task 관련만
→ Agent가 체크리스트만 보고 작업 완료
→ 스켈레톤이라 Agent가 채우며 TDD 가능
```

---

### 2-2. 구현 코드는 얼마나?

**"정보 밀도 균형점"이란?**

체크리스트에 제공하는 정보의 양과 상세도의 최적 지점입니다:
- **너무 적으면**: AI가 추측하여 프로젝트 표준 위반
- **너무 많으면**: AI가 복붙만 하여 TDD 불가능, 학습 효과 없음
- **균형점**: AI가 스스로 채우며 구현할 수 있는 "스켈레톤" 수준

이를 4단계 Level로 구체화하여, Level 3 (스켈레톤)이 균형점임을 시연합니다.

---

**Level 1: 인터페이스 계약** (20 lines) - **필수**
```python
def create_token(user_id: str) -> str:
    """JWT 액세스 토큰 생성.

    Args:
        user_id: 사용자 ID
    Returns:
        JWT 토큰 (1시간 유효)
    Raises:
        ValueError: user_id 빈 문자열
    """
```
→ "무엇을" 만들지 정의. Agent가 추측 불가능.

**Level 2: 아키텍처 제약** (10 lines) - **필수**
```python
# PyJWT 라이브러리 사용
# HS256 알고리즘만
# config.get_secret("JWT_SECRET_KEY") 사용
# structlog로 로깅
```
→ 프로젝트별 제약. Agent가 추측하면 틀림.

**Level 3: 구현 스켈레톤** (40 lines) - **균형점!** ✅
```python
def create_token(user_id: str) -> str:
    payload = {"user_id": user_id, "exp": datetime.utcnow() + timedelta(hours=1)}
    secret_key = config.get_secret("JWT_SECRET_KEY")
    token = jwt.encode(payload, secret_key, algorithm="HS256")
    logger.info("token_generated", user_id=user_id)
    return token
```
→ 핵심 로직 구조만. Agent가 에러 처리, validation 추가.

**Level 4: 전체 구현** (200+ lines) - **과함!** ❌
```python
def create_token(user_id: str) -> str:
    try:
        if not user_id:
            raise ValueError("user_id cannot be empty")
        if not isinstance(user_id, str):
            raise TypeError("user_id must be string")
        # ... 100+ lines of error handling
        # ... 50+ lines of edge case handling
    except Exception as e:
        logger.exception("unexpected_error")
        raise
```
→ 모든 엣지 케이스 포함. Agent가 복붙만 함. TDD 불가능.

**선택: Level 3 (스켈레톤)** - 이유:
- Agent가 스스로 채우며 구현 (학습 효과)
- TDD 가능 (테스트 실패 → 수정 → 통과 반복)
- "Necessary Information Only" 원칙 준수

---

### 2-3. 테스트 코드는 얼마나?

**Level 1: Given-When-Then 시나리오만** (10 lines) - **불충분** ❌
```python
def test_create_token_success():
    """Given: 유효한 user_id
       When: create_token 호출
       Then: JWT 토큰 반환"""
```
→ 구체적인 assert 없음. Agent가 어떻게 검증할지 모름.

**Level 2: 테스트 스켈레톤** (30 lines) - **균형점!** ✅
```python
def test_create_token_success():
    """Given: 유효한 user_id
       When: create_token 호출
       Then: JWT 토큰 반환"""
    # Given
    user_id = "test-user-123"
    generator = TokenGenerator()

    # When
    token = generator.create_token(user_id)

    # Then
    assert isinstance(token, str)
    decoded = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
    assert decoded["user_id"] == user_id
    # Agent가 exp 검증 등 추가
```
→ 기본 assert 구조 제공. Agent가 세밀한 검증 추가.

**Level 3: 완전한 테스트** (100+ lines) - **과함!** ❌
```python
def test_create_token_success():
    # ... 50 lines of setup
    # ... 30 lines of execution
    # ... 20 lines of verification
```
→ 모든 검증 포함. Agent가 복붙만 함.

**선택: Level 2 (스켈레톤)** - 이유:
- Given-When-Then 구조 명확
- 기본 assert로 방향 제시
- Agent가 세밀한 검증 추가 (TDD)

---

### 2-4. 자주 하는 실수는?

**Level 1: 항목만 나열** (5 lines) - **불충분** ❌
```
실수 1: exp를 초 단위로 제공
실수 2: SECRET_KEY 하드코딩
```
→ 뭐가 잘못됐는지만. 어떻게 고쳐야 할지 모름.

**Level 2: ❌/✅ Before/After** (15 lines) - **균형점!** ✅
```python
실수 1: exp를 초 단위로 제공
❌ payload["exp"] = 3600
✅ payload["exp"] = datetime.utcnow() + timedelta(hours=1)

실수 2: SECRET_KEY 하드코딩
❌ SECRET_KEY = "my-secret-123"
✅ secret_key = config.get_secret("JWT_SECRET_KEY")
```
→ 명확한 대비. Agent가 즉시 이해.

**Level 3: 이유 + 디버깅** (30+ lines) - **과함!** ❌
```
실수 1: exp를 초 단위로 제공

❌ 잘못된 코드: ...
왜 잘못됐나? ...
어떻게 발견하나? ...
✅ 올바른 코드: ...
추가 고려사항: ...
```
→ 너무 장황. Agent가 읽기 부담.

**선택: Level 2 (Before/After)** - 이유:
- 3-5 lines로 간결
- 즉시 비교 가능
- 패턴 명확

---

### 2-5. 프로젝트 표준은 어떻게?

**Option 1: 범용 문서 참조** ❌
```markdown
## Step 3: 구현
**프로젝트 표준**: PROJECT_STANDARDS.md 참조하세요
```
→ Agent가 800 lines 문서를 언제 읽나?

**Option 2: 인라인 복사** ✅ (균형점!)
```markdown
## Step 3: 구현

### 3.1 이 Task의 프로젝트 표준

#### 로깅 (PROJECT_STANDARDS.md Line 12-25)
- logger.info("event_name", key=value) 형식
- print() 금지
- 모든 주요 작업 로깅

#### 설정 (PROJECT_STANDARDS.md Line 30-45)
- config.get_secret("KEY_NAME") 사용
- 하드코딩 금지
- 환경변수로 관리

#### 에러 (PROJECT_STANDARDS.md Line 50-68)
- CustomError 상속
- structlog로 로깅
- 사용자에게 명확한 메시지
```
→ 체크리스트에 인라인. Agent가 왕복 불필요.
→ Line 참조 유지 (추적 가능성)
→ "이 Task 관련" 부분만 (Necessary Information Only)

**선택: Option 2 (인라인)** - 이유:
- 체크리스트만으로 자급자족
- 다른 문서 참조 불필요
- 30 lines 정도로 적정

---

### 2-6. 체크리스트 크기 계산

```
Step 1: 목표 이해 (50 lines)
  - Task 목표, 입출력, 성공 기준

Step 2: 테스트 작성 (100 lines)
  - Given-When-Then 시나리오 3-5개
  - 테스트 스켈레톤 (각 20-30 lines)

Step 3: 구현 (200 lines) ← 가장 많음
  - 3.1 프로젝트 표준 인라인 (30)
  - 3.2 함수 시그니처 (20)
  - 3.3 구현 스켈레톤 (40)
  - 3.4 자주 하는 실수 (60)
  - 3.5 구현 위치 (10)

Step 4: 정적 검증 (30 lines)
  - ruff, mypy, import-linter 명령어
  - 예상 출력

Step 5: 테스트 실행 (40 lines)
  - pytest + coverage 명령어
  - 예상 출력

Step 6-9: 리팩토링/재테스트/문서화/커밋 (80 lines)

총합: 50 + 100 + 200 + 30 + 40 + 80 = 500 lines
```

---

### 2-7. 파일 분리와 Line 참조

**큰 문서 = 문제 아님!**

```markdown
# 청사진이 5,000 lines? 괜찮아!

blueprints/
├── 01_auth_system.md (500 lines)
├── 02_payment_system.md (600 lines)
├── 03_notification_system.md (450 lines)
...

# Task 작성 시:
청사진 참조: blueprints/01_auth_system.md Line 145-178
→ 500 lines 문서의 33 lines만 읽으면 됨!

# Checklist 작성 시:
그 33 lines를 인라인으로 복사
→ Agent는 체크리스트만 읽음!
```

**PROJECT_STANDARDS.md가 800 lines? 괜찮아!**

```markdown
standards/
├── 01_logging.md (150 lines)
├── 02_configuration.md (120 lines)
├── 03_error_handling.md (180 lines)
├── 04_database.md (200 lines)
...

# Task 작성 시:
표준 참조: standards/01_logging.md Line 12-25
→ 150 lines 문서의 13 lines만!

# Checklist 작성 시:
그 13 lines를 Step 3.1에 인라인
→ Agent는 체크리스트만 읽음!
```

**핵심**:
- 큰 문서는 파일로 분리 (각 200-500 lines)
- Line 참조로 정확한 부분만 지정
- 체크리스트에 인라인 복사
- Agent는 최종적으로 체크리스트 500 lines만 읽음

---

## 3. 9-Step 구조 이해

### 전체 흐름
```
┌─────────────────────────────────────────────┐
│ Phase 1: 이해 + 테스트 설계 (Step 1-2)          │
│ - 목표 명확화                                  │
│ - 테스트 케이스 작성 (TDD)                      │
├─────────────────────────────────────────────┤
│ Phase 2: 구현 + 1차 검증 (Step 3-4)            │
│ - 핵심 로직 구현                               │
│ - 정적 검증 (ruff, mypy, import-linter)       │
├─────────────────────────────────────────────┤
│ Phase 3: 테스트 + 품질 개선 (Step 5-7)          │
│ - 테스트 실행 (pytest 95%+ coverage)          │
│ - 리팩토링                                    │
│ - 재테스트                                    │
├─────────────────────────────────────────────┤
│ Phase 4: 문서화 + 제출 (Step 8-9)             │
│ - Docstring + 사용 예시                       │
│ - Git commit                                │
└─────────────────────────────────────────────┘
```

### 핵심 원칙

**TDD (Test-Driven Development) ↔ 9-Step 매핑**

9-Step은 전통적인 Red-Green-Refactor 사이클을 확장한 것입니다:

```
Red-Green-Refactor (TDD 3단계):
├─ Red: 실패하는 테스트 작성
│    → Step 2: 테스트 작성
├─ Green: 최소 구현으로 통과
│    → Step 3: 구현
│    → Step 4: 정적 검증
│    → Step 5: 테스트 실행
└─ Refactor: 코드 개선
     → Step 6: 리팩토링
     → Step 7: 재테스트

추가 단계 (품질 보장):
├─ Step 1: 목표 이해 (사전 준비)
├─ Step 8: 문서화 (사후 정리)
└─ Step 9: 커밋 (최종 제출)
```

**Zero-Tolerance Quality**
- Step 4: ruff 0, mypy 0, import-linter 0
- Step 5: pytest 95%+ coverage
- Step 6-7: 품질 개선 + 재검증

**Documentation First**
- Step 8: Docstring (Google 스타일)
- 사용 예시 코드 포함

---

## 3. 9-Step 상세 가이드

### Step 1: 목표 이해

**질문**: "이 Task로 무엇을 만들 것인가?"

**산출물**:
- Task 목표 명확화
- 성공 기준 정의
- Task 문서 완전 이해

**Checklist 작성법**:
```markdown
## Step 1: 목표 이해

### Task 목표
{Task 문서의 Section 4 입력/출력을 그대로 복사}

예시:
- **입력**: user_id: str
- **출력**: token: str (JWT 액세스 토큰, 1시간 유효)

### 성공 기준
{Task 문서의 Section 6 완성 기준을 그대로 복사}

예시:
- [ ] create_token(user_id) 함수 완전 작동
- [ ] pytest 테스트 3개 통과 (성공/만료/잘못된 시크릿)
- [ ] ruff 0, mypy 0, coverage 95%+
```

**도구**: Task 문서

---

### Step 2: 테스트 작성

**질문**: "어떻게 동작을 검증할 것인가?"

**산출물**:
- Given-When-Then 테스트 케이스
- 성공/실패/엣지 케이스 포함
- pytest 파일 생성

**Checklist 작성법**:
````markdown
## Step 2: 테스트 작성

### 테스트 케이스

**성공 케이스**:

```python
def test_create_token_success():
    # Given: 유효한 사용자 ID
    user_id = "user123"

    # When: 토큰 생성
    token = create_token(user_id)

    # Then: 유효한 JWT 토큰 반환
    assert isinstance(token, str)
    decoded = jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])
    assert decoded["user_id"] == user_id
```

**실패 케이스**:

```python
def test_create_token_expired():
    # Given: 만료된 토큰
    token = create_expired_token("user123")

    # When: 토큰 검증
    # Then: ExpiredSignatureError 발생
    with pytest.raises(jwt.ExpiredSignatureError):
        jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])
```

**엣지 케이스**:

```python
def test_create_token_invalid_secret():
    # Given: 잘못된 시크릿
    token = create_token("user123")

    # When: 잘못된 시크릿으로 검증
    # Then: InvalidSignatureError 발생
    with pytest.raises(jwt.InvalidSignatureError):
        jwt.decode(token, "wrong_secret", algorithms=["HS256"])
```
### 파일 생성

- `tests/test_jwt_token.py` 생성
- 위 테스트 케이스 3개 작성
````

**도구**: pytest, Task 문서 Section 6 (완성 기준)

---

### Step 3: 구현

**질문**: "핵심 로직을 어떻게 구현할 것인가?"

**산출물**:

- 실제 구현 코드 (스켈레톤 수준)
- Type hints 포함
- 프로젝트 표준 인라인 복사

**Checklist 작성법**:

````markdown
## Step 3: 구현

### 3.1 이 Task의 프로젝트 표준 (인라인 복사!)

{Task 문서 Section 6의 프로젝트 표준을 그대로 복사}

예시:

#### 로깅 (PROJECT_STANDARDS_01_로깅.md Line 12-25)
- `logger.info("event_name", key=value)` 형식 사용
- `print()` 절대 금지
- 모든 주요 작업 (생성, 수정, 삭제) 로깅 필수
- 에러는 `logger.error()` 또는 `logger.exception()` 사용

#### 설정 (PROJECT_STANDARDS_02_설정.md Line 30-45)
- 모든 SECRET은 `config.get_secret("KEY_NAME")` 사용
- 하드코딩 절대 금지
- `.env` 파일에서 환경변수 관리
- Pydantic Settings 클래스 사용

#### 에러 처리 (PROJECT_STANDARDS_03_에러.md Line 50-68)
- 프로젝트 CustomError 클래스 상속
- 모든 예외 structlog로 로깅
- 사용자에게 명확한 에러 메시지 전달

### 3.2 함수 시그니처

{Task 문서 Section 7의 함수 시그니처}

```python
def create_token(user_id: str) -> str:
    """JWT 액세스 토큰 생성.

    Args:
        user_id: 사용자 고유 ID

    Returns:
        JWT 토큰 문자열 (1시간 유효)

    Raises:
        ValueError: user_id가 빈 문자열인 경우
    """
```

### 3.3 구현 힌트 (스켈레톤!)

{Task 문서 Section 7의 구현 힌트를 Level 3 스켈레톤으로}

**핵심**: 전체 코드 아니고 40 lines 스켈레톤만!

```python
from datetime import datetime, timedelta
import jwt
from src.config import settings

def create_token(user_id: str) -> str:
    """JWT 액세스 토큰 생성."""
    # 1. Payload 구성
    payload = {
        "user_id": user_id,
        "exp": datetime.utcnow() + timedelta(hours=1),
    }

    # 2. SECRET_KEY 가져오기
    secret_key = config.get_secret("JWT_SECRET_KEY")

    # 3. 토큰 생성
    token = jwt.encode(payload, secret_key, algorithm="HS256")

    # 4. 로깅
    logger.info("token_generated", user_id=user_id)

    return token
```

**Agent가 추가해야 할 것**:
- user_id validation (빈 문자열 체크)
- 에러 처리 (try-except)
- 추가 payload 필드 (iat, jti 등)

### 3.4 자주 하는 실수 (이 Task 특화)

{Task 문서 Section 8의 실수 패턴을 ❌/✅ 형식으로}

**실수 1: exp를 초 단위로 제공**
```python
❌ payload["exp"] = 3600  # 1970년 1월 1일 1시간 후로 해석됨!
✅ payload["exp"] = datetime.utcnow() + timedelta(hours=1)
```

**실수 2: SECRET_KEY 하드코딩**
```python
❌ SECRET_KEY = "my-secret-key-123"
✅ secret_key = config.get_secret("JWT_SECRET_KEY")
```

**실수 3: print() 사용**
```python
❌ print(f"Token generated for {user_id}")
✅ logger.info("token_generated", user_id=user_id)
```

**실수 4: algorithm 파라미터 누락**
```python
❌ jwt.encode(payload, secret_key)  # 알고리즘 기본값 변경될 수 있음
✅ jwt.encode(payload, secret_key, algorithm="HS256")
```

### 3.5 구현 위치

{Task 문서 Section 7의 구현 위치}

- **파일**: `src/auth/jwt.py`
- **함수**: `create_token(user_id: str) -> str`
- **테스트**: `tests/auth/test_jwt_token.py`
````

**도구**: Task 문서 Section 6, 7, 8

---

### Step 4: 정적 검증

**질문**: "코드 품질이 표준을 만족하는가?"

**산출물**:
- ruff 0 violations
- mypy 0 errors
- import-linter 0 violations

**Checklist 작성법**:

````markdown
## Step 4: 정적 검증

### 검증 명령어

```bash
# 1. Ruff 검사 (코드 스타일)
ruff check src/auth/jwt.py tests/test_jwt_token.py
# 기대: All checks passed!

# 2. MyPy 검사 (타입 안전성)
mypy src/auth/jwt.py tests/test_jwt_token.py
# 기대: Success: no issues found

# 3. Import Linter 검사 (아키텍처 규칙)
import-linter
# 기대: All contracts passed!
```

### 위반 발견 시 조치

**Ruff 위반**:

```bash
ruff check --fix src/auth/jwt.py
```

**MyPy 에러**:

- Type hints 추가 또는 수정
- `# type: ignore` 사용 금지

**Import Linter 위반**:

- 계층 위반 수정 (domain → infrastructure 금지)
````

**도구**: ruff, mypy, import-linter

---

### Step 5: 테스트 실행

**질문**: "테스트가 통과하고 커버리지가 충분한가?"

**산출물**:
- 모든 테스트 통과
- 95%+ test coverage
- pytest 리포트

**Checklist 작성법**:

````markdown
## Step 5: 테스트 실행

### 테스트 실행 명령어

```bash
# 전체 테스트 실행 + 커버리지
pytest tests/test_jwt_token.py \
    --cov=src/auth/jwt \
    --cov-report=term-missing \
    --cov-fail-under=95
```

### 기대 결과

```
tests/test_jwt_token.py::test_create_token_success PASSED
tests/test_jwt_token.py::test_create_token_expired PASSED
tests/test_jwt_token.py::test_create_token_invalid_secret PASSED

---------- coverage: platform darwin, python 3.11 ----------
Name                Stmts   Miss  Cover   Missing
-------------------------------------------------
src/auth/jwt.py        12      0   100%
-------------------------------------------------
TOTAL                  12      0   100%
```

### 커버리지 부족 시 조치

- Missing 라인 확인
- 추가 테스트 케이스 작성
- 95% 이상 달성할 때까지 반복
````

**도구**: pytest, pytest-cov

---

### Step 6: 리팩토링

**질문**: "코드를 더 명확하고 유지보수 가능하게 개선할 수 있는가?"

**산출물**:
- 개선된 코드 구조
- 중복 제거
- 명확한 변수명

**Checklist 작성법**:

````markdown
## Step 6: 리팩토링

### 리팩토링 체크리스트

**코드 구조**:
- [ ] 함수 길이 50줄 이하
- [ ] 중첩 depth 3 이하
- [ ] 하나의 함수는 하나의 책임만

**가독성**:
- [ ] 변수명이 명확한가? (`t` → `token`, `u` → `user_id`)
- [ ] 매직 넘버 제거 (3600 → `HOUR_IN_SECONDS`)
- [ ] 복잡한 조건문 함수로 추출

**중복 제거**:
- [ ] 반복되는 코드 함수로 추출
- [ ] 공통 상수 별도 정의

### 리팩토링 예시

**Before**:
```python
def create_token(user_id: str) -> str:
    p = {"user_id": user_id, "exp": datetime.utcnow() + timedelta(hours=1)}
    return jwt.encode(p, settings.jwt_secret, algorithm="HS256")
```

**After**:

```python
TOKEN_EXPIRY_HOURS = 1
JWT_ALGORITHM = "HS256"

def create_token(user_id: str) -> str:
    """JWT 액세스 토큰 생성."""
    payload = _create_payload(user_id)
    return jwt.encode(payload, settings.jwt_secret, algorithm=JWT_ALGORITHM)

def _create_payload(user_id: str) -> dict:
    """JWT payload 생성."""
    return {
        "user_id": user_id,
        "exp": datetime.utcnow() + timedelta(hours=TOKEN_EXPIRY_HOURS),
    }
```
````

**도구**: ruff (자동 리팩토링), IDE refactoring tools

---

### Step 7: 재테스트

**질문**: "리팩토링 후에도 모든 테스트가 통과하는가?"

**산출물**:
- 리팩토링 후 테스트 통과 확인
- 회귀 버그 없음 검증

**Checklist 작성법**:

```markdown
## Step 7: 재테스트

### 전체 검증 재실행

```bash
# 1. 정적 검증
ruff check src/auth/jwt.py tests/test_jwt_token.py
mypy src/auth/jwt.py tests/test_jwt_token.py
import-linter

# 2. 테스트 + 커버리지
pytest tests/test_jwt_token.py \
    --cov=src/auth/jwt \
    --cov-report=term-missing \
    --cov-fail-under=95

### 최종 확인

- [ ] ruff 0 violations
- [ ] mypy 0 errors
- [ ] import-linter 0 violations
- [ ] pytest 모든 테스트 통과
- [ ] coverage 95%+ 달성

### 실패 시 조치

- Step 6 리팩토링 재검토
- 깨진 테스트 수정
- 모든 검증 통과할 때까지 Step 6-7 반복
```

**도구**: ruff, mypy, import-linter, pytest

---

### Step 8: 문서화

**질문**: "다른 개발자가 이 코드를 쉽게 사용할 수 있는가?"

**산출물**:
- Google 스타일 docstring
- 사용 예시 코드
- 필요 시 README 업데이트

**Checklist 작성법**:

````markdown
## Step 8: 문서화

### Docstring 작성 (Google 스타일)

```python
def create_token(user_id: str) -> str:
    """JWT 액세스 토큰을 생성합니다.

    Args:
        user_id: 사용자 고유 ID (UUID 또는 문자열)

    Returns:
        JWT 토큰 문자열. 1시간 후 만료됩니다.

    Raises:
        ValueError: user_id가 빈 문자열인 경우

    Example:
        >>> token = create_token("user123")
        >>> print(token)
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'

        >>> # 토큰 검증
        >>> decoded = jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])
        >>> print(decoded["user_id"])
        'user123'
    """
    if not user_id:
        raise ValueError("user_id cannot be empty")

    payload = _create_payload(user_id)
    return jwt.encode(payload, settings.jwt_secret, algorithm=JWT_ALGORITHM)
```

### 사용 예시 (README.md 또는 별도 파일)

## JWT 토큰 생성 사용법

### 기본 사용

```python
from src.auth.jwt import create_token

# 토큰 생성
token = create_token("user123")

# API 응답에 포함
response = {
    "access_token": token,
    "token_type": "Bearer",
    "expires_in": 3600,
}
```

### 주의사항
- 토큰은 1시간 후 자동 만료됩니다
- settings.jwt_secret은 환경변수로 설정해야 합니다
- Production에서는 반드시 HTTPS 사용
````

**도구**: Task 문서 Section 4 (입력/출력)

---

### Step 9: 커밋

**질문**: "변경사항을 Git에 안전하게 기록할 준비가 되었는가?"

**산출물**:
- Git commit with conventional commit message
- Pre-commit hooks 통과

**Checklist 작성법**:

````markdown
## Step 9: 커밋

### 커밋 전 최종 확인

```bash
# 변경된 파일 확인
git status

# 예상 결과:
# modified:   src/auth/jwt.py
# new file:   tests/test_jwt_token.py
```

### Git 커밋

```bash
# 파일 추가
git add src/auth/jwt.py tests/test_jwt_token.py

# Conventional Commit 메시지로 커밋
git commit -m "feat(auth): Add JWT token generation module

- Implement create_token() function with HS256 algorithm
- Add 3 test cases (success/expired/invalid secret)
- Achieve 100% test coverage
- Add comprehensive docstring with usage examples

Closes T2.1.1"
```

### Pre-commit Hook 검증

Pre-commit hooks가 자동 실행됩니다:

- ✅ ruff check
- ✅ mypy
- ✅ import-linter
- ✅ pytest --cov-fail-under=95

**모든 hook 통과 시**: 커밋 성공
**Hook 실패 시**: Step 4-7 재실행

### Conventional Commit 형식

- `feat`: 새 기능
- `fix`: 버그 수정
- `refactor`: 리팩토링
- `test`: 테스트 추가
- `docs`: 문서화
````

**도구**: git, pre-commit hooks

---

## 4. Checklist 템플릿

아래 템플릿을 복사해서 각 Task마다 Checklist를 작성하세요.

````markdown
# Checklist: {Task ID} - {Task 이름}

> **Task 문서**: `docs/tasks/{Task_ID}.md`
> **생성일**: YYYY-MM-DD
> **예상 소요**: {Task 문서 Section 8 참조}

---

## Step 1: 목표 이해

### Task 목표
{Task 문서 Section 4: 입력/출력}

### 성공 기준
{Task 문서 Section 6: 완성 기준}

---

## Step 2: 테스트 작성

### 테스트 케이스

**성공 케이스**:

```python
def test_{function_name}_success():
    # Given:

    # When:

    # Then:
```

**실패 케이스**:

```python
def test_{function_name}_failure():
    # Given:

    # When:

    # Then:
```

**엣지 케이스**:

```python
def test_{function_name}_edge():
    # Given:

    # When:

    # Then:
```

### 파일 생성

- `tests/test_{module}.py` 생성

---

## Step 3: 구현

### 구현 위치

{Task 문서 Section 7: 구현 힌트}

### 구현 코드

```python
{실제 구현 코드}
```

### 프로젝트 표준 준수

{Task 문서 Section 2: 프로젝트 표준 참조}

---

## Step 4: 정적 검증

### 검증 명령어

```bash
ruff check {파일 경로}
mypy {파일 경로}
import-linter
```

### 기대 결과

- [ ] ruff 0 violations
- [ ] mypy 0 errors
- [ ] import-linter 0 violations

---

## Step 5: 테스트 실행

### 테스트 실행 명령어

```bash
pytest {테스트 파일} \
    --cov={모듈 경로} \
    --cov-report=term-missing \
    --cov-fail-under=95
```

### 기대 결과

- [ ] 모든 테스트 통과
- [ ] Coverage 95%+ 달성

---

## Step 6: 리팩토링

### 리팩토링 체크리스트

- [ ] 함수 길이 50줄 이하
- [ ] 중첩 depth 3 이하
- [ ] 변수명 명확
- [ ] 매직 넘버 제거
- [ ] 중복 코드 제거

---

## Step 7: 재테스트

### 전체 검증 재실행

```bash
ruff check {파일들}
mypy {파일들}
import-linter
pytest {테스트 파일} --cov={모듈} --cov-fail-under=95
```

### 최종 확인

- [ ] ruff 0 violations
- [ ] mypy 0 errors
- [ ] import-linter 0 violations
- [ ] pytest 모든 테스트 통과
- [ ] coverage 95%+ 달성

---

## Step 8: 문서화

### Docstring (Google 스타일)

```python
def {function_name}({args}):
    """{한 줄 요약}.

    Args:
        {arg}: {설명}

    Returns:
        {반환값 설명}

    Raises:
        {예외}: {발생 조건}

    Example:
        >>> {사용 예시}
    """
```

### 사용 예시

```python
{실제 사용 예시 코드}
```

---

## Step 9: 커밋

### Git 커밋

```bash
git add {파일들}

git commit -m "feat({scope}): {요약}

- {변경사항 1}
- {변경사항 2}

Closes {Task ID}"
```

### Pre-commit Hook 검증

- [ ] ruff check 통과
- [ ] mypy 통과
- [ ] import-linter 통과
- [ ] pytest 통과

---

## 완료 확인

- [ ] 9 Steps 모두 완료
- [ ] 모든 품질 기준 만족
- [ ] Git commit 성공
````

---

## 5. 실전 예시: Task T2.1.1 → Checklist

Task 문서에서 Checklist로 변환하는 과정을 보여드립니다.

### Task 문서 (요약)

```
# Task T2.1.1: JWT 토큰 생성 모듈

## 1. 📘 청사진 참조
Blueprint Line 145-178

## 2. 📋 프로젝트 표준 참조
PROJECT_STANDARDS.md Line 12-25 (structlog)
PROJECT_STANDARDS.md Line 45-58 (Pydantic Settings)

## 3. 🔧 사용 도구
- PyJWT

## 4. 📦 입력/출력
**입력**: user_id: str
**출력**: token: str - JWT 액세스 토큰

## 5. 🔗 조립 정보
**이 블럭을 사용하는 Task**: T2.2.1, T2.2.3
**이 블럭이 사용하는 Task**: 없음

## 6. 🎯 완성 기준
- [ ] create_token(user_id) 함수 완전 작동
- [ ] pytest 테스트 3개 통과
- [ ] ruff 0, mypy 0, coverage 95%+

## 7. 💡 구현 힌트
```python
def create_token(user_id: str) -> str:
    payload = {
        "user_id": user_id,
        "exp": datetime.utcnow() + timedelta(hours=1),
    }
    return jwt.encode(payload, settings.jwt_secret, algorithm="HS256")

## 8. ⏱️ 예상 작업 시간

2-3 hours
```

### Checklist (완성본)

````markdown
# Checklist: T2.1.1 - JWT 토큰 생성 모듈

> **Task 문서**: `docs/tasks/T2.1.1_JWT_Token_Generation.md`
> **생성일**: 2025-01-09
> **예상 소요**: 2-3 hours

---

## Step 1: 목표 이해

### Task 목표
- **입력**: `user_id: str` - 사용자 고유 ID
- **출력**: `token: str` - JWT 액세스 토큰 (1시간 유효)

### 성공 기준
- [ ] `create_token(user_id)` 함수 완전 작동
- [ ] pytest 테스트 3개 통과 (성공/만료/잘못된 시크릿)
- [ ] ruff 0, mypy 0, coverage 95%+

---

## Step 2: 테스트 작성

### 테스트 케이스

**성공 케이스**:
```python
def test_create_token_success():
    # Given: 유효한 사용자 ID
    user_id = "user123"

    # When: 토큰 생성
    token = create_token(user_id)

    # Then: 유효한 JWT 토큰 반환
    assert isinstance(token, str)
    decoded = jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])
    assert decoded["user_id"] == user_id
    assert "exp" in decoded
```
**실패 케이스**:

```python
def test_create_token_expired():
    # Given: 만료된 토큰
    with freeze_time("2025-01-01 12:00:00"):
        token = create_token("user123")

    # When: 1시간 후 검증
    with freeze_time("2025-01-01 13:00:01"):
        # Then: ExpiredSignatureError 발생
        with pytest.raises(jwt.ExpiredSignatureError):
            jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])
```

**엣지 케이스**:

```python
def test_create_token_invalid_secret():
    # Given: 유효한 토큰
    token = create_token("user123")

    # When: 잘못된 시크릿으로 검증
    # Then: InvalidSignatureError 발생
    with pytest.raises(jwt.InvalidSignatureError):
        jwt.decode(token, "wrong_secret", algorithms=["HS256"])
```

### 파일 생성

- `tests/auth/test_jwt_token.py` 생성
- 위 테스트 케이스 3개 작성

---

## Step 3: 구현

### 구현 위치

- **파일**: `src/auth/jwt.py`
- **함수**: `create_token(user_id: str) -> str`

### 구현 코드

```python
"""JWT 토큰 생성 및 검증 모듈."""
from datetime import datetime, timedelta
import jwt
from src.config import settings

# 상수 정의
TOKEN_EXPIRY_HOURS = 1
JWT_ALGORITHM = "HS256"


def create_token(user_id: str) -> str:
    """JWT 액세스 토큰을 생성합니다.

    Args:
        user_id: 사용자 고유 ID

    Returns:
        JWT 토큰 문자열 (1시간 유효)

    Raises:
        ValueError: user_id가 빈 문자열인 경우
    """
    if not user_id:
        raise ValueError("user_id cannot be empty")

    payload = _create_payload(user_id)
    return jwt.encode(payload, settings.jwt_secret, algorithm=JWT_ALGORITHM)


def _create_payload(user_id: str) -> dict:
    """JWT payload를 생성합니다.

    Args:
        user_id: 사용자 고유 ID

    Returns:
        JWT payload 딕셔너리
    """
    return {
        "user_id": user_id,
        "exp": datetime.utcnow() + timedelta(hours=TOKEN_EXPIRY_HOURS),
    }
```

### 프로젝트 표준 준수

**참조**: Task 문서 Section 2

- ✅ **structlog**: 에러 발생 시 structlog 사용 (이 모듈은 에러 로깅 불필요)
- ✅ **Pydantic Settings**: `settings.jwt_secret` 사용
- ✅ **Type hints**: 100% 타입 힌트 적용

---

## Step 4: 정적 검증

### 검증 명령어

```bash
# 1. Ruff 검사
ruff check src/auth/jwt.py tests/auth/test_jwt_token.py

# 2. MyPy 검사
mypy src/auth/jwt.py tests/auth/test_jwt_token.py

# 3. Import Linter 검사
import-linter
```

### 기대 결과

- [ ] ruff 0 violations
- [ ] mypy 0 errors
- [ ] import-linter 0 violations (auth 모듈은 domain 계층 의존성 없음)

### 위반 발견 시 조치

**Ruff 위반 예시**:

```bash
# 자동 수정
ruff check --fix src/auth/jwt.py
```

**MyPy 에러 예시**:

```python
# ❌ Before
def create_token(user_id):
    return jwt.encode(...)

# ✅ After
def create_token(user_id: str) -> str:
    return jwt.encode(...)
```

---

## Step 5: 테스트 실행

### 테스트 실행 명령어

```bash
pytest tests/auth/test_jwt_token.py \
    --cov=src/auth/jwt \
    --cov-report=term-missing \
    --cov-fail-under=95 \
    -v
```

### 기대 결과

```
tests/auth/test_jwt_token.py::test_create_token_success PASSED         [ 33%]
tests/auth/test_jwt_token.py::test_create_token_expired PASSED         [ 66%]
tests/auth/test_jwt_token.py::test_create_token_invalid_secret PASSED  [100%]

---------- coverage: platform darwin, python 3.11 ----------
Name                Stmts   Miss  Cover   Missing
-------------------------------------------------
src/auth/jwt.py        15      0   100%
-------------------------------------------------
TOTAL                  15      0   100%

Required test coverage of 95% reached. Total coverage: 100.00%
```

### 체크리스트

- [ ] 모든 테스트 통과 (3/3)
- [ ] Coverage 95%+ 달성 (100%)
- [ ] Missing 라인 없음

---

## Step 6: 리팩토링

### 리팩토링 체크리스트

**코드 구조**:

- [x] 함수 길이 50줄 이하 (create_token: 10줄, _create_payload: 5줄)
- [x] 중첩 depth 3 이하 (최대 depth: 1)
- [x] 하나의 함수는 하나의 책임만

**가독성**:

- [x] 변수명이 명확한가? (payload, user_id 모두 명확)
- [x] 매직 넘버 제거 (TOKEN_EXPIRY_HOURS, JWT_ALGORITHM 상수화)
- [x] 복잡한 조건문 함수로 추출 (해당 없음)

**중복 제거**:

- [x] 반복되는 코드 함수로 추출 (_create_payload 분리)
- [x] 공통 상수 별도 정의 (모듈 최상단에 정의)

### 개선 사항

**개선 전** (Task 문서 구현 힌트):

```python
def create_token(user_id: str) -> str:
    payload = {
        "user_id": user_id,
        "exp": datetime.utcnow() + timedelta(hours=1),
    }
    return jwt.encode(payload, settings.jwt_secret, algorithm="HS256")
```

**개선 후** (Step 3 구현):

- ✅ 상수 분리 (`TOKEN_EXPIRY_HOURS`, `JWT_ALGORITHM`)
- ✅ Payload 생성 함수 분리 (`_create_payload`)
- ✅ Validation 추가 (`user_id` 빈 문자열 체크)
- ✅ Docstring 추가 (Google 스타일)

---

## Step 7: 재테스트

### 전체 검증 재실행

```bash
# 1. 정적 검증
ruff check src/auth/jwt.py tests/auth/test_jwt_token.py
mypy src/auth/jwt.py tests/auth/test_jwt_token.py
import-linter

# 2. 테스트 + 커버리지
pytest tests/auth/test_jwt_token.py \
    --cov=src/auth/jwt \
    --cov-report=term-missing \
    --cov-fail-under=95
```

### 최종 확인

- [ ] ruff 0 violations ✅
- [ ] mypy 0 errors ✅
- [ ] import-linter 0 violations ✅
- [ ] pytest 모든 테스트 통과 (3/3) ✅
- [ ] coverage 100% 달성 ✅

### 회귀 테스트

리팩토링으로 인한 동작 변경 없음 확인:

- [ ] `create_token("user123")` 여전히 유효한 토큰 반환
- [ ] 만료 시간 여전히 1시간
- [ ] 알고리즘 여전히 HS256

---

## Step 8: 문서화

### Docstring (Google 스타일)

**이미 Step 3에서 작성 완료**:

```python
def create_token(user_id: str) -> str:
    """JWT 액세스 토큰을 생성합니다.

    Args:
        user_id: 사용자 고유 ID

    Returns:
        JWT 토큰 문자열 (1시간 유효)

    Raises:
        ValueError: user_id가 빈 문자열인 경우
    """
```

### 사용 예시 추가 (Docstring에 Example 섹션)

```python
def create_token(user_id: str) -> str:
    """JWT 액세스 토큰을 생성합니다.

    Args:
        user_id: 사용자 고유 ID

    Returns:
        JWT 토큰 문자열 (1시간 유효)

    Raises:
        ValueError: user_id가 빈 문자열인 경우

    Example:
        >>> from src.auth.jwt import create_token
        >>> token = create_token("user123")
        >>> print(token[:20])  # 토큰 앞부분 출력
        'eyJhbGciOiJIUzI1NiI...'

        >>> # 토큰 검증 예시
        >>> import jwt
        >>> from src.config import settings
        >>> decoded = jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])
        >>> print(decoded["user_id"])
        'user123'
    """
```

### README 업데이트 (필요 시)

`docs/auth/JWT_USAGE.md` 생성:

```markdown
# JWT 토큰 사용 가이드

## 개요
이 모듈은 HS256 알고리즘을 사용하여 JWT 액세스 토큰을 생성합니다.

## 기본 사용법

### 토큰 생성
\```python
from src.auth.jwt import create_token

token = create_token("user123")
print(f"Generated token: {token}")
\```

### 토큰 검증
\```python
import jwt
from src.config import settings

try:
    decoded = jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])
    user_id = decoded["user_id"]
    print(f"Valid token for user: {user_id}")
except jwt.ExpiredSignatureError:
    print("Token expired")
except jwt.InvalidSignatureError:
    print("Invalid token")
\```

## 설정

### 환경 변수
\```bash
# .env 파일
JWT_SECRET=your-secret-key-here
\```

### Settings 클래스
\```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    jwt_secret: str

settings = Settings()
\```

## 주의사항
- ⚠️ `JWT_SECRET`은 최소 32자 이상 강력한 암호를 사용하세요
- ⚠️ Production 환경에서는 반드시 HTTPS를 사용하세요
- ⚠️ 토큰은 1시간 후 자동 만료됩니다 (Refresh token 구현 권장)

## 관련 Task
- **T2.2.1**: JWT 토큰 검증 모듈
- **T2.2.3**: Login 엔드포인트 (이 모듈 사용)
```

---

## Step 9: 커밋

### 커밋 전 최종 확인

```bash
# 변경된 파일 확인
git status

# 예상 결과:
# new file:   src/auth/jwt.py
# new file:   tests/auth/test_jwt_token.py
# new file:   docs/auth/JWT_USAGE.md
```

### Git 커밋

```bash
# 파일 추가
git add src/auth/jwt.py tests/auth/test_jwt_token.py docs/auth/JWT_USAGE.md

# Conventional Commit 메시지로 커밋
git commit -m "feat(auth): Add JWT token generation module

- Implement create_token() function with HS256 algorithm
- Add TOKEN_EXPIRY_HOURS and JWT_ALGORITHM constants
- Extract _create_payload() for better testability
- Add 3 test cases: success, expired, invalid secret
- Achieve 100% test coverage
- Add comprehensive docstring with usage examples
- Create JWT usage guide documentation

Standards compliance:
- ruff 0 violations
- mypy 0 errors
- import-linter 0 violations
- pytest coverage 100%

Closes T2.1.1"
```

### Pre-commit Hook 검증

Pre-commit hooks 자동 실행:

```
[ruff] ................................................ Passed
[mypy] ................................................ Passed
[import-linter] ....................................... Passed
[pytest] .............................................. Passed
  - All tests passed (3/3)
  - Coverage: 100%
[commit-msg] .......................................... Passed
```

### 커밋 성공 확인

```bash
git log -1 --oneline
# f8a9c21 feat(auth): Add JWT token generation module

git show --stat
# 파일 변경 내역 확인
```

---

## 완료 확인

- [x] Step 1: 목표 이해 완료
- [x] Step 2: 테스트 3개 작성 완료
- [x] Step 3: 구현 완료 (create_token, _create_payload)
- [x] Step 4: 정적 검증 통과 (ruff 0, mypy 0, import-linter 0)
- [x] Step 5: 테스트 실행 통과 (100% coverage)
- [x] Step 6: 리팩토링 완료 (상수 분리, 함수 분리)
- [x] Step 7: 재테스트 통과 (모든 검증 재확인)
- [x] Step 8: 문서화 완료 (docstring + README)
- [x] Step 9: Git 커밋 성공

### 최종 산출물

✅ `src/auth/jwt.py` - JWT 토큰 생성 모듈 (100% coverage)
✅ `tests/auth/test_jwt_token.py` - 테스트 3개 (모두 통과)
✅ `docs/auth/JWT_USAGE.md` - 사용 가이드
✅ Git commit `f8a9c21` - Task T2.1.1 완료

**Task T2.1.1 완료! 다음 Task로 진행 가능.**
````

---

## 6. Checklist 작성 완료 검증

```markdown
### 완성도 체크리스트

**기본 요구사항**:

- [ ] 9-Step 모두 포함
- [ ] 각 Step마다 질문, 산출물, 도구 명시
- [ ] Task 문서와 명확히 연결 (Section 참조)

**실행 가능성**:

- [ ] AI가 이 Checklist만으로 작업 가능
- [ ] 모든 명령어가 실행 가능 (복사-붙여넣기 가능)
- [ ] 검증 기준이 명확 (✅/❌ 판단 가능)

**Task 문서 연결**:

- [ ] Section 1 (청사진) → Step 1 목표 이해
- [ ] Section 2 (표준) → Step 3, 4 준수 확인
- [ ] Section 3 (도구) → Step 2-5 사용
- [ ] Section 4 (입출력) → Step 1 목표, Step 8 문서화
- [ ] Section 5 (조립) → Step 1 이해 (의존성 파악)
- [ ] Section 6 (완성 기준) → Step 1, 7 검증
- [ ] Section 7 (구현 힌트) → Step 3 구현
- [ ] Section 8 (예상 시간) → Checklist 메타정보

**품질 검증**:

- [ ] Step 4: ruff, mypy, import-linter 명령어 정확
- [ ] Step 5: pytest coverage 명령어 정확
- [ ] Step 6-7: 리팩토링 후 재검증 포함
- [ ] Step 9: Conventional commit 형식 준수

### 흔한 실수 체크

**❌ 피해야 할 패턴**:

- Step 2에서 테스트 작성 없이 "테스트 작성 예정" 표시
- Step 3 구현이 너무 추상적 (실제 코드 없음)
- Step 4-7 검증 명령어 누락
- Step 8 docstring 없이 "문서화 완료" 표시
- Step 9 커밋 메시지가 Conventional Commit 형식 위반

**✅ 올바른 패턴**:

- 모든 Step에 실제 코드 또는 명령어 포함
- 검증 기준이 숫자로 명확 (ruff 0, coverage 95%+)
- Task 문서 내용을 직접 복사-참조
- 예시 코드가 실행 가능
```

## 7. Checklist와 Task 문서의 관계

### 정보 흐름

```markdown
Blueprint (5000 lines, 전체 설계)
    ↓
Task 문서 (100 lines, 이 작업만)
    ├─ Section 1: 청사진 참조 → "Blueprint Line 145-178만 읽어"
    ├─ Section 2: 표준 참조 → "PROJECT_STANDARDS.md Line 12-25만 읽어"
    ├─ Section 3: 도구 → "PyJWT 사용해"
    ├─ Section 4: 입출력 → "user_id 받아서 token 반환해"
    ├─ Section 5: 조립 → "T2.2.1, T2.2.3이 이걸 사용해"
    ├─ Section 6: 완성 기준 → "함수 작동 + 테스트 3개 + 0 위반"
    ├─ Section 7: 구현 힌트 → "이렇게 만들어"
    └─ Section 8: 예상 시간 → "2-3시간"
    ↓
Checklist (실행 지시서)
    ├─ Step 1: Task 문서 이해
    ├─ Step 2: 테스트 작성 (Given-When-Then)
    ├─ Step 3: 구현 (Section 7 힌트 사용)
    ├─ Step 4: 정적 검증 (ruff, mypy, import-linter)
    ├─ Step 5: 테스트 실행 (pytest coverage)
    ├─ Step 6: 리팩토링
    ├─ Step 7: 재테스트
    ├─ Step 8: 문서화
    └─ Step 9: 커밋
    ↓
완성된 코드 + 테스트 + 문서
```
### Necessary Information Only 원칙

**Blueprint (5000 lines)**:
- AI가 읽을 필요 없음 (너무 많음)
- Task 문서가 필요한 부분만 추출함

**Task 문서 (100 lines)**:
- AI가 읽어야 함
- "무엇을" 만들지 정의

**Checklist (실행 단계)**:
- AI가 따라야 함
- "어떻게" 만들지 단계별 지시

**핵심**: AI는 Blueprint를 직접 읽지 않고, Task 문서와 Checklist만으로 작업 완수 가능

---

## ⏪ 이전 Stage 검증 및 수정 프로토콜

### 검증 시점
- 각 Task Checklist 실행 전 Task 문서 검증
- 실행 중 Task 정의 문제 발견 시 즉시 중단

### 검증 대상

| Stage | 산출물 | 검증 항목 |
|-------|--------|----------|
| Stage 8 | 08T-01_*.md | Task 정의가 명확하고 완전? |
| Stage 8 | Task 상세 | 입력/출력/제약/완료 조건 명시? |
| Stage 8 | 의존성 | 선행 Task 완료 상태? |

### 오류 발견 시 프로토콜

```
Stage 9에서 Stage 8 오류 발견 시:

Step 1: Checklist 실행 중단
├─ 발견 위치: Checklist Step [N]
├─ 오류 내용: [구체적 설명]
├─ Task ID: [해당 Task]
└─ 기록: 실행 로그에 기록

Step 2: 오류 유형 판단
├─ Task 크기 문제: 너무 큼/작음 → Stage 8 분할/합치기
├─ Task 정의 불완전: 입출력 누락 → Stage 8 보완
├─ 의존성 오류: 선행 Task 미완료 → 순서 조정
├─ Blueprint 문제: 설계 자체 오류 → Stage 7로 이동!
└─ 분류 완료

Step 3: 해당 Stage로 이동 → 수정
├─ Stage 8 Task 문서 수정
├─ 또는 Stage 7 Blueprint 수정 (심각한 경우)
└─ 수정 검증

Step 4: Stage 9 재진행
├─ 수정된 Task로 Checklist 재작성
├─ Step 1부터 재실행
└─ 품질 기준 확인

Step 5: 검증 → 다음 Task ✅
```

### 흔한 오류 패턴

| 오류 유형 | 예시 | 해결 |
|----------|------|------|
| Task 과대 | Checklist 200줄 초과 | Stage 8에서 분할 |
| 입력 누락 | 참조 파일 경로 없음 | Stage 8 Task 보완 |
| 완료 조건 모호 | "적절히 구현" | Stage 8에서 구체화 |
| 의존성 미해결 | 선행 Task 미완료 | 순서 조정 후 재진행 |

### 추적성

```
수정 이력: docs/revision_log.md
Checklist 버전: v1.0 → v1.1 (수정 시 버전 업)
```

---

## 8. 추가 참고 자료

### 관련 문서
- **CORE_METHODOLOGY.md Section 3**: 9-Step Checklist 상세 설명
- **TASK_BREAKDOWN_GUIDE.md**: Task 문서 작성 방법
- **PROJECT_STANDARDS.md**: 프로젝트 표준 (structlog, Pydantic, 아키텍처 규칙)

### 도구 문서
- **pytest**: https://docs.pytest.org/
- **ruff**: https://docs.astral.sh/ruff/
- **mypy**: https://mypy.readthedocs.io/
- **import-linter**: https://import-linter.readthedocs.io/

### Conventional Commit

```
<type>(<scope>): <subject>

<body>

<footer>
```
**Type**:

- `feat`: 새 기능
- `fix`: 버그 수정
- `refactor`: 리팩토링
- `test`: 테스트 추가
- `docs`: 문서화

**Scope**: 변경된 모듈 (auth, payment, user 등)

**Footer**: `Closes T2.1.1` 형식으로 Task 참조

---

## 마무리

이 가이드를 사용하여:
1. **Task 문서 읽기** (TASK_BREAKDOWN_GUIDE 참조)
2. **Checklist 템플릿 복사** (Section 4)
3. **9-Step 순서대로 작성** (Section 3 참조)
4. **실전 예시 참고** (Section 5)
5. **검증 체크리스트 확인** (Section 6)

**핵심 원칙**:
- ✅ **실행 가능**: 모든 명령어가 복사-붙여넣기 가능
- ✅ **자급자족**: Task 문서 + Checklist만으로 완수 가능
- ✅ **검증 가능**: 0 violations, 95%+ coverage 명확히 확인

Happy coding! 🚀


================================================================================
