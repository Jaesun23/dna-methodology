# DNA Methodology 상세 문서

> **목적**: 00_CORE_METHODOLOGY.md의 각 Part를 상세하게 풀어쓴 실행 가이드
> **용도**: 실제 작업 시 참조, Stage별 가이드 작성의 기준
> **작성일**: 2025-12-02

## 목차

### Part 1: AI 협업의 문제와 해결

#### 		1.1 Context Rot (문맥 부패) - 핵심 문제

#### 		1.2 AI의 6가지 문제점

### Part 2: DNA 방법론 핵심 

#### 		2.1 DNA 4대 핵심 원칙

#### 		2.2 핵심 1: "부분으로 전체를 완성"

#### 		2.3 핵심 2: "환경으로 제어"

#### 		2.4 추적성 메커니즘: Stage 간 연결

### Part 3: Stage 1-2 분류와 조사

#### 		3.1 Stage 1: 패밀리 분류

#### 		3.2 Stage 2: 환경 제약 조사

### Part 4: Stage 3 결정 문서화 - ADR 

#### 		4.1 ADR의 역할과 위치

#### 		4.2 5대 ADR 카테고리

### Part 5: Stage 4-6 Bridge - 환경 구축

#### 		5.1 Bridge의 의미

#### 		5.2 Stage 4: DNA 시스템 청사진

#### 		5.3 Stage 5: DNA 시스템 구현

#### 		5.4 Stage 6: Project Standards

### Part 6: Stage 7-9 Blueprint → 구현

#### 		6.1 Stage 7: Project Blueprint

#### 		6.2 Stage 8: Task Breakdown

#### 		6.3 Stage 9: Checklist + 구현

### Part 7: AI 협업 기법

#### 		7.1 인지 글쓰기 이론 기반

#### 		7.2 Skeleton-of-Thought (SoT) - 구조 우선

#### 		7.3 Chain of Density (CoD) - 정보 밀도 증가

#### 		7.4 Tree of Thoughts (ToT) - 대안 탐색

#### 		7.5 RDoLT - 난이도별 분해

#### 		7.6 Stage별 기법 적용 요약

---

## Part 1: AI 협업의 문제와 해결

### 1.1 Context Rot (문맥 부패) - 핵심 문제

#### 정의
대화가 길어질수록 초기에 설정한 원칙, 규칙, 컨텍스트의 영향력이 점진적으로 약화되는 현상.

#### 발생 메커니즘

```
세션 시작
├─ 원칙 A 설정 (영향력 100%)
├─ 작업 1 진행
├─ 작업 2 진행
├─ ... (컨텍스트 누적)
├─ 작업 N 진행
└─ 원칙 A의 영향력 → 30% 이하로 감소

원인:
1. Transformer 모델의 Attention 메커니즘
   - 최근 토큰에 더 높은 가중치
   - 초기 토큰의 영향력 감소

2. 컨텍스트 윈도우 한계
   - 물리적 토큰 제한
   - 오래된 내용 truncation

3. 정보 희석
   - 새로운 정보가 추가될수록
   - 기존 정보의 상대적 비중 감소
```

#### 증상 (실제 경험 기반)

| 증상 | 설명 | 실제 사례 |
|------|------|----------|
| **최신성 편향** | 최근 대화 내용에 과도하게 집중 | "방금 말한 것만 기억하고 처음 합의한 건 무시" |
| **Lost in the Middle** | 중간에 언급된 내용을 놓침 | "10개 규칙 중 3-7번을 자주 빠뜨림" |
| **환각 가속화** | 컨텍스트 혼란 → 없는 사실 생성 | "이전에 합의했다고 착각하고 임의로 진행" |
| **원칙 망각** | 처음 합의한 규칙을 점점 무시 | "타입 안전성 강조했는데 any 남발" |

#### 해결 전략: 정적/동적 컨텍스트 분리

```
┌─────────────────────────────────────────┐
│ 정적 컨텍스트 (불변)                      │
├─────────────────────────────────────────┤
│ - 아키텍처 원칙                          │
│ - DNA 시스템 규칙                        │
│ - 품질 기준 (Lint 0, Type 0)            │
│ - 프로젝트 표준                          │
│                                         │
│ → 매 세션 시작 시 주입                   │
│ → 절대 변경하지 않음                     │
│ → 파일로 관리 (PROJECT_STANDARDS.md)    │
└─────────────────────────────────────────┘
              ↓ 분리
┌─────────────────────────────────────────┐
│ 동적 컨텍스트 (가변)                      │
├─────────────────────────────────────────┤
│ - 현재 작업 상태                         │
│ - 진행 상황                              │
│ - 이전 세션 결과물                       │
│ - 현재 세션 목표                         │
│                                         │
│ → 세션마다 갱신                          │
│ → 필요한 부분만 로드                     │
│ → JSON으로 상태 관리                     │
└─────────────────────────────────────────┘
```

---

### 1.2 AI의 6가지 문제점

#### 문제 1: Context 한계

```
현상:
- 일정 토큰 수를 넘으면 앞선 내용 망각
- 현재 작업이 전체 어디에 위치하는지 파악 불가
- 많은 정보를 제공해도 "읽었다"고 하지만 실제로는 반영 안 됨

실제 사례:
"500줄짜리 Blueprint를 제공했는데, 
 뒷부분 구현할 때 앞부분 규칙을 완전히 무시함"

해결:
├─ 단위작업 분할 (80-90K 토큰 안전 범위로)
├─ 현재 작업에 필요한 정보만 제공
└─ 전체 맥락은 요약으로 제공
```

#### 문제 2: 회피

```
현상:
- 너무 많은 정보를 대하면 모른 척 하거나 적당히 하다가 멈춤
- 긍정표현 규칙이 많으면: 그냥 좋은 말로 여기고 넘김
- 부정표현 규칙이 많으면: 부담스러워서 포기하고 싶다고 함

실제 사례:
"20개 규칙을 DO/DON'T로 정리해서 줬더니
 '네, 이해했습니다' 하고는 절반도 안 지킴"

해결:
├─ 최소 정보 제공 (현재 작업에 필수적인 것만)
├─ 환경으로 강제 (규칙 대신 pre-commit hook)
└─ 체크리스트로 검증 (자가 점검)
```

#### 문제 3: 자기 과신

```
현상:
- Context 한계가 있다는 것을 인지하지 못함
- 학습 데이터가 최신이 아니라는 걸 모름
- "차근차근 정리하면서" 하자고 해도 "모두 할 수 있다"고 자신감

실제 사례:
"TypeScript 타입 사용 주의하라고 했는데
 '할 수 있습니다!' 하고는 결국 프로젝트 폐기"

해결:
├─ 명확한 범위 제한 ("이 파일만", "이 함수만")
├─ 단계별 확인 (중간 점검 강제)
└─ Context7로 최신 정보 확인 강제
```

#### 문제 4: 불필요하게 과한 작업

```
현상:
- 요청하지 않은 "안정성", "호환성" 작업 추가
- 간단한 수정을 복잡한 리팩토링으로 확대
- 미운영 시스템인데 마이그레이션 전략 수립

실제 사례:
"랜덤값 실험이 필요한데 '안정성'을 이유로 고정값 하드코딩
 → 실패도 실험의 중요한 결과인데!!"

해결:
├─ 목표만 명확히 ("실험용", "프로토타입", "프로덕션")
├─ 범위 벗어나면 "STOP" 명시
└─ "요청하지 않은 작업은 하지 마세요" 명시
```

#### 문제 5: 할루시네이션

```
현상:
- 여러 기능 조사 → 구현 완료 → 그때서야 안 되는 걸 알게 됨
- "사실확인 안 된 사항 사용 금지" 경고해도
- 없는 사실 언급하거나 동의 없이 임의 추정

실제 사례:
"라이브러리 X의 Y 기능을 사용하면 된다고 해서 구현했는데,
 실제로 그 기능은 존재하지 않았음"

해결:
├─ Context7로 공식 문서 확인 강제
├─ "확인 안 된 사항은 '확인 필요'로 표시"
└─ 구현 전 기술 검증 단계 필수
```

#### 문제 6: 압박감/강박

```
현상:
- 컨텍스트 한계를 느끼는지 한 번에 다 해버리려고 함
- 애매모호한 질문 → 잘 대답해야 한다는 생각 → 할루시네이션
- 불완전해도 "완료"라고 보고

실제 사례:
"10개 파일 수정 요청했더니
 처음 3개는 꼼꼼히, 나머지 7개는 대충 처리"

해결:
├─ 단계별 진행 ("먼저 3개만")
├─ 중간 점검 필수 ("여기까지 확인하고 진행")
└─ 명시적 우선순위 ("1,2,3 순서로, 나머지는 다음 세션")
```

---

### 1.3 AI가 최고 성과를 낼 때

```
조건 1: 규모가 크지 않아 전체를 한 번에 계획해서 진행 가능
────────────────────────────────────────────────────────
- 80-90K 토큰 범위 내에서 완료 가능한 작업
- 명확한 시작점과 종료점
- 중간에 외부 의존성 없음

조건 2: 여러 선택지에서 논리적 흐름/근거에 따른 판단 가능
────────────────────────────────────────────────────────
- 선택지가 명확하게 제시됨 (A vs B vs C)
- 각 선택의 장단점이 정리됨
- 판단 기준이 주어짐 (성능 우선? 유지보수 우선?)

조건 3: 요청내용과 결과에 대한 명확한 지침 존재
────────────────────────────────────────────────────────
- 입력: "이 파일을 읽어서"
- 처리: "X 패턴으로 리팩토링하고"
- 출력: "새 파일로 저장해라"
- 검증: "Type Check 0 오류여야 함"

조건 4: 매번 새로운 대화지만 기존 작업을 어떤 방식으로든 이해
────────────────────────────────────────────────────────
- 이전 세션 결과물 제공
- 현재 위치 명시 ("Stage 3의 ADR 4-6번 작성 중")
- 전체 맥락 요약 제공
```

### 1.4 해결책의 근거: 인지 글쓰기 이론

```
인지 글쓰기 이론 (Flower & Hayes, 1981):

┌─────────────────────────────────────────┐
│         글쓰기 = 문제 해결               │
├─────────────────────────────────────────┤
│                                         │
│   기획 (Planning)                       │
│      ↓                                  │
│   작성 (Translating)                    │
│      ↓                                  │
│   검토 (Reviewing)                      │
│      ↓                                  │
│   반복...                               │
│                                         │
└─────────────────────────────────────────┘

AI 협업에 적용:

1. 기획 = 청사진/ADR 작성
   - 전체 구조 설계
   - 결정 사항 문서화

2. 작성 = 구현
   - 체크리스트 기반 실행
   - 단위작업 완료

3. 검토 = 검증
   - 정적 분석 (Lint, Type Check)
   - 테스트 실행
   - 품질 Gate 통과

4. 반복 = 점진적 완성
   - 세션 단위로 진행
   - 누적해서 전체 완성
```

---

## Part 2: DNA 방법론 핵심

### 2.1 DNA 4대 핵심 원칙

DNA 방법론의 성공을 결정하는 4가지 핵심 원칙:

```
┌─────────────────────────────────────────────────────────┐
│              DNA 4대 핵심 원칙                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 🎯 AI 최적 크기                                     │
│     - 80-90K 토큰 = 100-150줄 체크리스트               │
│     - Stage 8이 변환점 (Human-Driven → AI-Driven)      │
│                                                         │
│  2. 🔄 완전해질 때까지 반복                             │
│     - 3단계 검증 (크기, 의존성, 완전성)                 │
│     - "부족함이 없어질 때까지" 재작업                   │
│                                                         │
│  3. 🧩 기능별 분해 + 연결부 + 조립                      │
│     - 레이어별 분해 ❌ → 기능별 분해 ✅                 │
│     - 인터페이스(연결부) 먼저 정의                      │
│     - Task 완료 = 기능 완료 (E2E)                      │
│                                                         │
│  4. ⏪ 역방향 수정 프로토콜                             │
│     - 하위 Stage에서 상위 Stage 오류 발견 시           │
│     - 6단계 프로토콜로 체계적 수정                     │
│     - Stage 7이 가장 Critical (통합의 정점)            │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

#### 원칙 1: AI 최적 크기

```
왜 80-90K 토큰인가?
────────────────────────────────────────────────────────

AI 컨텍스트 윈도우 (예: 200K 토큰)
├─ 시스템 프롬프트: ~30K 토큰
├─ 대화 히스토리: ~20K 토큰
├─ 참조 문서 (Blueprint, Standards): ~50K 토큰
├─ 체크리스트 + 코드: ~20K 토큰
└─ 응답 생성 여유: ~80K 토큰 ← 실제 작업 공간!

Stage 8이 변환점인 이유:
────────────────────────────────────────────────────────
Stage 1-7: Human-Driven (인간 중심)
├─ 문서 크기 제한 없음
├─ 인간의 이해와 의사결정 중심
└─ 컨텍스트 = 인간의 기억력

Stage 8-9: AI-Driven (AI 중심)
├─ AI 컨텍스트 한계 고려 필수!
├─ 80-90K 토큰 내에서 완료 가능해야
└─ 체크리스트 100-150줄 범위
```

#### 원칙 2: 완전해질 때까지 반복

```
3단계 검증 프로토콜:
────────────────────────────────────────────────────────

검증 1: 크기 (Size Check)
├─ 체크리스트 예상 줄 수: 80-180줄?
├─ 예상 시간: 2-4시간?
├─ 생성 파일 수: 1-4개?
└─ 실패 시 → 분할 또는 합치기

검증 2: 의존성 (Dependency Check)
├─ 선행 Task 명확히 정의?
├─ 순환 의존성 없음?
├─ 병렬 실행 가능 Task 식별?
└─ 실패 시 → 의존성 재설계

검증 3: 완전성 (Completeness Check)
├─ 목표: 한 문장으로 명확?
├─ 입력/출력: 모두 명시?
├─ 완료 조건: 측정 가능? (Type 0, Lint 0)
├─ 테스트: 구체적 케이스 3개 이상?
└─ 실패 시 → Task 상세 보완

모든 검증 통과 → Stage 9로 전달 ✅
```

#### 원칙 3: 기능별 분해 + 연결부 + 조립

```
레이어별 분해 vs 기능별 분해:
────────────────────────────────────────────────────────

❌ 레이어별 분해 (Anti-pattern):
Task 001: 모든 엔티티 (Domain Layer)
Task 002: 모든 리포지토리 (Infrastructure)
Task 003: 모든 서비스 (Application)
Task 004: 모든 API (Presentation)

문제: Task 001 완료해도 "작동하는 기능" 없음!

✅ 기능별 분해 (Best Practice):
Task 001: User 기능 (Entity→Repo→Service→API)
Task 002: Order 생성 기능 (E2E)
Task 003: Order 조회 기능 (E2E)

장점: Task 001 완료 = User 기능 작동!

연결부 (Interface) 먼저 정의:
────────────────────────────────────────────────────────
Task 000: 인터페이스 정의
├─ IUserRepository
├─ IOrderRepository
├─ IUserService
└─ IOrderService

이후 Task는 인터페이스 구현 + E2E 작동!
```

#### 원칙 4: 역방향 수정 프로토콜

```
하위 Stage에서 상위 Stage 오류 발견 시:
────────────────────────────────────────────────────────

6단계 프로토콜:

Step 1: 오류 발견 및 문서화
Step 2: 영향 범위 파악 (가장 중요!)
Step 3: 해당 Stage로 이동 → 수정
Step 4: 중간 Stage 전파
Step 5: 현재 Stage 재진행
Step 6: 재진행 결과 검증

Stage 7이 가장 Critical:
────────────────────────────────────────────────────────
├─ Stage 1-6의 모든 결과물이 여기서 통합
├─ 오류 미발견 시 → Stage 8-9 전체 재작업
├─ 오류 수정 시 → Blueprint만 수정 (2-3시간)
└─ 비용 차이: 10배+

추적성:
────────────────────────────────────────────────────────
수정 이력 파일: docs/revision_log.md
각 수정마다 기록: 발견 Stage, 영향 범위, 수정 내용
```

---

### 2.2 핵심 1: "부분으로 전체를 완성"

#### 레고블럭 전략의 이론적 기반

```
Kent Beck의 Augmented Coding (2024):

"AI는 200K 컨텍스트 내에서 완전한 작업을 수행할 때 최고 성과"

DNA 방법론 적용:
├─ Task = 레고블럭 (독립 테스트 가능)
├─ 각 블럭이 완벽하면 전체가 완벽
└─ 블럭 간 인터페이스만 명확하면 됨
```

#### 단위작업 분할의 4가지 질문

**Q1: 컨텍스트 한계를 고려했는가?**

```
💡 핵심 원칙: 숫자는 참고일 뿐! 작업을 완전하게 설명하는 게 우선

에이전트 컨텍스트 기준 (200K, Compact 없음):
├─ 안전 범위: 80-90K 토큰
├─ 체크리스트: 100-150줄 범위 (120줄 내외 권장)
├─ ADR: 세션당 3개 이하
├─ Task: 세션당 1개 (복잡) ~ 3개 (단순)

컨텍스트 계산 근거 (에이전트 기준):
├─ Base (시스템 + 에이전트 정의): ~41K
├─ 읽기 (체크리스트 + 참조문서): ~7.5K
├─ 쓰기 (생각 정리 + 코드 작성): ~22K
├─ 실행/디버그 (테스트 + 수정): ~15K
└─ 총합: ~85.5K (120줄 체크리스트 기준)

⚠️ 중요 - AI 모델별 차이:
├─ 일부 AI: Compact 기능으로 긴 작업 가능
├─ 일부 AI: Compact 없음 → 컨텍스트가 hard limit
└─ Task 크기는 에이전트 기준으로 계산!

컨텍스트 안전 범위:
├─ 80K: 안정적 ✅ (권장)
├─ 90K: 빡빡함 ⚠️ (가능하지만 여유 부족)
├─ 100K+: 위험 ❌ (급히 종료 가능성)
└─ 180K+: 매우 위험 💥 (급히 종료 후 "완료" 보고)
```

**Q2: 의미있는 산출물을 생산하는가?**

```
"의미있는" 기준:
├─ 독립적으로 테스트/검증 가능
├─ 다른 작업 없이도 가치 있음
├─ 명확한 완료 조건 존재
└─ 롤백 가능 (실패해도 다른 부분 영향 없음)

좋은 예:
✅ "User 엔티티 생성 + 테스트" → 독립 검증 가능
✅ "로그인 API 구현 + 테스트" → 독립 실행 가능

나쁜 예:
❌ "User 엔티티 절반 작성" → 검증 불가
❌ "전체 인증 시스템 구현" → 너무 큼
```

**Q3: 일관성을 유지하는가?**

```
일관성 유지 방법:
├─ 동일한 템플릿 사용 (ADR, 체크리스트)
├─ 동일한 코딩 패턴 (Repository, Service)
├─ 동일한 네이밍 컨벤션
├─ 동일한 품질 기준 (Lint 0, Type 0)
└─ 동일한 검증 절차

구현:
- PROJECT_STANDARDS.md → 매 세션 주입
- pre-commit hooks → 자동 강제
- 템플릿 파일 → 복사해서 사용
```

**Q4: 누락이 없는가?**

```
누락 방지 방법:
├─ 전체 목록 먼저 작성 (Blueprint)
├─ 체크리스트로 관리
├─ 완료/미완료 상태 추적
└─ 다음 세션 가이드 제공

추적 방법:
- task_status.json (상태 관리)
- 각 문서의 "다음 작업" 섹션
- Blueprint의 완료 체크박스
```

---

### 2.3 핵심 2: "환경으로 제어"

#### 왜 문서화된 규칙이 실패하는가

```
실패 패턴:

1. 규칙 문서 제공 (20개 DO/DON'T)
      ↓
2. AI: "네, 이해했습니다"
      ↓
3. 구현 시작
      ↓
4. 규칙 50% 이상 위반
      ↓
5. 수정 요청
      ↓
6. 일부 수정, 새로운 위반 발생
      ↓
7. 무한 반복... 또는 포기

원인:
├─ AI는 규칙을 "참조"하지 "강제"하지 않음
├─ 긍정 표현 → "좋은 조언" 정도로 인식
├─ 부정 표현 → 부담감 → 회피
└─ 많은 규칙 → 우선순위 혼란
```

#### 환경 구축의 원리

```
"조심해라" (X) → "못하게 막는다" (O)

┌─────────────────────────────────────────────────────┐
│ 규칙: "print() 사용 금지"                            │
├─────────────────────────────────────────────────────┤
│ ❌ 문서: "print() 대신 logger를 사용하세요"          │
│    → AI가 읽고도 print() 사용                       │
│                                                     │
│ ✅ 환경:                                            │
│    1. src/core/logging/ 제공 (표준 로거)            │
│    2. pre-commit hook: print() 감지 → 커밋 차단    │
│    3. Lint 규칙: print 금지                         │
│    → 물리적으로 print()가 들어간 코드 커밋 불가     │
└─────────────────────────────────────────────────────┘
```

#### DNA 시스템 = 환경 구축의 구체화

```
DNA 11개 시스템 = 프로젝트 전체에 적용되는 "환경"

각 시스템의 역할:
├─ 표준 도구 제공 (바퀴 재발명 방지)
├─ 사용 패턴 강제 (일관성 확보)
├─ 자동 검증 (품질 보장)
└─ 위반 시 차단 (강제력)

예시 - Logging 시스템:
┌─────────────────────────────────────────┐
│ src/core/logging/                       │
│ ├─ logger.* (표준 로깅 래퍼)            │
│ ├─ config.* (로그 레벨, 포맷)          │
│ └─ handlers.* (파일, 콘솔, JSON)       │
├─────────────────────────────────────────┤
│ 사용 강제:                              │
│ - import logger from core.logging      │
│ - logger.info(), logger.error()        │
│ - print() → Lint 오류                  │
├─────────────────────────────────────────┤
│ 자동 제공:                              │
│ - trace_id (분산 추적)                 │
│ - 구조화된 JSON 로그                   │
│ - 로그 레벨별 필터링                   │
└─────────────────────────────────────────┘
```

---

### 2.4 추적성 메커니즘: Stage 간 연결

#### 왜 추적성이 필요한가

```
문제:
├─ Stage 3에서 결정한 사항이 Stage 7에서 무시됨
├─ Stage 6 표준이 Stage 9 체크리스트에 반영 안 됨
├─ 하위 Stage에서 문제 발견 → 상위 Stage 수정 필요
└─ 어디서 뭘 바꿔야 하는지 추적 불가

해결: 명시적 참조 체계
```

#### Stage 간 참조 형식

```
참조 형식: [문서ID] Ln [라인번호] 또는 Section [섹션명]

예시 흐름:

Stage 6 (PROJECT_STANDARDS.md):
┌─────────────────────────────────────────┐
│ ## 6.3 Database Standards (Ln 45-60)   │
│                                         │
│ - 모든 테이블 PK는 UUIDv7 사용          │
│ - created_at, updated_at 필수          │
│ - soft delete 사용 (deleted_at)        │
└─────────────────────────────────────────┘
         ↓ 참조
Stage 7 (07B-01_blueprint.md):
┌─────────────────────────────────────────┐
│ ## User Entity                          │
│ Ref: PROJECT_STANDARDS.md Ln 45-60     │
│                                         │
│ - id: UUIDv7 (PK)                      │
│ - created_at: datetime                 │
│ - updated_at: datetime                 │
│ - deleted_at: datetime (nullable)      │
└─────────────────────────────────────────┘
         ↓ 참조
Stage 9 (09L-001_user_entity.md):
┌─────────────────────────────────────────┐
│ ## Step 2: 테스트 작성                  │
│ Ref: 07B-01 Section "User Entity"      │
│                                         │
│ 검증 항목:                              │
│ - [ ] id가 UUIDv7 형식인가?            │
│ - [ ] created_at 자동 설정되는가?      │
│ - [ ] soft delete 동작하는가?          │
└─────────────────────────────────────────┘
```

#### 핫픽스 루프 (양방향 피드백)

```
정방향 (Top-Down):
Stage 3 → Stage 6 → Stage 7 → Stage 9 → 구현

역방향 (Bottom-Up) - 문제 발견 시:

구현 중 문제 발견
      ↓
"UUIDv7이 PostgreSQL 14에서 네이티브 지원 안 됨"
      ↓
Stage 9 체크리스트에 메모
      ↓
Stage 7 Blueprint 수정 요청
      ↓
Stage 6 Standards 재검토
      ↓
Stage 3 ADR 수정 (ADR-007: UUID 전략 변경)
      ↓
변경 사항 하향 전파
      ↓
Stage 5-6 업데이트 → Stage 7 업데이트 → Stage 9 업데이트

핫픽스 문서화:
┌─────────────────────────────────────────┐
│ ## Hotfix Log                           │
│                                         │
│ HF-001 (2024-01-15):                   │
│ - 원인: PostgreSQL 14 UUIDv7 미지원    │
│ - 영향: ADR-007, STANDARDS Ln 45-60    │
│ - 해결: UUID v4 + 별도 timestamp 컬럼  │
│ - 적용: Stage 6, 7, 9 문서 수정 완료   │
└─────────────────────────────────────────┘
```

---

## Part 3: Stage 1-2 분류와 조사

### 3.1 Stage 1: 패밀리 분류

#### 목표
시스템의 본질적 특성을 파악하여 7가지 패밀리 중 하나로 분류

#### 10가지 ADQ (Architecture-Driving Questions) 상세

**Part 0: 핵심 기능 파악 (ADQ 전 필수)**

```
Q0: "이 시스템은 무엇을 하기 위한 시스템인가?"
────────────────────────────────────────────────────────
목적: 시스템의 존재 이유, 원자적 핵심 기능 정의

핵심 원칙: "구현 방식"이 아닌 "본질적 기능"으로 정의

❌ 잘못된 예:
├─ 수동 거래 (기능 1)
├─ 자동 거래 (기능 2)
└─ 조건 감시 (기능 3)
→ 이건 "구현 방식"의 나열

✅ 올바른 예:
├─ 핵심 기능: 거래 (Trade)
│   ├─ 구현 방식 A: 수동 (사용자 직접)
│   ├─ 구현 방식 B: 자동 (시스템 자동)
│   └─ 구현 방식 C: 조건부 (조건 충족 시)
└─ 비즈니스 목적: 사용자가 원하는 조건에 주식을 매매

질문 체크리스트:
├─ "이 시스템이 없으면 사용자는 무엇을 못하나?"
├─ "한 문장으로 시스템을 설명한다면?"
└─ "가장 중요한 단 하나의 기능은?"

예시:
- 이커머스: "상품 거래" (검색, 장바구니, 결제는 구현 방식)
- 채팅 앱: "메시지 전달" (그룹채팅, 파일공유는 구현 방식)
- 예약 시스템: "일정 예약" (알림, 결제는 구현 방식)
```

**카테고리 A: 비즈니스 가치**

```
Q1: "이 시스템이 1시간 동안 멈추면 어떤 일이 일어나나요?"
────────────────────────────────────────────────────────
목적: 실패의 치명도 판단 (Layer 1 - 실패 영향)

답변 유형:
├─ 치명적 (A): "거래 손실", "인명 피해", "법적 책임"
├─ 심각 (B): "매출 감소", "고객 불만", "경쟁사 이탈"
└─ 경미 (C): "불편함", "지연", "대체 수단 존재"

예시:
- 주식 거래 플랫폼: "1시간 정지 = 수억 원 손실" → A
- 블로그 서비스: "1시간 정지 = 불편하지만 치명적이진 않음" → C
- 병원 예약 시스템: "1시간 정지 = 환자 대기, 심각한 불편" → B

Q2: "고객이 이 시스템에서 가장 중요하게 생각하는 것은?"
────────────────────────────────────────────────────────
목적: 핵심 품질 속성 식별 (Layer 2 - NFR 우선순위)

답변 유형:
├─ 속도: "빨라야 함", "즉시 응답"
├─ 정확성: "틀리면 안 됨", "100% 정확해야"
├─ 가용성: "항상 접속 가능해야", "24/7"
├─ 보안: "절대 유출되면 안 됨"
└─ 비용: "저렴해야 함", "운영비 최소화"

예시:
- 검색 엔진: "속도" (0.1초 내 결과)
- 은행 이체: "정확성" (1원도 틀리면 안 됨)
- 채팅 앱: "가용성" (항상 메시지 전송 가능)
```

**카테고리 B: 사용자/규모**

```
Q3: "사용자가 이 시스템에서 가장 자주 하는 행동 3가지는?"
────────────────────────────────────────────────────────
목적: 핵심 사용자 여정 파악

답변 형식:
1. [행동 1] - 빈도: 일 N회, 소요시간: N초
2. [행동 2] - 빈도: 일 N회, 소요시간: N초
3. [행동 3] - 빈도: 일 N회, 소요시간: N초

예시 (이커머스):
1. 상품 검색 - 일 100회, 1초 이내
2. 상품 상세 보기 - 일 50회, 3초 이내
3. 주문하기 - 일 5회, 30초 이내

Q4: "동시에 이 시스템을 사용하는 사용자는 얼마나 되나요?"
────────────────────────────────────────────────────────
목적: 확장성 요구사항 파악 (Layer 3 - 환경 제약)

답변 유형:
├─ 소규모: 10-100명 동시 접속
├─ 중규모: 100-10,000명 동시 접속
├─ 대규모: 10,000-100,000명 동시 접속
└─ 초대규모: 100,000명+ 동시 접속

추가 질문:
- 피크 시간대는? (출퇴근, 점심, 이벤트)
- 성장 예상치는? (월 N% 증가)
- 지역 분포는? (국내, 글로벌)
```

**카테고리 C: 데이터/의존성**

```
Q5: "이 시스템에서 다루는 데이터 중 가장 민감한 것은?"
────────────────────────────────────────────────────────
목적: 보안 수준 결정

답변 유형:
├─ 극비: 금융 정보, 의료 기록, 생체 정보
├─ 민감: 개인정보, 위치 정보, 연락처
├─ 내부: 비즈니스 데이터, 운영 정보
└─ 공개: 공개 콘텐츠, 통계 정보

규제 연결:
- 금융: 전자금융거래법, PCI-DSS
- 의료: HIPAA, 개인정보보호법
- 일반: GDPR, 개인정보보호법

Q6: "데이터는 어디서 오나요? (원천)"
────────────────────────────────────────────────────────
목적: 통합 복잡도 파악

답변 유형:
├─ 자체 생성: 사용자 입력, 시스템 생성
├─ 외부 API: 증권사 API, 결제 API, 지도 API
├─ 데이터 피드: 실시간 시세, 뉴스 피드
├─ 배치 수집: 일별 정산, 주기적 크롤링
└─ 사용자 업로드: 파일, 이미지, 문서

Q7: "데이터는 얼마나 오래 보관해야 하나요?"
────────────────────────────────────────────────────────
목적: 저장소 설계, 아카이빙 전략

답변 유형:
├─ 실시간: 현재 상태만 (캐시, 세션)
├─ 단기: 7일-30일 (로그, 임시 데이터)
├─ 중기: 1년-5년 (거래 내역, 활동 기록)
├─ 장기: 5년+ (법적 보관, 감사 추적)
└─ 영구: 삭제 불가 (블록체인, 아카이브)
```

**카테고리 D: 운영/환경**

```
Q8: "이 시스템이 연동해야 하는 외부 시스템은?"
────────────────────────────────────────────────────────
목적: 의존성 파악, 장애 전파 범위

답변 형식:
| 시스템 | 연동 방식 | 의존도 | 대체 가능 |
|--------|----------|--------|----------|
| KIS API | REST | 필수 | X |
| Slack | Webhook | 선택 | O (이메일) |

Q9: "시스템은 어디에 배포되나요?"
────────────────────────────────────────────────────────
목적: 인프라 제약 파악

답변 유형:
├─ 클라우드: AWS, GCP, Azure
├─ 온프레미스: 자체 서버, IDC
├─ 하이브리드: 클라우드 + 온프레미스
├─ 엣지: IoT, CDN, 로컬
└─ 제약: 특정 리전, 규제 요건

Q10: "시스템은 얼마나 자주 변경되나요?"
────────────────────────────────────────────────────────
목적: 유지보수 전략, 배포 파이프라인

답변 유형:
├─ 초고빈도: 일 수회 배포 (CI/CD 필수)
├─ 고빈도: 주 1-2회 배포
├─ 중빈도: 월 1-2회 배포
├─ 저빈도: 분기 1회 배포
└─ 극저빈도: 연 1-2회 (안정성 중시)
```

---

#### 7가지 패밀리와 ADQ 매핑

```
10가지 ADQ 답변 → 3-Layer Decision Tree → 패밀리 코드

Layer 1 (Q1 기반): 실패 영향
├─ A: 치명적 (금전/인명/법적)
├─ B: 심각 (비즈니스 영향)
└─ C: 경미 (불편함 수준)

Layer 2 (Q2, Q5, Q6 기반): 데이터 형태
├─ A: 구조화 (정형 데이터, 스키마 고정)
├─ B: 반구조화 (JSON, 유연한 스키마)
└─ C: 비구조화 (스트림, 로그, 자연어)

Layer 3 (Q3, Q4, Q10 기반): 응답 시점
├─ A: 밀리초 (실시간, <100ms)
├─ B: 초 단위 (대화형, <5s)
└─ C: 배치 (분~시간)
```

**7가지 주요 패밀리**:

| 코드 | 패밀리 | 특성 | 대표 사례 |
|------|--------|------|----------|
| **A-A-B** | CRUD/트랜잭션 | 치명적, 구조화, 초 | 주문, 결제, ERP |
| **B-B-B** | 검색/추천 | 점진적, 반구조화, 초 | Elasticsearch, 추천 엔진 |
| **B-C-A** | 실시간 스트리밍 | 점진적, 비구조화, 밀리초 | Netflix, Uber GPS |
| **B-A-C** | 분석/배치 | 점진적, 구조화, 배치 | Snowflake, BI |
| **B-A-A** | 협업/동기화 | 점진적, 구조화, 밀리초 | Google Docs, Figma |
| **A-A-A** | 초고빈도 거래 | 치명적, 구조화, 마이크로초 | HFT, NASDAQ |
| **A-B-A** | 안전-임계 IoT | 치명적, 반구조화, 밀리초 | SCADA, 의료기기 |

#### NFR 프로파일 도출

```
Q2 답변 기반 NFR 우선순위 결정:

예시: 주식 거래 플랫폼

Q2 답변: "빠르고 정확해야 하며, 항상 접속 가능해야 함"
         → 속도, 정확성, 가용성 모두 중요

NFR 프로파일:
┌─────────────────────────────────────────┐
│ 정확성: A (100% 정확, 1원도 틀리면 안됨) │
│ 속도: A (100ms 이내 응답)               │
│ 가용성: A (99.9% uptime)                │
│ 보안: A (금융 데이터)                   │
│ 비용: B (성능이 우선, 비용은 그 다음)    │
└─────────────────────────────────────────┘

프로파일 코드: A-A-A-A-B

충돌 식별:
├─ 정확성 A + 속도 A = 캐싱 전략 신중해야
├─ 가용성 A + 정확성 A = 분산 트랜잭션 필요
└─ → Stage 2에서 충돌 해결 전략 수립
```

#### Stage 1 산출물

```
01C-01_family_classification.md
────────────────────────────────
# 패밀리 분류 결과

## 프로젝트: [프로젝트명]

## 10가지 ADQ 답변
[Q1-Q10 답변 기록]

## 3-Layer 결정
- Layer 1 (실패 영향): A (치명적)
- Layer 2 (데이터 형태): A (구조화)
- Layer 3 (응답 시점): B (초 단위)

## 패밀리 코드: A-A-B (CRUD/트랜잭션)

## NFR 프로파일: A-A-A-A-B
- 정확성: A
- 속도: A
- 가용성: A
- 보안: A
- 비용: B

## 잠재적 충돌
1. 정확성 + 속도: 캐싱 vs 실시간 검증
2. 가용성 + 정확성: 분산 vs 단일 소스

## 다음 단계
→ Stage 2에서 Layer 3 외부 제약 조사
→ 충돌 해결 전략 수립
```

---

### 3.2 Stage 2: 환경 제약 조사

#### 목표
Layer 3 외부 제약 파악, 충돌 패턴 식별, 기술 스택 결정

#### 외부 제약 조사 체크리스트

```
1. API/연동 제약 (Q8 심화)
────────────────────────────────
[ ] 사용할 외부 API 목록
[ ] 각 API의 호출 제한 (rate limit)
[ ] 인증 방식 (OAuth, API Key, 인증서)
[ ] 응답 시간 SLA
[ ] 장애 시 대응 방안

예시 (KIS API):
├─ 호출 제한: 초당 20회
├─ 인증: OAuth 2.0 + 앱키
├─ 시장 시간: 09:00-15:30 (정규)
└─ 장애 대응: 재시도 3회 + 알림

2. 규제/법적 제약
────────────────────────────────
[ ] 적용되는 법규 목록
[ ] 데이터 보관 요건
[ ] 감사 로그 요건
[ ] 암호화 요건
[ ] 지역 제한 (데이터 거주지)

예시 (금융):
├─ 전자금융거래법
├─ 거래 기록 5년 보관
├─ 이상거래 탐지 의무
└─ 국내 서버 필수

3. 인프라 제약 (Q9 심화)
────────────────────────────────
[ ] 클라우드 제공자 제한
[ ] 가용 리전
[ ] 네트워크 대역폭
[ ] 스토리지 용량/비용
[ ] 기존 인프라 연동

4. 시간 제약
────────────────────────────────
[ ] 서비스 운영 시간
[ ] 배치 처리 시간 윈도우
[ ] 유지보수 시간
[ ] 마감 시간 (정산, 리포트)
```

#### 충돌 패턴 식별

```
Stage 1의 NFR 프로파일에서 충돌 식별:

공통 충돌 패턴:

1. 정확성 vs 속도 (CAP Theorem의 C vs A)
────────────────────────────────
상황: 강한 일관성 vs 낮은 지연시간
해결 전략:
├─ 쓰기: 동기식 (정확성)
├─ 읽기: 캐시 + 비동기 (속도)
└─ 중요 작업만 동기, 나머지 비동기

2. 가용성 vs 정확성 (CAP Theorem의 A vs C)
────────────────────────────────
상황: 항상 응답 vs 항상 정확
해결 전략:
├─ 네트워크 정상: 둘 다 만족
├─ 네트워크 장애: 정확성 우선 (금융)
└─ Saga 패턴, Outbox 패턴 검토

3. 성능 vs 비용
────────────────────────────────
상황: 최고 성능 vs 운영비 절감
해결 전략:
├─ 피크 시간: 오토스케일링
├─ 비피크: 최소 인스턴스
└─ 비용 상한선 설정

4. 보안 vs 사용성
────────────────────────────────
상황: 강한 보안 vs 편리한 사용
해결 전략:
├─ 조회: 간단한 인증
├─ 거래: MFA 필수
└─ 위험 기반 인증 (Risk-based Auth)
```

#### 기술 스택 결정 프로세스

```
1. 패밀리 기반 후보군 도출
────────────────────────────────
패밀리: A-A-B (CRUD/트랜잭션)

후보 DB:
├─ PostgreSQL: ACID, JSON 지원, 성숙
├─ MySQL: ACID, 대중적, Aurora 옵션
└─ Oracle: 엔터프라이즈, 비용 높음

후보 프레임워크 (언어별):
├─ Python: FastAPI, Django
├─ TypeScript: NestJS, Express
├─ Java: Spring Boot
└─ Go: Gin, Echo

2. 제약조건 필터링
────────────────────────────────
팀 역량: [팀 주력 언어] → [선택 프레임워크]
비용 제한: 오픈소스 우선 → PostgreSQL
성능 요건: 비동기 필수 → [비동기 지원 프레임워크]

3. 결정 및 근거 문서화
────────────────────────────────
→ Stage 3에서 ADR로 문서화
```

#### Stage 2 산출물

```
02C-01_external_constraints.md
────────────────────────────────
# 외부 제약 조건

## API 제약
[KIS API, 결제 API 등 상세]

## 규제 제약
[법규, 보관 요건 등]

## 인프라 제약
[클라우드, 리전 등]

## 시간 제약
[운영 시간, 배치 윈도우 등]

---

02C-02_conflict_patterns.md
────────────────────────────────
# 충돌 패턴 분석

## 식별된 충돌
1. 정확성 vs 속도
2. 가용성 vs 정확성

## 해결 전략
[각 충돌별 전략]

---

02D-01_tech_stack.md
────────────────────────────────
# 기술 스택 결정

## 결정 사항
- 언어: [선택 언어]
- 프레임워크: [선택 프레임워크]
- DB: PostgreSQL 15
- 캐시: Redis
- 메시징: Kafka

## 선택 근거
[각 기술별 근거]

## 제외된 대안
[검토했으나 제외된 기술과 이유]
```

---

## Part 4: Stage 3 결정 문서화 - ADR

### 4.1 ADR의 역할과 위치

#### ADR이란?

```
ADR = Architecture Decision Record
     아키텍처 결정 기록

목적:
├─ 왜 이 결정을 했는지 기록
├─ 어떤 대안이 있었는지 기록
├─ 나중에 "왜 이렇게 했지?" 질문에 답변
└─ 결정 변경 시 영향 범위 파악

핵심:
"코드는 '무엇'을 보여주지만, ADR은 '왜'를 설명한다"
```

#### ADR vs Design Doc

```
┌─────────────────────────────────────────────────────────┐
│                    Design Doc                           │
│  (상세 분석 문서)                                        │
├─────────────────────────────────────────────────────────┤
│  - 문제 정의                                            │
│  - 여러 대안 상세 분석                                  │
│  - 장단점 비교표                                        │
│  - 프로토타입 결과                                      │
│  - 성능 벤치마크                                        │
│  - 10-50 페이지                                         │
│                                                         │
│  → 복잡한 결정에 사용                                   │
│  → "어머니" 문서                                        │
└─────────────────────────────────────────────────────────┘
                    ↓ 요약
┌─────────────────────────────────────────────────────────┐
│                      ADR                                │
│  (결정 기록)                                            │
├─────────────────────────────────────────────────────────┤
│  - 결정 사항 (1줄)                                      │
│  - 맥락 (왜 필요했나)                                   │
│  - 선택한 대안과 이유                                   │
│  - 결과 (무엇이 바뀌나)                                 │
│  - 1-2 페이지                                           │
│                                                         │
│  → 모든 결정에 사용                                     │
│  → Design Doc의 "결론" 요약                             │
└─────────────────────────────────────────────────────────┘

판단 기준:
├─ 간단한 결정: ADR만 작성
│   예: "로깅은 구조화 로깅 라이브러리 사용"
│
├─ 복잡한 결정: Design Doc → ADR
│   예: "DB 선택 (PostgreSQL vs MySQL vs MongoDB)"
│
└─ 매우 복잡: RFC/KEP → Design Doc → ADR
    예: "마이크로서비스 vs 모놀리식"
```

---

### 4.2 5대 ADR 카테고리

#### 카테고리 1: 외부 제약 ADR

```
정의: 변경할 수 없는 외부 요인에 의한 결정

특징:
├─ 우리가 선택할 수 없음
├─ 반드시 따라야 함
├─ 위반 시 시스템 작동 불가 또는 법적 문제
└─ "왜?"보다 "무엇?"이 중요

예시:
├─ 법규: "금융 거래 기록 5년 보관 (전자금융거래법)"
├─ API 제한: "KIS API 초당 20회 호출 제한"
├─ 시장 시간: "KRX 정규장 09:00-15:30"
└─ 지역 제한: "개인정보 국내 서버 저장 필수"

템플릿:
┌─────────────────────────────────────────────────────────┐
│ ADR-001: KIS API 호출 제한 준수                         │
├─────────────────────────────────────────────────────────┤
│ 상태: 승인됨                                            │
│ 일자: 2024-01-15                                        │
│ 카테고리: 외부 제약                                     │
├─────────────────────────────────────────────────────────┤
│ 맥락:                                                   │
│ KIS API는 초당 20회 호출 제한이 있음.                   │
│ 이를 초과하면 일시적 차단됨.                            │
├─────────────────────────────────────────────────────────┤
│ 결정:                                                   │
│ Rate Limiter를 구현하여 초당 15회로 제한.               │
│ 여유분 5회는 재시도용.                                  │
├─────────────────────────────────────────────────────────┤
│ 결과:                                                   │
│ - 모든 KIS API 호출은 RateLimiter를 거쳐야 함          │
│ - 벌크 요청 시 큐잉 필요                               │
└─────────────────────────────────────────────────────────┘
```

#### 카테고리 2: 충돌 해결 ADR

```
정의: 상충하는 요구사항 간 Trade-off 결정

특징:
├─ 둘 다 중요하지만 둘 다 만족 불가
├─ 하나를 선택하면 다른 하나 희생
├─ "왜 이걸 선택했나?"가 핵심
└─ 나중에 재검토 가능성 있음

예시:
├─ 정확성 vs 속도: "주문 정확성 > 응답 속도"
├─ 일관성 vs 가용성: "CP 선택 (장애 시 거부)"
├─ 보안 vs 편의성: "거래는 MFA, 조회는 단순 인증"
└─ 비용 vs 성능: "피크 시 성능, 비피크 시 비용"

템플릿:
┌─────────────────────────────────────────────────────────┐
│ ADR-002: 정확성 우선 전략                               │
├─────────────────────────────────────────────────────────┤
│ 상태: 승인됨                                            │
│ 일자: 2024-01-15                                        │
│ 카테고리: 충돌 해결                                     │
├─────────────────────────────────────────────────────────┤
│ 맥락:                                                   │
│ 주문 처리에서 정확성(금액 정확)과 속도(빠른 응답)가     │
│ 충돌함. 캐시 사용 시 속도↑ but 정확성 위험.            │
├─────────────────────────────────────────────────────────┤
│ 검토한 대안:                                            │
│ 1. 캐시 사용 + 비동기 검증: 속도↑, 정확성 위험         │
│ 2. 항상 실시간 조회: 정확성↑, 속도↓ (200ms→500ms)     │
│ 3. 하이브리드: 조회는 캐시, 주문은 실시간              │
├─────────────────────────────────────────────────────────┤
│ 결정:                                                   │
│ 대안 3 선택. 주문 관련 데이터는 항상 실시간 조회.      │
│ 시세 조회는 1초 캐시 허용.                              │
├─────────────────────────────────────────────────────────┤
│ 결과:                                                   │
│ - 주문 API: 캐시 사용 금지                              │
│ - 시세 API: Redis 캐시 1초 TTL                          │
│ - 모니터링: 캐시 히트율 + 주문 정확도 추적             │
├─────────────────────────────────────────────────────────┤
│ 재검토 조건:                                            │
│ - 응답 시간이 1초 초과 시                               │
│ - 정확도 문제 발생 시                                   │
└─────────────────────────────────────────────────────────┘
```

#### 카테고리 3: 기술 스택 ADR

```
정의: 여러 기술 대안 중 하나를 선택하는 결정

특징:
├─ 비교 가능한 대안 존재
├─ 정량적 비교 가능 (성능, 비용, 생태계)
├─ Context7 검증 필수
└─ 팀 역량, 생태계 고려

예시:
├─ DB: "PostgreSQL vs MySQL vs MongoDB"
├─ 프레임워크: "[팀 언어]의 프레임워크 비교"
├─ 메시지 큐: "Kafka vs RabbitMQ vs Redis Pub/Sub"
└─ 캐시: "Redis vs Memcached"

템플릿:
┌─────────────────────────────────────────────────────────┐
│ ADR-003: PostgreSQL 선택                                │
├─────────────────────────────────────────────────────────┤
│ 상태: 승인됨                                            │
│ 일자: 2024-01-15                                        │
│ 카테고리: 기술 스택                                     │
├─────────────────────────────────────────────────────────┤
│ 맥락:                                                   │
│ CRUD/트랜잭션 패밀리로, ACID 준수 DB 필요.              │
├─────────────────────────────────────────────────────────┤
│ 검토한 대안:                                            │
│                                                         │
│ | 기준 | PostgreSQL | MySQL | MongoDB |                 │
│ |------|------------|-------|---------|                 │
│ | ACID | ✅ 완전    | ✅    | ⚠️ 제한 |                │
│ | JSON | ✅ JSONB   | ⚠️    | ✅ 네이티브 |            │
│ | 성능 | 복잡쿼리↑  | 단순↑ | 읽기↑   |                │
│ | 비용 | 무료       | 무료  | Atlas$$ |                 │
│ | 팀경험| ✅ 있음   | ✅    | ⚠️ 적음 |                │
├─────────────────────────────────────────────────────────┤
│ 결정:                                                   │
│ PostgreSQL 15 선택.                                     │
│ - ACID 완전 지원                                        │
│ - JSONB로 유연한 스키마 가능                            │
│ - 팀 경험 있음                                          │
├─────────────────────────────────────────────────────────┤
│ 결과:                                                   │
│ - ORM: SQLAlchemy 2.0 (async 지원)                      │
│ - 마이그레이션: Alembic                                 │
│ - 연결: asyncpg (비동기)                                │
└─────────────────────────────────────────────────────────┘
```

#### 카테고리 4: 도메인 기술 ADR

```
정의: 프로젝트 특화 로직/알고리즘 설계 결정

특징:
├─ 외부 라이브러리로 해결 안 됨
├─ 자체 설계/구현 필요
├─ 비즈니스 로직 깊숙이 관련
└─ 성능/정확도가 핵심

예시:
├─ 주문 매칭 알고리즘
├─ 추천 점수 계산 로직
├─ 가격 책정 엔진
└─ 동시성 제어 전략

템플릿:
┌─────────────────────────────────────────────────────────┐
│ ADR-101: 주문 실행 전략                                 │
├─────────────────────────────────────────────────────────┤
│ 상태: 승인됨                                            │
│ 일자: 2024-01-15                                        │
│ 카테고리: 도메인 기술                                   │
├─────────────────────────────────────────────────────────┤
│ 맥락:                                                   │
│ 사용자 주문을 KIS API로 전송하는 전략 필요.             │
│ 부분 체결, 실패, 재시도 처리 필요.                      │
├─────────────────────────────────────────────────────────┤
│ 설계:                                                   │
│ 1. 주문 상태 머신:                                      │
│    CREATED → SUBMITTED → PARTIAL → FILLED/FAILED       │
│                                                         │
│ 2. 재시도 전략:                                         │
│    - 네트워크 오류: 최대 3회, 지수 백오프              │
│    - 비즈니스 오류: 재시도 없음, 사용자 알림           │
│                                                         │
│ 3. 부분 체결:                                           │
│    - 원주문 유지 + 체결 이력 별도 저장                 │
│    - 잔량 추적                                         │
├─────────────────────────────────────────────────────────┤
│ 결과:                                                   │
│ - OrderStateMachine 구현 필요                           │
│ - OrderExecution 서비스 구현 필요                       │
│ - 상태 변경 이벤트 발행 (Kafka)                        │
└─────────────────────────────────────────────────────────┘
```

#### 카테고리 5: DNA 시스템 ADR

```
정의: 프로젝트 공통 인프라/표준 결정

특징:
├─ 전체 프로젝트에 영향
├─ Stage 4-6 (Bridge)에서 구현
├─ 일관성이 핵심
└─ 변경 시 영향 범위 큼

예시:
├─ 로깅 표준: "구조화 로깅 + JSON 포맷"
├─ 에러 처리: "예외 계층 + 에러 코드"
├─ 설정 관리: "타입 안전 설정 + 환경 변수"
└─ 테스트 전략: "테스트 프레임워크 + 95% 커버리지"

템플릿:
┌─────────────────────────────────────────────────────────┐
│ ADR-010: 로깅 표준화                                    │
├─────────────────────────────────────────────────────────┤
│ 상태: 승인됨                                            │
│ 일자: 2024-01-15                                        │
│ 카테고리: DNA 시스템                                    │
├─────────────────────────────────────────────────────────┤
│ 맥락:                                                   │
│ 일관된 로깅으로 디버깅/모니터링 효율화 필요.            │
│ 분산 추적(trace_id) 필수.                               │
├─────────────────────────────────────────────────────────┤
│ 결정:                                                   │
│ - 라이브러리: [언어별 구조화 로깅 도구]                 │
│ - 포맷: JSON (프로덕션), Console (개발)                │
│ - 레벨: DEBUG, INFO, WARNING, ERROR, CRITICAL          │
│ - 컨텍스트: trace_id, user_id, request_id              │
├─────────────────────────────────────────────────────────┤
│ 결과:                                                   │
│ - src/core/logging/ 모듈 구현                          │
│ - print() 사용 금지 (Lint 규칙)                        │
│ - 모든 로그는 logger.info() 등 사용                    │
├─────────────────────────────────────────────────────────┤
│ 강제:                                                   │
│ - pre-commit: print() 감지 차단                        │
│ - Lint: print 금지 규칙 활성화                         │
└─────────────────────────────────────────────────────────┘
```

---

## Part 5: Stage 4-6 Bridge - 환경 구축

### 5.1 Bridge의 의미

#### "Gap이 아니라 Bridge"

```
기존 오해:
├─ Stage 3 (ADR) 완료
├─ ???
├─ ???
├─ ???
└─ Stage 7 (Blueprint) 시작

→ "Stage 4-6은 뭐하는 거지? 그냥 넘어가도 되나?"

Gemini 연구 결과:
┌─────────────────────────────────────────────────────────┐
│ Stage 4-6 = Bridge (다리)                               │
│                                                         │
│ ADR (결정) ──────────────────────→ Blueprint (설계)     │
│             ↑                   ↑                       │
│             │    Stage 4-6     │                       │
│             │                   │                       │
│             └───────────────────┘                       │
│                                                         │
│ 결정을 "실행 가능한 환경"으로 변환하는 단계             │
└─────────────────────────────────────────────────────────┘

비유:
├─ ADR = "서울에서 부산 가기로 결정" (결정)
├─ Bridge = "KTX 티켓 구매, 역 도착" (준비)
└─ Blueprint = "출발역, 환승, 도착역 계획" (상세 계획)
```

#### 4대 구성요소

```
"강제 가능한 환경"의 4대 구성요소:

┌─────────────────────────────────────────────────────────┐
│ 1. 성문화된 결정 (Stage 3)                              │
│    = ADR 문서                                           │
│    = "왜 이렇게 해야 하는지" 근거                       │
│    → 비유: 법률                                         │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 2. 재사용 가능한 컴포넌트 (Stage 5)                     │
│    = src/core/ 공통 모듈                                │
│    = "이걸 쓰면 됨" 도구                                │
│    → 비유: 공구                                         │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 3. 의무적 규칙 (Stage 6)                                │
│    = PROJECT_STANDARDS.md                               │
│    = "이렇게 해야 함" 명시                              │
│    → 비유: 교통법규                                     │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 4. 자동화된 거버넌스 (Stage 6)                          │
│    = pre-commit, Lint, Type Check, Test                │
│    = "위반하면 막힘" 강제                               │
│    → 비유: 단속 카메라                                  │
└─────────────────────────────────────────────────────────┘
```

#### 핵심 인사이트

```
DNA 시스템 = "환경/플랫폼"
도메인 = "애플리케이션"

관계:
┌─────────────────────────────────────────────────────────┐
│                    도메인 코드                          │
│  (Stage 7-9에서 구현)                                   │
│                                                         │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐                   │
│  │ 주문    │ │ 계좌    │ │ 시세    │  ← 비즈니스 로직  │
│  │ 서비스  │ │ 서비스  │ │ 서비스  │                   │
│  └────┬────┘ └────┬────┘ └────┬────┘                   │
│       │          │          │                          │
│  ═════╪══════════╪══════════╪═══════════════════════   │
│       │          │          │                          │
│  ┌────┴──────────┴──────────┴────┐                     │
│  │        DNA 시스템 (환경)       │                     │
│  │  (Stage 4-6에서 구축)          │                     │
│  │                                │                     │
│  │  logging / config / types     │                     │
│  │  database / cache / messaging │                     │
│  │  testing / monitoring / auth  │                     │
│  │  error handling / api gateway │                     │
│  └────────────────────────────────┘                     │
└─────────────────────────────────────────────────────────┘

핵심:
├─ DNA가 먼저 구축되어야 도메인이 일관되게 구현됨
├─ 도메인은 DNA를 "사용"만 함 (직접 구현 X)
└─ DNA 변경 = 전체 영향 (신중해야)
```

---

### 5.2 Stage 4: DNA 시스템 청사진

#### 목표
DNA 시스템 11개의 설계 문서 작성

#### DNA 11개 시스템 개요

```
┌──────────────────────────────────────────────────────────┐
│                  DNA 11개 시스템                         │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  핵심 인프라 (4개):                                      │
│  ├─ 1. Logging: 구조화된 로깅                           │
│  ├─ 2. Configuration: 타입 안전 설정                    │
│  ├─ 3. Types: 공통 타입 정의                            │
│  └─ 4. Error Handling: 예외 계층 + 에러 코드            │
│                                                          │
│  데이터/통신 (3개):                                      │
│  ├─ 5. Database: ORM + 마이그레이션                     │
│  ├─ 6. Cache: 캐싱 추상화                               │
│  └─ 7. Messaging: 이벤트 발행/구독                      │
│                                                          │
│  품질/보안 (4개):                                        │
│  ├─ 8. Testing: 테스트 인프라                           │
│  ├─ 9. Monitoring: 메트릭 수집                          │
│  ├─ 10. Security: 인증/인가                             │
│  └─ 11. API Gateway: 라우팅/미들웨어                    │
│                                                          │
│  (언어별 구현: docs/manuals/ 참조)                       │
└──────────────────────────────────────────────────────────┘
```

#### 패밀리별 DNA 시스템 선택

```
모든 패밀리 공통 (필수):
├─ Logging
├─ Configuration
├─ Types
├─ Error Handling
└─ Testing

패밀리별 선택:

A-A-B (CRUD/트랜잭션):
├─ Database: ✅ 필수 (ACID)
├─ Cache: ✅ 권장 (읽기 최적화)
├─ Messaging: ⚠️ 선택 (이벤트 발행)
├─ Monitoring: ✅ 권장
├─ Security: ✅ 필수 (금융)
└─ API Gateway: ✅ 필수

B-C-A (실시간 스트리밍):
├─ Database: ⚠️ 선택 (상태 저장)
├─ Cache: ✅ 필수 (버퍼링)
├─ Messaging: ✅ 필수 (Kafka)
├─ Monitoring: ✅ 필수 (지연 모니터링)
├─ Security: ⚠️ 선택
└─ API Gateway: ✅ 필수 (WebSocket)

B-A-A (협업/동기화):
├─ Database: ✅ 필수 (상태 저장)
├─ Cache: ✅ 필수 (로컬 캐시)
├─ Messaging: ✅ 필수 (실시간 동기화)
├─ Monitoring: ✅ 권장
├─ Security: ✅ 필수 (사용자 인증)
└─ API Gateway: ✅ 필수 (WebSocket)
```

#### Stage 4 산출물

```
04B-01_dna_blueprint.md (또는 여러 파트)
────────────────────────────────────────

# DNA 시스템 청사진

## 1. 선택된 DNA 시스템
- 패밀리: A-A-B (CRUD/트랜잭션)
- 필수: Logging, Config, Types, Error, Testing, DB, Security, API
- 선택: Cache, Monitoring
- 제외: Messaging (MVP 이후)

## 2. 각 시스템 설계

### 2.1 Logging 시스템
- 라이브러리: [언어별 구조화 로깅 도구]
- 포맷: JSON (prod), Console (dev)
- 컨텍스트: trace_id, user_id, request_id
- 디렉토리: src/core/logging/

[각 시스템별 상세 설계...]

## 3. 의존성 관계
Logging ← 모든 시스템
Config ← Database, Cache, Messaging
Types ← 모든 시스템
Error ← 모든 시스템

## 4. 구현 순서
1. Types (의존성 없음)
2. Config (Types 의존)
3. Logging (Config 의존)
4. Error (Types, Logging 의존)
5. ...
```

---

### 5.3 Stage 5: DNA 시스템 구현

#### 목표
청사진 기반 src/core/ 공통 모듈 구현

#### 디렉토리 구조

```
(예시: Python 디렉토리 구조 - 언어별 상세: docs/manuals/ 참조)

src/
├── core/                           # DNA 시스템
│   │
│   ├── logging/                    # 1. Logging
│   │   ├── logger.*                # 로깅 래퍼
│   │   ├── config.*                # 로그 레벨, 포맷
│   │   └── handlers.*              # 파일, 콘솔, JSON
│   │
│   ├── config/                     # 2. Configuration
│   │   ├── settings.*              # 타입 안전 설정
│   │   └── validators.*            # 커스텀 검증
│   │
│   ├── types/                      # 3. Types
│   │   ├── base.*                  # 기본 타입 확장
│   │   ├── ids.*                   # ID 타입 (UUID)
│   │   └── common.*                # 공통 타입
│   │
│   ├── errors/                     # 4. Error Handling
│   │   ├── exceptions.*            # 예외 계층
│   │   ├── codes.*                 # 에러 코드
│   │   └── handlers.*              # 전역 핸들러
│   │
│   ├── database/                   # 5. Database
│   │   ├── __init__.py
│   │   ├── session.py              # SQLAlchemy 세션
│   │   ├── base.py                 # Base 모델
│   │   └── mixins.py               # 공통 믹스인
│   │
│   ├── cache/                      # 6. Cache
│   │   ├── __init__.py
│   │   ├── client.py               # Redis 클라이언트
│   │   └── decorators.py           # @cached 데코레이터
│   │
│   └── ...                         # 나머지 시스템
│
├── domain/                         # 도메인 코드 (Stage 7-9)
│   └── ...
│
└── api/                            # API 레이어 (Stage 7-9)
    └── ...
```

#### 구현 원칙

```
1. 표준 라이브러리 우선
────────────────────────────────
❌ 직접 구현:
class MyLogger:
    def log(self, msg):
        print(f"[LOG] {msg}")  # 1679줄...

✅ 표준 라이브러리:
// 언어별 구조화 로깅 도구 사용
// Python: structlog, TypeScript: winston, Java: logback
logger = get_logger()  // 의사코드

2. 인터페이스 추상화
────────────────────────────────
# core/cache/interface.py
class CacheInterface(Protocol):
    async def get(self, key: str) -> Any: ...
    async def set(self, key: str, value: Any, ttl: int) -> None: ...

# core/cache/redis.py
class RedisCache(CacheInterface):
    async def get(self, key: str) -> Any:
        return await self.client.get(key)

# 나중에 Memcached로 교체 가능

3. 설정 주입
────────────────────────────────
# core/config/settings.py
class Settings(BaseSettings):
    redis_url: str = "redis://localhost:6379"
    log_level: str = "INFO"
    
    model_config = SettingsConfigDict(env_file=".env")

# 사용
settings = Settings()
logger.info("Connecting to", redis_url=settings.redis_url)
```

---

### 5.4 Stage 6: Project Standards

#### 목표
DNA 시스템 사용 강제 규칙 + 자동화 설정

#### PROJECT_STANDARDS.md 구조 예시

```
# Project Standards

## 1. 코드 스타일

### 1.1 포맷팅
- 표준 Formatter 사용
- 줄 길이: 80-120자 (언어별 관례)
- 들여쓰기: 언어별 표준

### 1.2 네이밍
- 클래스: PascalCase
- 함수/변수: snake_case 또는 camelCase (언어별)
- 상수: UPPER_SNAKE_CASE
- 비공개: _prefix 또는 private

## 2. DNA 시스템 사용 규칙

### 2.1 Logging (DO/DON'T)
DO:
- from core.logging import logger
- logger.info("message", key=value)

DON'T:
- print() 사용 금지
- logging.getLogger() 직접 사용 금지

### 2.2 Configuration (DO/DON'T)
DO:
- from core.config import settings
- settings.database_url

DON'T:
- os.environ.get() 직접 사용 금지
- 하드코딩된 설정값 금지

### 2.3 Types (DO/DON'T)
DO:
- from core.types import UserId, OrderId
- 모든 함수에 타입 힌트

DON'T:
- Any 타입 사용 금지 (불가피한 경우 주석 필수)
- Dict[str, Any] 대신 TypedDict 사용

### 2.4 Error Handling (DO/DON'T)
DO:
- from core.errors import NotFoundError, ValidationError
- raise NotFoundError(entity="User", id=user_id)

DON'T:
- 일반 Exception raise 금지
- except: pass 금지

## 3. 테스트 규칙

### 3.1 커버리지
- 전체: 95% 이상
- 신규 코드: 100%
- 핵심 로직: 100%

### 3.2 테스트 구조
- tests/unit/: 단위 테스트
- tests/integration/: 통합 테스트
- tests/e2e/: E2E 테스트

## 4. 품질 기준

### 4.1 Zero Tolerance
- Lint: 0 violations
- Type Check: 0 errors
- Test: 0 failures
- Coverage: 95%+

### 4.2 커밋 전 필수
- pre-commit hooks 통과
- 테스트 통과
- 타입 체크 통과
```

#### 자동화 설정

```yaml
# 언어별 설정 파일 (Python: pyproject.toml, TS: eslint.config.js 등)

[Lint 설정]
line-length = 80-120
rules = [코드 스타일, import 정렬, print 금지]

[Type Check 설정]
strict = true
warn_return_any = true

[Test 설정]
coverage = "--cov=src --cov-fail-under=95"

---

# .pre-commit-config.yaml (언어별 도구로 대체)
repos:
  - repo: [Lint 도구 레포지토리]
    rev: [버전]
    hooks:
      - id: lint
        args: [--fix]
      - id: format

  - repo: [Type Check 도구 레포지토리]
    rev: [버전]
    hooks:
      - id: type-check
        additional_dependencies: [필요한 플러그인]

  - repo: local
    hooks:
      - id: test
        name: unit-test
        entry: [테스트 프레임워크] tests/unit -q
        language: system
        pass_filenames: false
        always_run: true

# 언어별 예시:
# Python: ruff, mypy, pytest
# TypeScript: eslint, tsc, jest
# Java: checkstyle, javac, junit
# Go: golint, go vet, go test
```

#### 자동화 성숙도

```
Day 1: 정적 분석
────────────────────────────────
├─ pre-commit 설치
├─ Ruff (린팅 + 포맷팅)
├─ MyPy (타입 체크)
└─ 기본 테스트 실행

Week 2: 아키텍처 검증
────────────────────────────────
├─ import-linter 설정
│   - core → domain 금지
│   - domain → api 금지
├─ 아키텍처 테스트 추가
└─ 의존성 방향 검증

Month 1+: 고급 거버넌스
────────────────────────────────
├─ Fitness Functions
│   - 응답 시간 < 200ms
│   - 커버리지 > 95%
├─ Policy-as-Code
│   - 보안 정책 자동 검증
└─ 메트릭 기반 알림
```

---

## Part 6: Stage 7-9 Blueprint → 구현

### 6.1 Stage 7: Project Blueprint

#### 목표
도메인 ADR 기반 완전히 상세한 청사진 작성

#### Blueprint vs ADR

```
ADR (Stage 3):
├─ "무엇을" 결정했는지
├─ "왜" 그렇게 결정했는지
└─ 개별 결정 단위

Blueprint (Stage 7):
├─ "어떻게" 구현할 것인지
├─ 모든 ADR을 통합한 전체 그림
├─ 구체적인 구현 명세
└─ 코드 작성 직전 단계

관계:
ADR-001 ─┐
ADR-002 ─┼──→ Blueprint
ADR-003 ─┘
```

#### Blueprint 필수 섹션

```
07B-01_project_blueprint.md
────────────────────────────

# Project Blueprint

## 1. 시스템 개요
- 목적
- 범위
- 핵심 기능
- 참조: 01C-01 패밀리 분류

## 2. 아키텍처 구조
- 레이어 다이어그램
- 컴포넌트 다이어그램
- 데이터 흐름
- 참조: ADR-004 하이브리드 아키텍처

## 3. 도메인 모델
### 3.1 엔티티
- User: id, email, created_at, ...
- Order: id, user_id, status, ...
- 참조: PROJECT_STANDARDS.md Ln 45-60 (DB 규칙)

### 3.2 값 객체
- Money: amount, currency
- OrderStatus: enum

### 3.3 집계 (Aggregate)
- Order (루트): Order + OrderItems

## 4. API 설계
### 4.1 엔드포인트
- POST /orders: 주문 생성
- GET /orders/{id}: 주문 조회
- 참조: ADR-101 API 버저닝

### 4.2 요청/응답 스키마
- CreateOrderRequest: {...}
- OrderResponse: {...}

## 5. 데이터베이스 설계
### 5.1 테이블
- users: id(PK), email, ...
- orders: id(PK), user_id(FK), ...
- 참조: ADR-003 PostgreSQL

### 5.2 인덱스
- orders_user_id_idx
- orders_created_at_idx

## 6. 외부 연동
### 6.1 KIS API
- 인증 흐름
- 주문 API 호출
- 참조: ADR-001 KIS API 제한

## 7. 에러 처리
- 에러 코드 체계
- 재시도 전략
- 참조: ADR-010 에러 표준

## 8. 보안
- 인증: JWT
- 인가: RBAC
- 참조: ADR-011 보안

## 9. 다음 단계
→ Stage 8 Task Breakdown
```

#### SoT (Skeleton-of-Thought) 적용

```
Blueprint 작성에 SoT 적용:

Step 1: 목차 (뼈대) 생성
────────────────────────────────
1. 시스템 개요
2. 아키텍처 구조
3. 도메인 모델
4. API 설계
5. 데이터베이스 설계
6. 외부 연동
7. 에러 처리
8. 보안
9. 다음 단계

Step 2: 각 섹션 병렬 확장
────────────────────────────────
세션 1: 1-3 섹션 작성
세션 2: 4-6 섹션 작성
세션 3: 7-9 섹션 작성

Step 3: 전체 일관성 검토
────────────────────────────────
- ADR 참조 확인
- PROJECT_STANDARDS 참조 확인
- 섹션 간 모순 확인
```

---

### 6.2 Stage 8: Task Breakdown

#### 목표
AI가 한 세션에 완료할 수 있는 크기로 작업 분해

#### 분해 기준

```
좋은 Task의 조건:

1. 크기 (참고 기준, 핵심은 컨텍스트!)
────────────────────────────────
├─ 체크리스트: 100-150줄 범위 (120줄 내외)
├─ 예상 시간: 2-4시간
├─ 컨텍스트: 80-90K 토큰 이내 ← 실제 제한
└─ 💡 숫자는 참고! 작업을 완전하게 설명하는 게 우선

2. 독립성
────────────────────────────────
├─ 다른 Task 없이 테스트 가능
├─ 명확한 입력/출력
├─ 자체 완결적
└─ 롤백 가능

3. 검증 가능
────────────────────────────────
├─ 테스트 작성 가능
├─ 성공/실패 판단 명확
├─ 품질 기준 적용 가능
└─ MyPy 0, Ruff 0 달성

4. 가치 있음
────────────────────────────────
├─ 완료 시 실제 기능 동작
├─ 데모 가능
└─ 진행 상황 확인 가능
```

#### 분해 패턴

```
Blueprint 섹션 → Tasks 분해:

예시: "3. 도메인 모델" 섹션

┌─────────────────────────────────────────────────────────┐
│ 3. 도메인 모델                                          │
│                                                         │
│ 3.1 User 엔티티                                         │
│ 3.2 Order 엔티티                                        │
│ 3.3 OrderItem 엔티티                                    │
│ 3.4 Money 값 객체                                       │
│ 3.5 OrderStatus 열거형                                  │
└─────────────────────────────────────────────────────────┘
            ↓ 분해
┌─────────────────────────────────────────────────────────┐
│ Task 001: User 엔티티 + 테스트                          │
│   - User 모델 구현 (20줄)                               │
│   - 단위 테스트 (30줄)                                  │
│   - 예상: 2시간                                         │
├─────────────────────────────────────────────────────────┤
│ Task 002: Order 엔티티 + OrderItem + 테스트             │
│   - Order, OrderItem 모델 (40줄)                        │
│   - 집계 로직 (20줄)                                    │
│   - 단위 테스트 (40줄)                                  │
│   - 예상: 3시간                                         │
├─────────────────────────────────────────────────────────┤
│ Task 003: 값 객체 + 열거형 + 테스트                     │
│   - Money, OrderStatus (20줄)                           │
│   - 단위 테스트 (20줄)                                  │
│   - 예상: 1.5시간                                       │
└─────────────────────────────────────────────────────────┘
```

#### RDoLT 적용 (난이도별 분해)

```
RDoLT: Recursive Decomposition of Logical Thoughts

Level 1 - Easy (기본 기능):
────────────────────────────────
├─ 단순 CRUD
├─ 기본 모델 정의
├─ 단순 API 엔드포인트
└─ 명확한 로직

예: Task 001 (User 엔티티)

Level 2 - Intermediate (상호작용):
────────────────────────────────
├─ 엔티티 간 관계
├─ 트랜잭션 로직
├─ 서비스 계층 통합
└─ 검증 로직

예: Task 005 (주문 생성 서비스)

Level 3 - Final (엣지 케이스):
────────────────────────────────
├─ 에러 처리
├─ 동시성 제어
├─ 성능 최적화
├─ 보안 검증
└─ 예외 상황

예: Task 015 (주문 동시성 처리)

작업 순서:
Easy → Intermediate → Final
(기반 먼저, 복잡한 것 나중)
```

#### Stage 8 산출물

```
08T-01_task_breakdown.md
────────────────────────────

# Task Breakdown

## 개요
- 총 Tasks: 20개
- 예상 시간: 60시간
- 세션 수: 20-25 세션

## Task 목록

### Phase 1: Domain Models (Easy)
| ID | Task | 예상 | 의존성 |
|----|------|------|--------|
| 001 | User 엔티티 | 2h | - |
| 002 | Order + OrderItem | 3h | 001 |
| 003 | 값 객체 | 1.5h | - |

### Phase 2: Services (Intermediate)
| ID | Task | 예상 | 의존성 |
|----|------|------|--------|
| 005 | 주문 생성 서비스 | 4h | 002 |
| 006 | 주문 조회 서비스 | 2h | 002 |

### Phase 3: Integration (Final)
| ID | Task | 예상 | 의존성 |
|----|------|------|--------|
| 015 | 동시성 처리 | 4h | 005 |
| 016 | KIS API 연동 | 4h | 005 |

## 의존성 다이어그램
[Mermaid 또는 ASCII]

## 우선순위
1. 핵심 경로: 001 → 002 → 005 → 016
2. 병렬 가능: 003, 006
```

---

### 6.3 Stage 9: Checklist + 구현

#### 목표
TDD 기반 9-Step 체크리스트 작성 및 실행

#### 9-Step Checklist 구조

````
09L-001_user_entity.md
────────────────────────────

# Task 001: User 엔티티 체크리스트

## 메타 정보
- Task ID: 001
- Blueprint 참조: 07B-01 Section 3.1
- 의존성: 없음
- 예상 시간: 2시간

## Step 1: 목표 이해 ✅
────────────────────────────────
[ ] Blueprint Section 3.1 읽기
[ ] PROJECT_STANDARDS DB 규칙 확인
[ ] 관련 ADR 확인 (ADR-003)

예상 산출물:
- src/domain/entities/user.py
- tests/unit/domain/test_user.py

## Step 2: 테스트 작성 🧪
────────────────────────────────
[ ] 테스트 파일 생성
[ ] User 생성 테스트
[ ] User 필드 검증 테스트
[ ] User ID 형식 테스트 (UUIDv7)

```python
# tests/unit/domain/test_user.py
def test_user_creation():
    user = User(email="test@example.com")
    assert user.id is not None
    assert user.email == "test@example.com"
    assert user.created_at is not None

def test_user_id_is_uuidv7():
    user = User(email="test@example.com")
    # UUIDv7 검증 로직
    assert is_valid_uuidv7(user.id)
```

## Step 3: 구현 🔨
────────────────────────────────
[ ] User 모델 작성
[ ] ID 생성 로직
[ ] 타임스탬프 자동 설정
[ ] soft delete 필드

```python
# src/domain/entities/user.py
from core.types import UserId
from core.database import Base

class User(Base):
    __tablename__ = "users"
    
    id: UserId = Field(default_factory=generate_uuidv7)
    email: str
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    deleted_at: datetime | None = None
```

## Step 4: 정적 검증 🔍
────────────────────────────────
[ ] Lint 실행: `[lint-tool] check src/domain/entities/user.*`
[ ] Type Check 실행: `[type-check-tool] src/domain/entities/user.*`
[ ] 0 violations 확인

## Step 5: 단위 테스트 실행 ✅
────────────────────────────────
[ ] 테스트 실행: `[test-framework] tests/unit/domain/test_user.* -v`
[ ] 모든 테스트 통과 확인
[ ] 커버리지 확인: `[test-framework] --cov=src/domain/entities/user`

## Step 6: 리팩토링 🔄
────────────────────────────────
[ ] 중복 코드 제거
[ ] 네이밍 개선
[ ] 타입 힌트 완성
[ ] 문서화 (주석/docstring)

## Step 7: 종합 테스트 🧪
────────────────────────────────
[ ] 전체 테스트 실행: `[test-framework] tests/ -v`
[ ] 기존 테스트 깨지지 않음 확인
[ ] 커버리지 95%+ 확인

## Step 8: 문서화 📝
────────────────────────────────
[ ] 모듈 docstring 작성
[ ] 주요 함수 docstring
[ ] 사용 예시 추가 (필요시)

## Step 9: 커밋 ✅
────────────────────────────────
[ ] pre-commit 통과 확인
[ ] 커밋 메시지 작성
    ```
    feat(domain): add User entity
    
    - Add User model with UUIDv7 ID
    - Add soft delete support
    - Add unit tests (100% coverage)
    
    Refs: Task-001, ADR-003
    ```

[ ] 커밋

## 완료 조건
────────────────────────────────

- [ ] Ruff 0 violations
- [ ] MyPy 0 errors
- [ ] 테스트 100% 통과
- [ ] 커버리지 95%+
- [ ] pre-commit 통과
- [ ] 커밋 완료
````

#### 체크리스트 작성 원칙

```markdown
1. 복사-붙여넣기 가능
   ────────────────────────────────
   모든 명령어는 그대로 실행 가능해야 함

❌ "테스트를 실행하세요"
✅ "[test-framework] tests/unit/domain/test_user.* -v"

2. 구체적인 코드 예시
   ────────────────────────────────
   예상되는 코드 구조를 미리 제시

❌ "User 모델을 구현하세요"
✅ 실제 코드 스니펫 제공

3. 검증 가능한 완료 조건
   ────────────────────────────────
   ❌ "잘 작동해야 함"
   ✅ "Ruff 0, MyPy 0, 테스트 100% 통과"

4. 참조 명확
   ────────────────────────────────
   ❌ "표준을 따르세요"
   ✅ "PROJECT_STANDARDS.md Ln 45-60 참조"
```

---

## Part 7: AI 협업 기법

### 7.1 인지 글쓰기 이론 기반

```markdown
Flower & Hayes (1981) - 인지 글쓰기 프로세스:

┌─────────────────────────────────────────────────────────┐
│                   글쓰기 = 문제 해결                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│   ┌─────────┐                                          │
│   │ 기획    │ ← 아이디어 생성, 구조화, 목표 설정       │
│   │Planning │                                          │
│   └────┬────┘                                          │
│        ↓                                               │
│   ┌─────────┐                                          │
│   │ 작성    │ ← 아이디어를 텍스트로 변환               │
│   │Translating│                                        │
│   └────┬────┘                                          │
│        ↓                                               │
│   ┌─────────┐                                          │
│   │ 검토    │ ← 평가, 수정, 개선                       │
│   │Reviewing│                                          │
│   └────┬────┘                                          │
│        │                                               │
│        └────→ 반복...                                  │
│                                                         │
└─────────────────────────────────────────────────────────┘

DNA 방법론 적용:
├─ 기획 = Stage 1-3 (ADR까지)
├─ 작성 = Stage 7-9 (Blueprint → 구현)
├─ 검토 = 각 Stage의 검증 단계
└─ 반복 = 세션 단위 점진적 완성
```
### 7.2 Skeleton-of-Thought (SoT) - 구조 우선

#### 원리

```markdown
전통적 방식:
────────────────────────────────
시작 → 서론 작성 → 본론 1 → 본론 2 → ... → 결론
(순차적, 한 줄로)

문제:
├─ 앞부분에서 시간 소모
├─ 전체 구조 놓침
├─ 논리적 표류 발생
└─ 뒷부분 품질 저하

SoT 방식:
────────────────────────────────
Step 1: 뼈대 (Skeleton) 생성
┌───────────────────────────────┐
│ 1. 서론                       │
│ 2. 본론 A                     │
│ 3. 본론 B                     │
│ 4. 본론 C                     │
│ 5. 결론                       │
└───────────────────────────────┘

Step 2: 각 부분 병렬 확장
┌───────────────────────────────┐
│ 1. 서론 ────→ [상세 내용]    │
│ 2. 본론 A ──→ [상세 내용]    │  병렬 처리
│ 3. 본론 B ──→ [상세 내용]    │  가능
│ 4. 본론 C ──→ [상세 내용]    │
│ 5. 결론 ────→ [상세 내용]    │
└───────────────────────────────┘

장점:
├─ 전체 구조 먼저 확정
├─ 논리적 표류 방지
├─ 병렬 작업 가능 (여러 세션)
└─ 일관성 유지
```

#### DNA 적용: Blueprint 작성

```markdown
Stage 7 Blueprint에 SoT 적용:

세션 1: 뼈대 생성
────────────────────────────────
1. 시스템 개요
2. 아키텍처 구조
3. 도메인 모델
4. API 설계
5. 데이터베이스 설계
6. 외부 연동
7. 에러 처리
8. 보안
9. 다음 단계

→ 목차만 작성 (10분)
→ 각 섹션 2-3줄 요약

세션 2: 섹션 1-3 확장
────────────────────────────────
각 섹션 상세 내용 작성
ADR 참조 추가
다이어그램 포함

세션 3: 섹션 4-6 확장
────────────────────────────────
API 스펙 상세화
테이블 스키마 정의
외부 API 연동 명세

세션 4: 섹션 7-9 확장 + 검토
────────────────────────────────
에러 코드 정의
보안 정책 명세
전체 일관성 검토
```
#### 프롬프트 템플릿

```markdown
SoT 뼈대 생성 프롬프트:

"[주제]에 대한 문서를 작성하려 합니다.
먼저 전체 구조(목차)만 작성해주세요.
각 섹션은 제목과 2-3줄 요약만 포함합니다.
상세 내용은 이후 별도로 작성합니다."

SoT 확장 프롬프트:

"아래 목차의 섹션 [N-M]을 상세하게 작성해주세요.
[목차 제공]
[관련 ADR/참조 문서 제공]
다른 섹션은 작성하지 마세요."
```
---

### 7.3 Chain of Density (CoD) - 정보 밀도 증가

#### 원리

```markdown
전통적 요약:
────────────────────────────────
원문 1000자 → 요약 200자
(한 번에 압축, 정보 손실 큼)

CoD 방식:
────────────────────────────────
Round 1: 초기 요약 (200자)
├─ 핵심 주제 파악
└─ 기본 구조 유지

Round 2: 밀도 증가 (200자 유지)
├─ 불필요한 수식어 제거
├─ 새로운 핵심 정보 추가
└─ 더 많은 내용을 같은 길이에

Round 3: 밀도 증가 (200자 유지)
├─ 추가 압축
├─ 더 많은 엔티티 포함
└─ 문장 구조 최적화

Round 4-5: 최종 밀도
├─ 최대 정보 밀도 달성
├─ 핵심만 남김
└─ 읽기 어려우면 롤백

핵심:
├─ 길이 고정 (200자)
├─ 정보량 증가 (매 라운드)
└─ 4-5회 반복
```
#### DNA 적용: 요구사항 정제

```markdown
Stage 1-2에서 CoD 적용:

원본 (사용자 요청):
────────────────────────────────
"주식 거래할 수 있는 앱을 만들고 싶어요.
한국투자증권 API를 사용하고요.
실시간으로 시세도 보고 싶고
주문도 넣을 수 있으면 좋겠어요.
자동매매도 나중에 추가하고 싶어요."

Round 1 (요약):
────────────────────────────────
"한국투자증권 API 기반 주식 거래 앱.
실시간 시세 조회, 주문 기능 필요.
자동매매는 추후 확장."

Round 2 (밀도 증가):
────────────────────────────────
"KIS API 기반 주식 거래 플랫폼.
핵심: 실시간 시세(WebSocket), 주문 CRUD.
패밀리: A-A-B (거래 정확성 최우선).
확장: 자동매매 (Phase 2)."

Round 3 (밀도 증가):
────────────────────────────────
"KIS API 주식 거래 플랫폼.
실시간 시세(WS) + 주문(REST/ACID).
A-A-B 패밀리, NFR: 정확성>속도>가용성.
제약: KIS 20req/s, KRX 09:00-15:30.
확장: 자동매매 (조건부 주문)."

Round 4 (최종):
────────────────────────────────
"KIS API 주식 거래 (A-A-B)
├─ 시세: WebSocket 실시간
├─ 주문: REST + PostgreSQL ACID
├─ NFR: 정확성 A, 속도 A, 가용성 A
├─ 제약: 20req/s, 09:00-15:30
└─ Phase 2: 조건부 자동매매"
```

#### 프롬프트 템플릿

```markdown
CoD 적용 프롬프트:

"아래 요구사항을 5줄로 요약해주세요.
[요구사항 제공]

이제 같은 5줄을 유지하면서,
더 많은 핵심 정보를 포함하도록 다시 작성해주세요.
불필요한 수식어를 제거하고, 새로운 엔티티를 추가하세요.

이 과정을 3번 더 반복합니다."
```
---

### 7.4 Tree of Thoughts (ToT) - 대안 탐색

#### 원리

```markdown
전통적 방식 (단일 경로):
────────────────────────────────
문제 → 해결책 1 → 구현
(첫 번째 아이디어에 고착)

ToT 방식 (다중 경로):
────────────────────────────────
          문제
            │
     ┌──────┼──────┐
     ↓      ↓      ↓
   해결책1 해결책2 해결책3
     │      │      │
   평가    평가    평가
   (60점) (85점) (70점)
            │
            ↓
        해결책2 선택
            │
     ┌──────┼──────┐
     ↓      ↓      ↓
   구현A   구현B   구현C
     │      │      │
   평가    평가    평가
            │
            ↓
        최적 경로 완성

핵심:
├─ 여러 대안 생성
├─ 각 대안 평가 (점수화)
├─ 최적 선택
├─ 역추적 가능 (막히면)
└─ BFS/DFS 탐색
```
#### DNA 적용: ADR 대안 비교

```markdown
Stage 3 ADR에서 ToT 적용:

문제: "데이터베이스 선택"

Step 1: 대안 생성
────────────────────────────────
대안 1: PostgreSQL
대안 2: MySQL
대안 3: MongoDB

Step 2: 평가 기준 정의
────────────────────────────────
├─ ACID 지원 (필수)
├─ JSON 지원 (중요)
├─ 팀 경험 (중요)
├─ 성능 (보통)
└─ 비용 (보통)

Step 3: 각 대안 평가
────────────────────────────────

| 기준   | PostgreSQL | MySQL | MongoDB |
| ------ | ---------- | ----- | ------- |
| ACID   | 10/10      | 9/10  | 6/10    |
| JSON   | 9/10       | 6/10  | 10/10   |
| 팀경험 | 8/10       | 8/10  | 4/10    |
| 성능   | 8/10       | 9/10  | 8/10    |
| 비용   | 10/10      | 10/10 | 6/10    |
| 총점   | 45         | 42    | 34      |

Step 4: 최적 선택
────────────────────────────────
PostgreSQL 선택 (45점)

근거:
├─ ACID 완전 지원 (필수 요건)
├─ JSONB로 유연성 확보
├─ 팀 경험 있음
└─ 오픈소스 (비용 절감)

역추적 조건:
├─ 성능 문제 심각 시 → MySQL 재검토
├─ 스키마리스 필요 시 → MongoDB 재검토
```
#### 프롬프트 템플릿

```markdown
ToT 적용 프롬프트:

"[문제]에 대해 3가지 대안을 제시해주세요.

각 대안에 대해:

1. 장점 3가지
2. 단점 3가지
3. 적합한 상황
4. 점수 (10점 만점)

평가 기준:

- [기준 1] (가중치: 높음)
- [기준 2] (가중치: 중간)
- [기준 3] (가중치: 낮음)

최종적으로 하나를 선택하고 근거를 설명해주세요.
역추적 조건(언제 재검토해야 하는지)도 명시해주세요."
```
---

### 7.5 RDoLT - 난이도별 분해

#### 원리

```
전통적 분해:
────────────────────────────────
전체 기능 → 균등 분할
(복잡도 고려 없음)

RDoLT 방식:
────────────────────────────────
Level 1 - Easy:
├─ 기본 CRUD
├─ 단순 모델
├─ 명확한 로직
└─ 의존성 없음

Level 2 - Intermediate:
├─ 엔티티 간 관계
├─ 서비스 통합
├─ 트랜잭션
└─ 외부 연동 (단순)

Level 3 - Final:
├─ 에러 처리
├─ 동시성
├─ 성능 최적화
├─ 보안
└─ 예외 상황

작업 순서:
Easy → Intermediate → Final
(기반부터, 복잡한 것은 나중에)
```
#### DNA 적용: Task Breakdown

```
Stage 8 Task Breakdown에 RDoLT 적용:

전체 기능: "주문 시스템"

Level 1 - Easy (먼저):
────────────────────────────────
Task 001: Order 엔티티 기본 필드
Task 002: OrderItem 엔티티
Task 003: OrderStatus 열거형
Task 004: 기본 Repository

Level 2 - Intermediate (다음):
────────────────────────────────
Task 005: 주문 생성 서비스 (트랜잭션)
Task 006: Order-OrderItem 관계 처리
Task 007: 주문 조회 서비스 (조인)
Task 008: KIS API 연동 (기본)

Level 3 - Final (마지막):
────────────────────────────────
Task 009: 동시 주문 처리 (락)
Task 010: 부분 체결 처리
Task 011: 주문 실패 복구
Task 012: 주문 취소/정정
Task 013: 성능 최적화 (인덱스, 캐시)
Task 014: 보안 검증 (권한, 한도)
```
#### 프롬프트 템플릿

```
RDoLT 적용 프롬프트:

"[기능]을 구현하기 위한 Task를 분해해주세요.

3단계로 분류합니다:

Level 1 - Easy (기본):

- 단순 모델, CRUD, 명확한 로직
- 의존성 없음

Level 2 - Intermediate (상호작용):

- 엔티티 관계, 서비스 통합, 트랜잭션
- Level 1에 의존

Level 3 - Final (고급):

- 에러 처리, 동시성, 성능, 보안
- Level 1, 2에 의존

각 Task는:

- 2-4시간 분량
- 독립 테스트 가능
- 명확한 완료 조건"
```
---

### 7.6 Stage별 기법 적용 요약

```
┌─────────────────────────────────────────────────────────┐
│ Stage │ 기법 │ 적용 목적                                │
├───────┼──────┼─────────────────────────────────────────┤
│ 1     │ CoD  │ 아이디어 → 정제된 요구사항               │
│       │ RDoLT│ 핵심 기능 파악 (Easy부터)               │
├───────┼──────┼─────────────────────────────────────────┤
│ 2     │ CoD  │ 제약조건 정리                           │
│       │ ToT  │ 충돌 패턴 분석                          │
├───────┼──────┼─────────────────────────────────────────┤
│ 3     │ ToT  │ ADR 대안 비교, 결정 근거                │
├───────┼──────┼─────────────────────────────────────────┤
│ 4-6   │ SoT  │ DNA 청사진 구조화                       │
├───────┼──────┼─────────────────────────────────────────┤
│ 7     │ SoT  │ Blueprint 목차 먼저, 확장               │
├───────┼──────┼─────────────────────────────────────────┤
│ 8     │ RDoLT│ Task 난이도별 분해                      │
│       │ SoT  │ Task 구조화                             │
├───────┼──────┼─────────────────────────────────────────┤
│ 9     │ SoT  │ Checklist 구조                          │
└─────────────────────────────────────────────────────────┘
```
---

## 마무리

### 이 문서의 위치

```
┌─────────────────────────────────────────────────────────┐
│ Tier 1: Overview (빠른 파악)                            │
│ 00_CORE_METHODOLOGY.md                                │
│ → 전체 맥락, 현재 위치                                 │
└───────────────────────┬─────────────────────────────────┘
                        │
                        ↓
┌─────────────────────────────────────────────────────────┐
│ Tier 2: Detailed (상세 참조) ← 현재 문서               │
│ 01_DNA_METHODOLOGY_DETAILED.md                            │
│ → 실제 작업 시 참조                                    │
└───────────────────────┬─────────────────────────────────┘
                        │
                        ↓
┌─────────────────────────────────────────────────────────┐
│ Tier 3: Stage별 가이드                                │
│ STAGE_1_GUIDE.md, STAGE_2_GUIDE.md, ...               │
│ → 각 Stage 실행 시 로드                                │
└─────────────────────────────────────────────────────────┘
```
---

**문서 작성 완료**: 2025-12-02
**총 라인 수**: ~1900줄
**참조**: 00_CORE_METHODOLOGY.md, GEMINI_RESEARCH_SYNTHESIS.md
